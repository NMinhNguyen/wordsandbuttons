<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Simple image vectorization</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
    width: 300pt;
}

table {
    border-width: 0pt;
}

td {
    vertical-align: top;
    padding: 6pt 12pt 6pt 12pt;
    font-size: 16pt;
    border: 1px solid black;
    width: 600pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

input[type="text"] {
    width: 48pt;
    height: 22pt;
    font-size: 16pt;
    text-align: center;
}

input[type="radio"] {
    height: 16pt;
    width: 16pt;
    font-size: 16pt;
}

button {
    width: 128pt;
    height: 26pt;
    font-size: 16pt;
    text-align: center;
}

textarea {
    width: 505pt;
    font-size: 12pt;
    font-family: monospace;
}

.comment {
    font-size: 12pt;
    text-align:center;
    font-family: sans-serif;
    padding-bottom: 24pt;
}

.formula {
    font-family: sans-serif;
    font-size: 15pt;
    font-style: italic;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

    </style>
    <script language="JavaScript">
// client
var w = 640.0;
var h = 640.0;

// algorithm
var threshold = 0.5;

// pixels
var pixels = [];
var pixel_size;

function reset_pixels(w, h) {
    pixels = [];
    for(var i = 0; i < h; ++i) {
        pixelsi = []
        for(var j = 0; j <w; ++j)
            pixelsi.push(0);
        pixels.push(pixelsi);
    }
}

var points_and_tangents = [];
var splines = [];

// solver specific to [0..1] parametrized splines
function spline_for(p1, p1d, p2, p2d) {
//     A = [
//         [1, 0, 0, 0],
//         [0, 1, 0, 0],
//         [1, 1, 1, 1],
//         [0, 1, 2, 3]];
//     B = [p1, p1d, p2, p2d]
    return [
        p1,
        p1d,
        3 * p2 - p2d - 3*p1 - 2*p1d,
        p2d + p1d - 2*p2 + 2*p1
    ];
}

// polynomial
function polynomial_in_t(A, t){
    var pt = 0.0;
    for(var i = 0; i < A.length; ++i){
        pt += A[i] * Math.pow(t, i);
    }
    return pt;
}

// pixel value with out of bounds checks
function pixel_in(pixels, i, j) {
    if(i >= pixels.length)
        return pixel_in(pixels, pixels.length-1, j);
    if(i < 0) 
        return pixel_in(pixels, 0, j);
    if(j >= pixels[0].length)
        return pixel_in(pixels, i, pixels[0].length-1);
    if(j < 0)
        return pixel_in(pixels, i, 0);
    return pixels[i][j];
}

// linear interpolation
function value_in(pixels, x, y) {
    var j = Math.floor(x - 0.5);
    var tj = x - 0.5 - j;
    var i = Math.floor(y - 0.5);
    var ti = y - 0.5 - i;
    return pixel_in(pixels, i, j) * (1 - ti) * (1 - tj)
         + pixel_in(pixels, i, j+1) * (1 - ti) * (tj)
         + pixel_in(pixels, i+1, j+1) * (ti) * (tj)
         + pixel_in(pixels, i+1, j) * (ti) * (1 - tj);
}

// gradient
function gradient(pixels, x, y) {
    const epsilon = 1e-5;
    return [(value_in(pixels, x + epsilon, y) - value_in(pixels, x, y)) / epsilon,
            (value_in(pixels, x, y + epsilon) - value_in(pixels, x, y)) / epsilon];
}

// how far should you shift the point to meet the isoline 
// if value_in were a distance function
function gradient_shift(pixels, threshold, x, y) {
    var g = gradient(pixels, x, y);
    var g_norm = Math.sqrt(g[0]*g[0] + g[1]*g[1]);
    var d = threshold - value_in(pixels, x, y);
    return [g[0] * d / g_norm / g_norm, g[1] * d / g_norm / g_norm];
}

// brings a point closer to the threshold isoline
function fit_point_better(pixels, threshold, point) {
    const small_enough_error = 1/255;
    if(Math.abs(value_in(pixels, point[0], point[1]) - threshold) < small_enough_error)
        return point;
    gs = gradient_shift(pixels, threshold, point[0], point[1])
    return fit_point_better(pixels, threshold, [point[0] + gs[0], point[1] + gs[1]]);
}

// the algorithm itself
function turn_pixels_into_points_and_tangents(pixels, threshold) {
    var points = [];
    var tangents = [];

    // "horizontal" pieces    
    for(var i = 0; i <= pixels.length; i += 1) {
        var old_point = [];
        var old_tangent = [];
        for(var j = 0; j <= pixels[0].length; j += 1) {
            // if right, left, top, and bottom pixels have a sign change, there should be a spline there
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;
            if(sign_change_on_the_right || sign_change_on_the_left) {
                // fits the point on a threshold isoline
                var point = fit_point_better(pixels, threshold, [j, i]);
                var g = gradient(pixels, point[0], point[1]);
                
                // we want our tangent to be X-positive for horizontal pieces
                var tangent = g[1] >= 0 ? [g[1], -g[0]] : [-g[1], g[0]];
                
                // this is an T or X junction, the tangent is ambiguous
                if(sign_change_on_the_left + sign_change_on_the_right + sign_change_on_the_top + sign_change_on_the_bottom > 2)
                    tangent = [0., 0.];
                    
                // store the point+tangent and the previous point+tangent if there is one
                if(sign_change_on_the_left && old_point) {                    
                    points.push([old_point, point]);
                    tangents.push([old_tangent, tangent]);
                }
                
                // save the point+tangent for later
                if(sign_change_on_the_right) {
                    old_point = point;
                    old_tangent = tangent;
                }   
            }      
        }
    }

    // "vertical" pieces
    for(var j = 0; j <= pixels[0].length; j += 1) {
        var old_point = [];
        var old_tangent = [];
        for(var i = 0; i <= pixels.length; i += 1) {
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;
            if(sign_change_on_the_bottom || sign_change_on_the_top) {
                var point = fit_point_better(pixels, threshold, [j, i]);
                var g = gradient(pixels, point[0], point[1]);             
                var tangent = g[0] < 0 ? [g[1], -g[0]] : [-g[1], g[0]];
                if(sign_change_on_the_left + sign_change_on_the_right + sign_change_on_the_top + sign_change_on_the_bottom > 2)
                    tangent = [0., 0.];
                if(sign_change_on_the_top && old_point) {
                    points.push([old_point, point]);
                    tangents.push([old_tangent, tangent]);
                }
                if(sign_change_on_the_bottom) {
                    old_point = point;
                    old_tangent = tangent;
                }   
            }      
        }
    }
    return [points, tangents];
}

function turn_points_and_tangents_into_splines(points_and_tangents)
{
    var splines = [];
    var points = points_and_tangents[0];
    var tangents = points_and_tangents[1];
    for(var i = 0; i < points.length; ++i) {
        var Px = spline_for(points[i][0][0], tangents[i][0][0], points[i][1][0], tangents[i][1][0]);
        var Py = spline_for(points[i][0][1], tangents[i][0][1], points[i][1][1], tangents[i][1][1]);
        splines.push([Px, Py]);
    }
    return splines
}

function draw_the_splines(context, splines) {
    context.beginPath();
    for(var i = 0; i < splines.length; ++i) {
        for(var k = 0; k < pixel_size; k += 1) {
            var t1 = (k) / pixel_size;
            var t2 = (k + 1) / pixel_size;
            var x1 = polynomial_in_t(splines[i][0], t1) * pixel_size;
            var y1 = polynomial_in_t(splines[i][1], t1) * pixel_size;
            var x2 = polynomial_in_t(splines[i][0], t2) * pixel_size;
            var y2 = polynomial_in_t(splines[i][1], t2) * pixel_size;
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
        }
    }
    
    context.strokeStyle="#AA3366";
    context.lineWidth = 3;
    context.stroke();
    context.closePath();    
}

// gray-scale canvas
function draw_greyscale_canvas() {
    var canvas = document.getElementById("greyscale_canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var pixel_value = Math.max(Math.min(pixels[in_pixels_i][in_pixels_j], 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;
    }
    context.putImageData(pixel_field, -0.5, -0.5);
    
    // pixel grid
    context.beginPath();
    for(var i = pixel_size; i <= h; i += pixel_size) {
        context.moveTo(0.0, i);
        context.lineTo(w, i);
    }
    for(var j = pixel_size; j <= w; j += pixel_size) {
        context.moveTo(j, 0.0);
        context.lineTo(j, h);
    }
    context.strokeStyle="#AAAAAA";
    context.lineWidth=1;
    context.setLineDash([4, 4]);
    context.stroke();
    context.setLineDash([]);
    context.closePath();
    
    context.font = "14px Arial";
    context.fillStyle = "#000000";
    context.textAlign = "center";
    context.textBaseline = "middle"; 
    for(var i = 0; i < pixels.length; ++i) {
        for(var j = 0; j< pixels[0].length; ++j) {
           context.fillText(Math.floor(255 * pixels[i][j]).toString(), (j + 0.5) * pixel_size, (i + 0.5) * pixel_size);
        }
    }
}

// gray-scale canvas contour
function draw_greyscale_canvas_contour() {
    var canvas = document.getElementById("greyscale_canvas_contour");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var pixel_value = Math.max(Math.min(pixels[in_pixels_i][in_pixels_j], 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;
        if ( pixel_in(pixels, in_pixels_i, in_pixels_j) < threshold 
          != pixel_in(pixels, Math.floor((on_canvas_i - 1) / pixel_size), in_pixels_j) < threshold 
        ||   pixel_in(pixels, in_pixels_i, in_pixels_j) < threshold 
          != pixel_in(pixels, in_pixels_i, Math.floor((on_canvas_j - 1) / pixel_size)) < threshold) {
            pixel_field.data[i + 0] = 0x11;
            pixel_field.data[i + 1] = 0x11;
            pixel_field.data[i + 2] = 0x11;
        }
           
    }
    context.putImageData(pixel_field, -0.5, -0.5);
}

// interpolation canvas
function draw_interpolation_canvas() {
    var canvas = document.getElementById("interpolation_canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var interpolated_in = function (pixels, x, y) {
        return value_in(pixels, x, y);
    }
    if(document.getElementById("interpolation_1").checked) {
        interpolated_in = function (pixels, x, y) {
            return pixel_in(pixels, Math.floor(y), Math.floor(x));
        }
    }
    
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var x = on_canvas_j / pixel_size;
        var y = on_canvas_i / pixel_size;
        var pixel_value = Math.max(Math.min(interpolated_in(pixels, x, y), 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;
        if ( interpolated_in(pixels, x, y) < threshold 
          != interpolated_in(pixels, x - 1 / pixel_size, y) < threshold 
        ||   interpolated_in(pixels, x, y) < threshold 
          != interpolated_in(pixels, x, y - 1 / pixel_size) < threshold) {
            pixel_field.data[i + 0] = 0x11;
            pixel_field.data[i + 1] = 0x11;
            pixel_field.data[i + 2] = 0x11;
        }
           
    }
    context.putImageData(pixel_field, -0.5, -0.5);
}

// fitting
function fit_point_several_times(pixels, threshold, point, n) {
    const small_enough_error = 1/255;
    if(n == 0)
        return point;
    gs = gradient_shift(pixels, threshold, point[0], point[1])
    return fit_point_several_times(pixels, threshold, [point[0] + gs[0], point[1] + gs[1]], n-1);
}

var fit_iterations = 0;

function fit_the_point_iteration() {
    fit_iterations++;
    if(fit_iterations > 0 && fit_iterations < 4)
        document.getElementById("fitting_button").innerHTML = "Fit more";        
    else if (fit_iterations == 4)
        document.getElementById("fitting_button").innerHTML = "Start over"; 
    else if (fit_iterations == 5) {
        document.getElementById("fitting_button").innerHTML = "Fit the contour"; 
        fit_iterations = 0;
    }
    draw_fitting_canvas();
}

function draw_fitting_canvas(){
    var canvas = document.getElementById("fitting_canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var x = on_canvas_j / pixel_size;
        var y = on_canvas_i / pixel_size;
        var pixel_value = Math.max(Math.min(value_in(pixels, x, y), 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;          
    }
    context.putImageData(pixel_field, -0.5, -0.5);
    
    // contour
    context.beginPath();
    // "horizontal" pieces    
    for(var i = 0; i <= pixels.length; i += 1) {
        var old_point = [];
        for(var j = 0; j <= pixels[0].length; j += 1) {
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;
            if(sign_change_on_the_right || sign_change_on_the_left) {
                var point = fit_point_several_times(pixels, threshold, [j, i], fit_iterations);
                    
                // draw the line
                if(sign_change_on_the_left && old_point) {                    
                    context.moveTo(old_point[0] * pixel_size, old_point[1] * pixel_size);
                    context.lineTo(point[0] * pixel_size, point[1] * pixel_size);
                }
                
                // save the point+tangent for later
                if(sign_change_on_the_right) {
                    old_point = point;
                }   
            }      
        }
    }

    // "vertical" pieces
    for(var j = 0; j <= pixels[0].length; j += 1) {
        var old_point = [];
        for(var i = 0; i <= pixels.length; i += 1) {
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;
            if(sign_change_on_the_bottom || sign_change_on_the_top) {
                var point = fit_point_several_times(pixels, threshold, [j, i], fit_iterations);
                if(sign_change_on_the_top && old_point) {
                    context.moveTo(old_point[0] * pixel_size, old_point[1] * pixel_size);
                    context.lineTo(point[0] * pixel_size, point[1] * pixel_size);
                }
                if(sign_change_on_the_bottom) {
                    old_point = point;
                }   
            }      
        }
    }
    context.strokeStyle="#AA3366";
    context.lineWidth = 3;
    context.stroke();
    context.closePath(); 
}

// cubic
var cubic_xs = [170, 120, 500, 600];
var cubic_ys = [200, 400, 550, 100];
var cubic_n = 4;
var cubic_i = 0;


function init_cubic(){
    cubic = document.getElementById("cubic_canvas");
    var canvas_rect = cubic.getBoundingClientRect();
    draw_cubic_canvas(0, 0, false);

    cubic.addEventListener('mousemove', function(e){
        var canvas_rect = cubic.getBoundingClientRect();
        draw_cubic_canvas(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1){
            cubic_xs[cubic_i] = e.clientX - canvas_rect.left;
            cubic_ys[cubic_i] = e.clientY - canvas_rect.top;
            draw_cubic_canvas(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
        }
    }, false);

    cubic.addEventListener('mousedown', function(e){
        var canvas_rect = cubic.getBoundingClientRect();
        cubic_xs[cubic_i] = e.clientX - canvas_rect.left;
        cubic_ys[cubic_i] = e.clientY - canvas_rect.top;
        draw_cubic_canvas(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
    }, false);

    cubic.addEventListener('mouseleave', function(e){
        draw_cubic_canvas(0, 0, false);
    }, false);
}

function draw_cubic_canvas(client_x, client_y, do_guides){
    cubic = document.getElementById("cubic_canvas");
    var context = cubic.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);
    
    var Px = spline_for(cubic_xs[1], cubic_xs[0] - cubic_xs[1], cubic_xs[2], cubic_xs[3] - cubic_xs[2]);
    var Py = spline_for(cubic_ys[1], cubic_ys[0] - cubic_ys[1], cubic_ys[2], cubic_ys[3] - cubic_ys[2]);
    
    context.beginPath();
    for(var i = 0; i < w; ++i) {    
        var t1 = (i) / w;
        var t2 = (i + 1) / w;
        var x1 = polynomial_in_t(Px, t1);
        var y1 = polynomial_in_t(Py, t1);
        var x2 = polynomial_in_t(Px, t2);
        var y2 = polynomial_in_t(Py, t2);
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
    }
    context.strokeStyle="#AA3366";
    context.lineWidth = 3;
    context.stroke();
    context.closePath();
    context.lineWidth = 1;
    
    // dots
    for(var i = 0; i < cubic_n; ++i){
        context.beginPath();
        context.arc(cubic_xs[i], cubic_ys[i], 3, 0, 2*Math.PI);
        context.fillStyle="#6633AA";
        context.fill();
        context.closePath();    
    }

    // tangents
    context.beginPath();
    context.setLineDash([4, 4]);
    context.moveTo(cubic_xs[0], cubic_ys[0]);
    context.lineTo(cubic_xs[1], cubic_ys[1]);
    context.moveTo(cubic_xs[cubic_n-2], cubic_ys[cubic_n-2]);
    context.lineTo(cubic_xs[cubic_n-1], cubic_ys[cubic_n-1]);
    context.strokeStyle="#6633AA";
    context.stroke();
    context.setLineDash([]);
    context.closePath();

    // guides
    if(do_guides){
        min_d = Math.pow(cubic_xs[0] - client_x, 2) + Math.pow(cubic_ys[0] - client_y, 2);
        min_i = 0;
        for(var i = 1; i < cubic_n; ++i){
            var di = Math.pow(cubic_xs[i] - client_x, 2) + Math.pow(cubic_ys[i] - client_y, 2);
            if(di < min_d){
                min_d = di;
                min_i = i;
            }
        }
        cubic_i = min_i;
        context.setLineDash([4, 4]);
        context.beginPath();
        context.moveTo(cubic_xs[min_i], cubic_ys[min_i]);
        context.lineTo(client_x, client_y);
        context.strokeStyle="#6633AA";
        context.stroke();
        context.closePath();
        context.setLineDash([]);
    }
    
    // labels
    context.font = "14px Arial";
    context.fillStyle = "#000000";
    context.textBaseline = "middle"; 
    context.textAlign = "right";
    context.fillText("point 1", cubic_xs[1] - 8, cubic_ys[1]);
    context.textAlign = "left";
    context.fillText("point 2", cubic_xs[2] + 8, cubic_ys[2]);
    context.textAlign = "center";
    context.fillText("tangent 1", (cubic_xs[0] + cubic_xs[1]) / 2, (cubic_ys[0] + cubic_ys[1]) / 2);
    context.fillText("tangent 2", (cubic_xs[2] + cubic_xs[3]) / 2, (cubic_ys[2] + cubic_ys[3]) / 2);

# todo: compute speed integral	    
#	constant speed equation: 
# 1296*ax**4/7 + 432*ax**3*bx + 864*ax**3*cx/5 + 2592*ax**2*ay**2/7 + 432*ax**2*ay*by + 864*ax**2*ay*cy/5 + 1872*ax**2*bx**2/5 + 288*ax**2*bx*cx + 576*ax**2*by**2/5 + 72*ax**2*by*cy + 48*ax**2*cx**2 + 432*ax*ay**2*bx + 864*ax*ay**2*cx/5 + 2592*ax*ay*bx*by/5 + 216*ax*ay*bx*cy + 216*ax*ay*by*cx + 96*ax*ay*cx*cy + 144*ax*bx**3 + 160*ax*bx**2*cx + 144*ax*bx*by**2 + 96*ax*bx*by*cy + 48*ax*bx*cx**2 + 64*ax*by**2*cx + 48*ax*by*cx*cy + 1296*ay**4/7 + 432*ay**3*by + 864*ay**3*cy/5 + 576*ay**2*bx**2/5 + 72*ay**2*bx*cx + 1872*ay**2*by**2/5 + 288*ay**2*by*cy + 48*ay**2*cy**2 + 144*ay*bx**2*by + 64*ay*bx**2*cy + 96*ay*bx*by*cx + 48*ay*bx*cx*cy + 144*ay*by**3 + 160*ay*by**2*cy + 48*ay*by*cy**2 + 64*bx**4/3 + 32*bx**3*cx + 128*bx**2*by**2/3 + 32*bx**2*by*cy + 16*bx**2*cx**2 + 32*bx*by**2*cx + 32*bx*by*cx*cy + 64*by**4/3 + 32*by**3*cy + 16*by**2*cy**2

    
}


// the main canvas
var cur_point_indexes = [];
var cur_point_in_pair_indexes = [];
var cur_tangent_index = -1;
var cur_tangent_in_pair_index = -1;
function init_canvas(){
    var canvas = document.getElementById("canvas");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        var x = e.clientX - canvas_rect.left;
        var y = e.clientY - canvas_rect.top;
        if(document.getElementById("tool_2").checked) { // points
            cur_point_indexes = [];
            cur_point_in_pair_indexes = [];
            var points = points_and_tangents[0];
            var min_d2 = (w+h)*(w+h);
            for(var i = 0; i < points.length; ++i) {
                for(var j = 0; j < 2; ++ j) {
                    var px = pixel_size * points[i][j][0];
                    var py = pixel_size * points[i][j][1];
                    var d2 = (px - x)*(px - x) + (py - y)*(py - y);
                    if(cur_point_indexes.length == 0 || d2 < min_d2) {
                        cur_point_indexes = [i];
                        cur_point_in_pair_indexes = [j];
                        min_d2 = d2;
                    }else if(d2 == min_d2) {
                        cur_point_indexes.push(i);
                        cur_point_in_pair_indexes.push(j);
                    }
                }
            }
        } else if(document.getElementById("tool_3").checked) { // tangents
            cur_tangent_index = -1;
            cur_tangent_in_pair_index = -1;
            var points = points_and_tangents[0];
            var tangents = points_and_tangents[1];
            var min_d2 = (w+h)*(w+h);
            for(var i = 0; i < points.length; ++i) {
                for(var j = 0; j < 2; ++ j) {
                    var px = pixel_size * (points[i][j][0] + tangents[i][j][0]);
                    var py = pixel_size * (points[i][j][1] + tangents[i][j][1]);
                    var d2 = (px - x)*(px - x) + (py - y)*(py - y);
                    if(cur_tangent_index == -1 || d2 < min_d2) {
                        cur_tangent_index = i;
                        cur_tangent_in_pair_index = j;
                        min_d2 = d2;
                    }
                }
            }
        }
    }, false);
     
    canvas.addEventListener('mousemove', function(e){
        if(e.buttons == 1){
            canvas_rect = canvas.getBoundingClientRect();
            var x = e.clientX - canvas_rect.left;
            var y = e.clientY - canvas_rect.top;
            if(document.getElementById("tool_2").checked) { // points
                var points = points_and_tangents[0];
                for(var i = 0; i < cur_point_indexes.length; ++i) {
                    points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][0] = x / pixel_size;
                    points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][1] = y / pixel_size;
                }               
            } else if(document.getElementById("tool_3").checked) { // tangents
                var points = points_and_tangents[0];
                var tangents = points_and_tangents[1];
                tangents[cur_tangent_index][cur_tangent_in_pair_index][0] = x / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][0];
                tangents[cur_tangent_index][cur_tangent_in_pair_index][1] = y / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][1];
                splines = turn_points_and_tangents_into_splines(points_and_tangents);  
            }
            splines = turn_points_and_tangents_into_splines(points_and_tangents);
            draw_canvas();
        }
    }, false);
    
    canvas.addEventListener('mouseup', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        var x = e.clientX - canvas_rect.left;
        var y = e.clientY - canvas_rect.top;
        if(document.getElementById("tool_1").checked) {
            var in_pixels_i = Math.floor(y / pixel_size);
            var in_pixels_j = Math.floor(x / pixel_size);
            pixels[in_pixels_i][in_pixels_j] *= 7;
            if(e.shiftKey)       
                pixels[in_pixels_i][in_pixels_j] += 7;
            else
                pixels[in_pixels_i][in_pixels_j] += 1;
            pixels[in_pixels_i][in_pixels_j] = Math.floor(pixels[in_pixels_i][in_pixels_j]) % 8;
            pixels[in_pixels_i][in_pixels_j] /= 7;
            points_and_tangents = turn_pixels_into_points_and_tangents(pixels, threshold);
            splines = turn_points_and_tangents_into_splines(points_and_tangents);
        } else if(document.getElementById("tool_2").checked) { // points
            var points = points_and_tangents[0];
            for(var i = 0; i < cur_point_indexes.length; ++i) {
                points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][0] = x / pixel_size;
                points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][1] = y / pixel_size;
            }
            splines = turn_points_and_tangents_into_splines(points_and_tangents);  
        } else if(document.getElementById("tool_3").checked) { // tangents
            var points = points_and_tangents[0];
            var tangents = points_and_tangents[1];
            tangents[cur_tangent_index][cur_tangent_in_pair_index][0] = x / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][0];
            tangents[cur_tangent_index][cur_tangent_in_pair_index][1] = y / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][1];
            splines = turn_points_and_tangents_into_splines(points_and_tangents);  
        }
        draw_canvas();            
    }, false);
    
    draw_canvas();
}


function draw_canvas(){
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var pixel_value = Math.max(Math.min(pixels[in_pixels_i][in_pixels_j], 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;
    }
    context.putImageData(pixel_field, -0.5, -0.5);
    
    // pixel grid
    context.beginPath();
    for(var i = pixel_size; i <= h; i += pixel_size) {
        context.moveTo(0.0, i);
        context.lineTo(w, i);
    }
    for(var j = pixel_size; j <= w; j += pixel_size) {
        context.moveTo(j, 0.0);
        context.lineTo(j, h);
    }
    context.strokeStyle="#AAAAAA";
    context.lineWidth=1;
    context.setLineDash([4, 4]);
    context.stroke();
    context.setLineDash([]);
    context.closePath();
    
    // contour
    draw_the_splines(context, splines);
    
    // points if needed
    if(document.getElementById("tool_2").checked) {
        var points = points_and_tangents[0];
        for(var i = 0; i < points.length; ++i) {
            for(var j = 0; j < 2; ++j) {
                context.beginPath();
                context.arc(pixel_size * points[i][j][0], pixel_size * points[i][j][1], 3, 0, 2*Math.PI);
                context.fillStyle="#6633AA";
                context.fill();
                context.closePath();        
            }
        }
    }
    
    // tangents if needed
    if(document.getElementById("tool_3").checked) {
        var points = points_and_tangents[0];
        var tangents = points_and_tangents[1];
        for(var i = 0; i < points.length; ++i) {
            for(var j = 0; j < 2; ++j) {
                context.beginPath();
                context.arc(pixel_size * points[i][j][0], pixel_size * points[i][j][1], 3, 0, 2*Math.PI);
                context.fillStyle="#AA3366";
                context.fill();
                context.closePath();
                
                context.beginPath();
                context.lineWidth=1;
                context.moveTo(pixel_size * points[i][j][0], pixel_size * points[i][j][1]);
                context.lineTo(pixel_size * (points[i][j][0] + tangents[i][j][0]), pixel_size * (points[i][j][1] + tangents[i][j][1]));
                context.strokeStyle="#6633AA";
                context.setLineDash([2, 2]);
                context.stroke();
                context.setLineDash([]);
                context.closePath();
                
                context.beginPath();
                context.arc(
                    pixel_size * (points[i][j][0] + tangents[i][j][0]), 
                    pixel_size * (points[i][j][1] + tangents[i][j][1]), 3, 0, 2*Math.PI);
                context.fillStyle="#6633AA";
                context.fill();
                context.closePath();        
            }
        }
    }
}

// import from PGM
function reimport_image() {
    space_divided = function(text) {
        var new_text = text.replace('\r', ' ');
        new_text = new_text.replace('\n', ' ');
        new_text = new_text.replace('\t', ' ');
        while(true) {
            new_new_text = new_text.replace('  ', ' ');
            if(new_new_text.length == new_text.length)
                return new_text;
            new_text = new_new_text;    
        }
    }
    var text = document.getElementById("import_PGM").value;
    document.getElementById("import_status").innerHTML = "";
    var lines = text.split("\n");
    var no_comments = []
    for(var i = 0; i < lines.length; ++i) {
        var new_line = lines[i].trim();
        if (new_line == "" || new_line[0] == '#')
            continue;
        no_comments.push(new_line);
    }
    var numbers = space_divided(no_comments.join(' ')).split(' ');
    if(numbers[0] != "P2") {
        document.getElementById("import_status").innerHTML = "Sorry, I can only import grayscale Netpbm (*.pgm = 'P2...')";
        return;
    }
    try {
        var new_w = parseInt(numbers[1]);
        var new_h = parseInt(numbers[2]);
        var new_depth = parseInt(numbers[3]);
        if(numbers.length > new_w * new_h + 4) {
            document.getElementById("import_status").innerHTML = "Sorry, there's some extra data I couldn't parse.";
            return;
        }
        if(numbers.length < new_w * new_h + 4) {
            document.getElementById("import_status").innerHTML = "Sorry, not enough data to form an image.";
            return;
        }
        h = w * new_h / new_w;
        document.getElementById("canvas").height = h;
        pixel_size = w / new_w;
        reset_pixels(new_w, new_h);
        for(var i = 0; i < new_h; ++i)
            for(var j = 0; j < new_w; ++j)
                pixels[i][j] = parseInt(numbers[4 + i*new_w + j]) / new_depth;
        points_and_tangents = turn_pixels_into_points_and_tangents(pixels, threshold);
        splines = turn_points_and_tangents_into_splines(points_and_tangents);
    } catch (error) {
        document.getElementById("import_status").innerHTML = "Sorry, couldn't parse that. " + error.message;
    }
    draw_greyscale_canvas();
    draw_greyscale_canvas_contour();
    draw_interpolation_canvas();
    draw_fitting_canvas();
    draw_canvas();  
}


// export to SVG
function export_splines() {
    const printable = function(x) {
        return Math.floor(x * 100);
    };
    var svg = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n";
    svg += "<svg width=\"" + printable(pixels[0].length) + "\" height=\"" + printable(pixels.length);
    svg += "\"\n  viewBox=\"0 0 " + printable(pixels[0].length) + " " + printable(pixels.length) + "\" xmlns=\"http://www.w3.org/2000/svg\">\n";
    for(var i = 0; i < points_and_tangents[0].length; ++i) {
        var p1 = points_and_tangents[0][i][0];
        var p2 = points_and_tangents[0][i][1];
        var p1_n = points_and_tangents[1][i][0];
        var p2_n = points_and_tangents[1][i][1];
        svg += "<path fill=\"none\" stroke=\"rgb(0,0,0)\" \n  d=\"M " + printable(p1[0]) + "," + printable(p1[1]) + " ";
        svg += "C " + printable(p1[0] + p1_n[0] / 3.) + "," + printable(p1[1] + p1_n[1] / 3.); 
        svg += " " +  printable(p2[0] - p2_n[0] / 3.) + "," + printable(p2[1] - p2_n[1] / 3.) + " " + printable(p2[0]) + "," + printable(p2[1]) + "\"/>\n";
    }
    svg += "</svg>\n";
    document.getElementById("export_SVG").value = svg;
}

// ui
function reset_threshold() {
    threshold = parseFloat(document.getElementById("threshold").value);
}

function change_interpolation() {
    draw_interpolation_canvas();
}

// lexical highlighting
function colorized(text) {
    const separators = ['function ', ' if(', 'return ', 'var ', 'const ', ' for(', 
        '\n', '&lt;', '&gt;', ' ', '\t', '.', ',', ':', ';', '+', '-', '/', '*', '(', ')', '<', '>', '[', ']', '{', '}'];
    const brackets = [['//', '\n']];

    function painted_in(line, color) {
        return line.length == 0 ? "" : "<span style=\"color:#" + color + "\">" + line + "</span>";
    }

    function colorized(token) {
        var code_sum = 0;
        for(var i = 0; i < token.length; ++i)
            code_sum += ([1, 7, 11, 13][i % 4] * token.charCodeAt(i));
        var zero_channel = code_sum % 3;
        var color = '' + (zero_channel == 0 ? '3' : '') + (1 + (code_sum % 5) * 2)
            + (zero_channel == 1 ? '3' : '') + (4 + (code_sum % 2) * 5)
            + (zero_channel == 2 ? '3' : '');
        return painted_in(token, color);
    }

    function separated(line, i) {
        if(i == separators.length)
            return colorized(line);
        return line.split(separators[i]).map(function(subline) {
            return separated(subline, i + 1);}).join(separators[i]);
    }

    function unbracketed(line, i) {
        if(i == brackets.length)
            return separated(line, 0);
        var chunks = line.split(brackets[i][0]);
        return unbracketed(chunks[0], i + 1) + chunks.slice(1).map( function(chunk) {
            var in_out_bracket = chunk.split(brackets[i][1]);
            return painted_in(brackets[i][0] + in_out_bracket[0] + (in_out_bracket.length > 1 ? brackets[i][1] : ''), "888") 
                + unbracketed(in_out_bracket.slice(1).join(brackets[i][1]), i + 1);}).join('');
    }

    return unbracketed(text, 0);
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Bezier curve
    </h1>
    
    <h2>
Cubic splines
    </h2>
    <p>
    ...
    </p>
    <canvas id="cubic_canvas" width=640 height=640></canvas>
    
    <script language="JavaScript">
    init_cubic();
    </script>

    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
        <a href="index.html"><img src="favicon.ico"></a>
    </td>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        &nbsp;&larr; there's more.
    </td>
    <td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
        +
        <a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
        <a href="https://twitter.com/wordsandbuttons">Twitter</a> &
        <a href="https://news.ycombinator.com/from?site=wordsandbuttons.online">Hacker News</a>
    </td>
    </tr>
    </table>
    </center>
  </body>
</html>


