<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SWInE</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.results {
    font-family: sans-serif;
    font-size: 14pt;
    width: 505pt;
    text-align: left;
}

.formula {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: italic;
    width: 505pt;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table.footer {
    padding: 64pt 0pt 32pt 0pt;
    background-color: transparent;
    width: 505pt;
}

td.footer {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: normal;
    padding: 0;
    margin: 0;
    border: 0;
}

li {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
    padding-bottom: 6pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

input[type="text"] {
    width: 32pt;
    height: 22pt;
    font-size: 16pt;
    text-align: center;
}

button {
    width: 32pt;
    height: 26pt;
    font-size: 16pt;
    text-align: center;
}
    </style>
    <script language="JavaScript">

// client
var w = 640.0;
var h = 640.0;


var xs = [-1, 140, 500, 500, 140];
var ys = [-1, 140, 140, 500, 500];
var zs = [-1,  64, 128, 196, 255];
// triangles' points are not really ordered
var tris = [[1, 2, 3], [3, 4, 1]];
// but the border's should be. This determines in and out of the model
var border = [[1, 2], [2, 3], [3, 4], [4, 1]];

const wf = function(x) {return 1./Math.pow(x, 2);}    // weight funtion

// point belongs to a triangle
function in_tri(px, py, x1, y1, x2, y2, x3, y3) {
    /* shove it into sympy to get solution
    px, py, x1, y1, x2, y2, x3, y3, a, b = symbols('px py x1 y1 x2 y2 x3 y3 a b')
    solve([
    x1 + a * (x2-x1) + b * (x3-x1) - px,
    y1 + a * (y2-y1) + b * (y3-y1) - py
    ], (a, b))
    */
    var a = (-(px - x1)*(y1 - y3) + (py - y1)*(x1 - x3))/((x1 - x2)*(y1 - y3) - (x1 - x3)*(y1 - y2));
    var b = ((px - x1)*(y1 - y2) - (py - y1)*(x1 - x2))/((x1 - x2)*(y1 - y3) - (x1 - x3)*(y1 - y2));
    return (a >= 0 && b >= 0 && a + b <= 1.);
}

// point projection belongs to an edge
function in_edge(px, py, x1, y1, x2, y2) {
    if((px-x1)*(y2-y1)-(py-y1)*(x2-x1) < 0) // border should be ordered for that
        return false;
    /*
    px, py, x1, y1, x2, y2, a = symbols('px py x1 y1 x2 y2 a')
    solve([(x1 + (x2 - x1) * a - px) * (x2 - x1) + (y1 + (y2 - y1) * a - py) * (y2 - y1)], (a))
    */
    var a = (-px*x1 + px*x2 - py*y1 + py*y2 + x1*x1 - x1*x2 + y1*y1 - y1*y2)/(x1*x1 - 2*x1*x2 + x2*x2 + y1*y1 - 2*y1*y2 + y2*y2);
    return (a >= 0 && a <= 1);
}

// distance squared from (x1, y1) to (x2, y2)
function d2(x1, y1, x2, y2) {
    return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);
}

// project point on edge
function projected_on_edge(px, py, x1, y1, x2, y2) {
     /*
    px, py, x1, y1, x2, y2, a = symbols('px py x1 y1 x2 y2 a')
    solve([(x1 + (x2 - x1) * a - px) * (x2 - x1) + (y1 + (y2 - y1) * a - py) * (y2 - y1)], (a))
    */
    var a = (-px*x1 + px*x2 - py*y1 + py*y2 + x1*x1 - x1*x2 + y1*y1 - y1*y2)/(x1*x1 - 2*x1*x2 + x2*x2 + y1*y1 - 2*y1*y2 + y2*y2);
    return [x1 + (x2 - x1) * a, y1 + (y2 - y1) * a];
}

// distance from (x1, y1) to (x2, y2)
function d(x1, y1, x2, y2) {
    return Math.sqrt(d2(x1, y1, x2, y2));
}

// distance from (x, y) to edge [(x1, y1), (x2, y2)]
function d_e(x, y, x1, y1, x2, y2) {
    const dxe = x2-x1;
    const dye = y2-y1;
    const dx = x-x1;
    const dy = y-y1;
    const area = Math.abs(dxe*dy - dye*dx);
    return area / d(x1, y1, x2, y2);
}

const d_min = 1e-5; // too close

// interpolation on the edge
function z_in_edge(px, py, x1, y1, z1, x2, y2, z2) {
    const pp = projected_on_edge(px, py, x1, y1, x2, y2);
    const d1 = d(pp[0], pp[1], x1, y1);
    const d2 = d(pp[0], pp[1], x2, y2);
    if(d1 < d_min)
        return z1;
    if(d2 < d_min)
        return z2;
    return (z1 * wf(d1) + z2 * wf(d2)) / (wf(d1) + wf(d2));
}

// interpolation in tri
function z_in_tri(px, py, x1, y1, z1, x2, y2, z2, x3, y3, z3) {
    const d1 = d_e(px, py, x1, y1, x2, y2);
    const d2 = d_e(px, py, x2, y2, x3, y3);
    const d3 = d_e(px, py, x3, y3, x1, y1);
    if(d1 < d_min)
        return z_in_edge(px, py, x1, y1, z1, x2, y2, z2);
    if(d2 < d_min)
        return z_in_edge(px, py, x2, y2, z2, x3, y3, z3);
    if(d3 < d_min)
        return z_in_edge(px, py, x3, y3, z3, x1, y1, z1);
    return (z_in_edge(px, py, x1, y1, z1, x2, y2, z2) * wf(d1) 
          + z_in_edge(px, py, x2, y2, z2, x3, y3, z3) * wf(d2) 
          + z_in_edge(px, py, x3, y3, z3, x1, y1, z1) * wf(d3)) 
        / (wf(d1) + wf(d2) + wf(d3));
}

function closest_point_starting_from(x, y, i) {
    for(var j = i + 1; j < xs.length; ++j)
        if(d2(x, y, xs[j], ys[j]) < d2(x, y, xs[i], ys[i]))
            return closest_point_starting_from(x, y, j);
    return i;
}
// finds a closest point from xs, ys to x, y
function closest_point(x, y){
    return closest_point_starting_from(x, y, 1);
}

function init_canvas(){
    var canvas = document.getElementById("canvas");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        const point_i = closest_point(x, y);
        xs[point_i] = x;
        ys[point_i] = y;
        draw_canvas(0, 0, false);
    }, false);
     
    canvas.addEventListener('mousemove', function(e){
         canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;    
        if(e.buttons == 1){
            const point_i = closest_point(x, y);
            xs[point_i] = x;
            ys[point_i] = y;
            draw_canvas(0, 0, false);
        } else {
            draw_canvas(x, y, true);
        }
    }, false);
    
    canvas.addEventListener('mouseup', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        draw_canvas(0, 0, false);
    }, false);
    
    draw_canvas();
}

function draw_arrow(context, x1, y1, x2, y2) {
    var d = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.moveTo(x2 - (y2 - y1) * 6 / d - (x2 - x1) * 16 / d, y2 - (y2 - y1) * 16 / d + (x2 - x1) * 6 / d);
    context.lineTo(x2, y2);
    context.moveTo(x2 + (y2 - y1) * 6 / d - (x2 - x1) * 16 / d, y2 - (y2 - y1) * 16 / d - (x2 - x1) * 6 / d);
    context.lineTo(x2, y2);
    context.stroke();
    context.closePath();
}

function draw_canvas(client_x, client_y, do_guides){
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
    
    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var y = Math.floor(Math.floor(i / 4) / w);
        var x = Math.floor(i / 4) % w;
        var z = 0;
        var z_determined = false;
        for(var j = 0; j < tris.length; ++j)
            if(in_tri(x, y, xs[tris[j][0]], ys[tris[j][0]], xs[tris[j][1]], ys[tris[j][1]], xs[tris[j][2]], ys[tris[j][2]])) {
                z = z_in_tri(x, y, 
                    xs[tris[j][0]], ys[tris[j][0]], zs[tris[j][0]], 
                    xs[tris[j][1]], ys[tris[j][1]], zs[tris[j][1]], 
                    xs[tris[j][2]], ys[tris[j][2]], zs[tris[j][2]]);
                z_determined = true;
            }
        if(!z_determined) {
            var d_min = 10e5;   // large enough
            for(var j = 0; j < border.length; ++j) {
                if(in_edge(x, y, xs[border[j][0]], ys[border[j][0]], xs[border[j][1]], ys[border[j][1]])) {
                    const projected_xy = projected_on_edge(x, y, xs[border[j][0]], ys[border[j][0]], xs[border[j][1]], ys[border[j][1]]);
                    const d_to_porjected_xy = d(x, y, projected_xy[0], projected_xy[1]);
                    if(d_to_porjected_xy < d_min) {
                        z = z_in_edge(x, y, xs[border[j][0]], ys[border[j][0]], zs[border[j][0]], xs[border[j][1]], ys[border[j][1]], zs[border[j][1]]);
                        d_min = d_to_porjected_xy;
                        z_determined = true;
                    }
                }
            }
        }
        if(!z_determined)
            z = zs[closest_point(x, y)];
        const color = Math.trunc(z / 16) * 16;
        pixel_field.data[i + 0] = color;
        pixel_field.data[i + 1] = color;
        pixel_field.data[i + 2] = color;
        pixel_field.data[i + 3] = 0xFF;
    }
    context.putImageData(pixel_field, -0.5, -0.5);
    
    
    // dots
    context.strokeStyle="#d64562";    
    for(var i = 1; i <= 4; ++i){
        context.beginPath();
        context.arc(xs[i], ys[i], 4, 0, 2*Math.PI);
        context.stroke();
        context.closePath();    
    }

    // guides
    if(do_guides){
        const point_i = closest_point(client_x, client_y);
        draw_arrow(context, xs[point_i], ys[point_i], client_x, client_y);
    }
        
    // border
    context.setLineDash([4, 4]);
    for(var i = 0; i < border.length; ++i) {
     context.beginPath();
        context.moveTo(xs[border[i][0]], ys[border[i][0]]);
        context.lineTo(xs[border[i][1]], ys[border[i][1]]);
        context.stroke();
        context.closePath();
    }
    context.setLineDash([]);
}

    </script>
  </head>
  <body>
    <center>
    <canvas id="canvas" width=640 height=640></canvas>
    <script language="JavaScript">
    init_canvas();
    </script>
    </center>
  </body>
</html>
