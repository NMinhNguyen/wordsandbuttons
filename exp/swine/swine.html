<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SWInE</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.results {
    font-family: sans-serif;
    font-size: 14pt;
    width: 505pt;
    text-align: left;
}

.formula {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: italic;
    width: 505pt;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table.footer {
    padding: 64pt 0pt 32pt 0pt;
    background-color: transparent;
    width: 505pt;
}

td.footer {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: normal;
    padding: 0;
    margin: 0;
    border: 0;
}

li {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
    padding-bottom: 6pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

input[type="text"] {
    width: 32pt;
    height: 22pt;
    font-size: 16pt;
    text-align: center;
}

button {
    width: 32pt;
    height: 26pt;
    font-size: 16pt;
    text-align: center;
}
    </style>
    <script language="JavaScript">
// todo: basis functions
// todo: planar version: weights and basis functions
// a) 2 points, weights
// b) 4 points, basis: linear, quadratic

// client
const w = 640.0;
const h = 640.0;

//// 2d
// visible region
var x2d_min = -1.0;
var y2d_min = -1.0;
var x2d_max = 4.0;
var y2d_max = 4.0;

var client_x2d_center = w*(0-x2d_min)/(x2d_max-x2d_min);
var client_x2d_step = (w/(x2d_max-x2d_min));

var client_y2d_center = h - h*(0-y2d_min)/(y2d_max-y2d_min);
var client_y2d_step = (h/(y2d_max-y2d_min));

function client_to_x(client_x){
    return (client_x - client_x2d_center) / client_x2d_step;
}

function client_to_y(client_y){
    return (client_y2d_center - client_y) / client_y2d_step;
}

function x2d_to_client(x){
    return x * client_x2d_step + client_x2d_center;
}

function y2d_to_client(y){
    return client_y2d_center - y * client_y2d_step;
}

function draw_grid_on(context){
    // grid
    context.font = "16px sans-serif";
    context.beginPath();
    context.moveTo(0, client_y2d_center);
    context.lineTo(w, client_y2d_center);
    context.lineTo(w - 12, client_y2d_center - 5);
    context.moveTo(w, client_y2d_center);
    context.lineTo(w - 12, client_y2d_center + 5);
    context.moveTo(client_x2d_center, h);
    context.lineTo(client_x2d_center, 0);
    context.lineTo(client_x2d_center - 5, 12);
    context.moveTo(client_x2d_center, 0);
    context.lineTo(client_x2d_center + 5, 12);
    context.fillStyle="#000000";
    for(var i = x2d_min + 1; i <= x2d_max - 1; i++){
        if(i != 0) {
            context.moveTo(client_x2d_center + i*client_x2d_step, client_y2d_center);
            context.lineTo(client_x2d_center + i*client_x2d_step, client_y2d_center - 5);
            context.fillText(i, client_x2d_center + i*client_x2d_step + 4, client_y2d_center + 16);
        }
    }
    for(var i = y2d_min + 1; i <= y2d_max - 1; i++){
        if(i != 0) {
            context.moveTo(client_x2d_center, client_y2d_center - i*client_y2d_step);
            context.lineTo(client_x2d_center + 5, client_y2d_center - i*client_y2d_step);
        }
        context.fillText(i, client_x2d_center + 5, client_y2d_center - i*client_y2d_step + 16);
    }
    context.strokeStyle = "#000000";
    context.stroke();
    context.closePath();
}

function closest_point_starting_from(x, y, xs, ys, i) {
    for(var j = i + 1; j < xs.length; ++j)
        if(d2(x, y, xs[j], ys[j]) < d2(x, y, xs[i], ys[i]))
            return closest_point_starting_from(x, y, xs, ys, j);
    return i;
}

// finds a closest point from xs, ys to x, y
function closest_point(x, y, xs, ys){
    return closest_point_starting_from(x, y, xs, ys, 0);
}



// params
var weight2d = 1;
var basis2d = 0;

var x2s1 = [140, 500];
var y2s1 = [500, 140];

var x2s2 = [140, 200, 300, 500];
var y2s2 = [500, 140, 300, 400];

function init_canvas2d1() {
    var canvas = document.getElementById("canvas2d1");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        const point_i = closest_point(x, y, x2s1, y2s1);
        x2s1[point_i] = x;
        y2s1[point_i] = y;
        draw_canvas2d1(0, 0, false);
    }, false);
     
    canvas.addEventListener('mousemove', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;    
        if(e.buttons == 1){
            const point_i = closest_point(x, y, x2s1, y2s1);
            x2s1[point_i] = x;
            y2s1[point_i] = y;
            draw_canvas2d1(0, 0, false);
        } else {
            draw_canvas2d1(x, y, true);
        }
    }, false);
    
    canvas.addEventListener('mouseup', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        draw_canvas2d1(0, 0, false);
    }, false);
    
    draw_canvas2d1();
}

function draw_canvas2d1(client_x, client_y, do_guides){
    var canvas = document.getElementById("canvas2d1");
    var context = canvas.getContext("2d");
    
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);
        
    draw_grid_on(context);
    
    // dots
    context.strokeStyle="#f71134";    
    for(var i = 0; i <= x2s1.length; ++i){
        context.beginPath();
        context.arc(x2s1[i], y2s1[i], 4, 0, 2*Math.PI);
        context.stroke();
        context.closePath();    
    }

    // guides
    if(do_guides){
        const point_i = closest_point(client_x, client_y, x2s1, y2s1);
        draw_arrow(context, x2s1[point_i], y2s1[point_i], client_x, client_y);
    }
}
    
function init_canvas2d2(){
    var canvas = document.getElementById("canvas2d2");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        const point_i = closest_point(x, y, x2s2, y2s2);
        x2s2[point_i] = x;
        y2s2[point_i] = y;
        draw_canvas2d2(0, 0, false);
    }, false);
     
    canvas.addEventListener('mousemove', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;    
        if(e.buttons == 1){
            const point_i = closest_point(x, y, x2s2, y2s2);
            x2s2[point_i] = x;
            y2s2[point_i] = y;
            draw_canvas2d2(0, 0, false);
        } else {
            draw_canvas2d2(x, y, true);
        }
    }, false);
    
    canvas.addEventListener('mouseup', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        draw_canvas2d2(0, 0, false);
    }, false);
    
    draw_canvas2d2();
}

function draw_canvas2d2(client_x, client_y, do_guides){
    var canvas = document.getElementById("canvas2d2");
    var context = canvas.getContext("2d");
    
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);
    
    draw_grid_on(context);
    
    // dots
    context.strokeStyle="#f71134";    
    for(var i = 0; i <= x2s2.length; ++i){
        context.beginPath();
        context.arc(x2s2[i], y2s2[i], 4, 0, 2*Math.PI);
        context.stroke();
        context.closePath();    
    }

    // guides
    if(do_guides){
        const point_i = closest_point(client_x, client_y, x2s2, y2s2);
        draw_arrow(context, x2s2[point_i], y2s2[point_i], client_x, client_y);
    }    
}




//// 3d
// points
var x3s = [-1, 140, 500, 500, 140];
var y3s = [-1, 140, 140, 500, 500];
var z3s = [-1,  64, 140, 180, 255];
// triangles' points are ordered clockwise
var tris = [[1, 2, 3], [3, 4, 1]];

// weight funtion
var weight3d = 2;
const wf = function(x) {return 1./Math.pow(x, weight3d);}


// finds a closest point from x3s, y3s to x, y
function closest_3d_point(x, y){
    return closest_point_starting_from(x, y, x3s, y3s, 1);
}

// point belongs to a triangle
function in_tri(px, py, x1, y1, x2, y2, x3, y3) {
    /* shove it into sympy to get solution
    px, py, x1, y1, x2, y2, x3, y3, a, b = symbols('px py x1 y1 x2 y2 x3 y3 a b')
    solve([
    x1 + a * (x2-x1) + b * (x3-x1) - px,
    y1 + a * (y2-y1) + b * (y3-y1) - py
    ], (a, b))
    */
    var a = (-(px - x1)*(y1 - y3) + (py - y1)*(x1 - x3))/((x1 - x2)*(y1 - y3) - (x1 - x3)*(y1 - y2));
    var b = ((px - x1)*(y1 - y2) - (py - y1)*(x1 - x2))/((x1 - x2)*(y1 - y3) - (x1 - x3)*(y1 - y2));
    return (a >= 0 && b >= 0 && a + b <= 1.);
}

// point projection belongs to an edge
function in_edge(px, py, x1, y1, x2, y2) {
    if((px-x1)*(y2-y1)-(py-y1)*(x2-x1) < 0) // border should be ordered for that
        return false;
    /*
    px, py, x1, y1, x2, y2, a = symbols('px py x1 y1 x2 y2 a')
    solve([(x1 + (x2 - x1) * a - px) * (x2 - x1) + (y1 + (y2 - y1) * a - py) * (y2 - y1)], (a))
    */
    var a = (-px*x1 + px*x2 - py*y1 + py*y2 + x1*x1 - x1*x2 + y1*y1 - y1*y2)/(x1*x1 - 2*x1*x2 + x2*x2 + y1*y1 - 2*y1*y2 + y2*y2);
    return (a >= 0 && a <= 1);
}

// distance squared from (x1, y1) to (x2, y2)
function d2(x1, y1, x2, y2) {
    return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);
}

// project point on edge
function projected_on_edge(px, py, x1, y1, x2, y2) {
     /*
    px, py, x1, y1, x2, y2, a = symbols('px py x1 y1 x2 y2 a')
    solve([(x1 + (x2 - x1) * a - px) * (x2 - x1) + (y1 + (y2 - y1) * a - py) * (y2 - y1)], (a))
    */
    var a = (-px*x1 + px*x2 - py*y1 + py*y2 + x1*x1 - x1*x2 + y1*y1 - y1*y2)/(x1*x1 - 2*x1*x2 + x2*x2 + y1*y1 - 2*y1*y2 + y2*y2);
    return [x1 + (x2 - x1) * a, y1 + (y2 - y1) * a];
}

// distance from (x1, y1) to (x2, y2)
function d(x1, y1, x2, y2) {
    return Math.sqrt(d2(x1, y1, x2, y2));
}

// distance from (x, y) to edge [(x1, y1), (x2, y2)]
function d_e(x, y, x1, y1, x2, y2) {
    const dxe = x2-x1;
    const dye = y2-y1;
    const dx = x-x1;
    const dy = y-y1;
    const area = Math.abs(dxe*dy - dye*dx);
    return area / d(x1, y1, x2, y2);
}

const d_min = 1e-5; // too close

// interpolation on the edge
function z_in_edge(px, py, x1, y1, z1, x2, y2, z2) {
    const pp = projected_on_edge(px, py, x1, y1, x2, y2);
    const d1 = d(pp[0], pp[1], x1, y1);
    const d2 = d(pp[0], pp[1], x2, y2);
    if(d1 < d_min)
        return z1;
    if(d2 < d_min)
        return z2;
    return (z1 * wf(d1) + z2 * wf(d2)) / (wf(d1) + wf(d2));
}

// interpolation in tri
function z_in_tri(px, py, x1, y1, z1, x2, y2, z2, x3, y3, z3) {
    const d1 = d_e(px, py, x1, y1, x2, y2);
    const d2 = d_e(px, py, x2, y2, x3, y3);
    const d3 = d_e(px, py, x3, y3, x1, y1);
    if(d1 < d_min)
        return z_in_edge(px, py, x1, y1, z1, x2, y2, z2);
    if(d2 < d_min)
        return z_in_edge(px, py, x2, y2, z2, x3, y3, z3);
    if(d3 < d_min)
        return z_in_edge(px, py, x3, y3, z3, x1, y1, z1);
    return (z_in_edge(px, py, x1, y1, z1, x2, y2, z2) * wf(d1) 
          + z_in_edge(px, py, x2, y2, z2, x3, y3, z3) * wf(d2) 
          + z_in_edge(px, py, x3, y3, z3, x1, y1, z1) * wf(d3)) 
        / (wf(d1) + wf(d2) + wf(d3));
}

function init_canvas3d(){
    var canvas = document.getElementById("canvas3d");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        const point_i = closest_3d_point(x, y);
        x3s[point_i] = x;
        y3s[point_i] = y;
        compute_edges_and_z_field();
        draw_canvas3d(0, 0, false);
    }, false);
     
    canvas.addEventListener('mousemove', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;    
        if(e.buttons == 1){
            const point_i = closest_3d_point(x, y);
            x3s[point_i] = x;
            y3s[point_i] = y;
            compute_edges_and_z_field();
            draw_canvas3d(0, 0, false);
        } else {
            draw_canvas3d(x, y, true);
        }
    }, false);
    
    canvas.addEventListener('mouseup', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        draw_canvas3d(0, 0, false);
    }, false);
    
    compute_edges_and_z_field();
    draw_canvas3d();
}

function draw_arrow(context, x1, y1, x2, y2) {
    var d = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.moveTo(x2 - (y2 - y1) * 6 / d - (x2 - x1) * 16 / d, y2 - (y2 - y1) * 16 / d + (x2 - x1) * 6 / d);
    context.lineTo(x2, y2);
    context.moveTo(x2 + (y2 - y1) * 6 / d - (x2 - x1) * 16 / d, y2 - (y2 - y1) * 16 / d - (x2 - x1) * 6 / d);
    context.lineTo(x2, y2);
    context.stroke();
    context.closePath();
}

function edge_as_number(edge) {
    return edge[0] * 10000 + edge[1];
}

function number_as_edge(number) {
    return [Math.floor(number / 10000), number % 10000];
}

var edges = [];
var z_field = [];
function compute_edges_and_z_field() {
    // compute all edges
    var all_edges = new Set();
    var inner_edges = new Set();
    for(var i = 0; i < tris.length; ++i) {
        for(var j = 0; j < 3; ++j) {
            const i1 = tris[i][j % 3];
            const i2 = tris[i][(j+1) % 3];
            const ordered_edge = i1 < i2 ? [i1, i2] : [i2, i1];
            if(all_edges.has(edge_as_number(ordered_edge)))
                inner_edges.add(edge_as_number(ordered_edge));              
            all_edges.add(edge_as_number(ordered_edge))
        }
    }
    edges = Array.from(all_edges.values()).map(number_as_edge);
    
    // compute outer edges
    var outer_edges = [];
    for(var i = 0; i < tris.length; ++i) {
        for(var j = 0; j < 3; ++j) {
            const edge = [tris[i][j % 3], tris[i][(j+1) % 3]];
            const egde = [tris[i][(j+1) % 3], tris[i][j % 3]];
            if(!(inner_edges.has(edge_as_number(edge)) || inner_edges.has(edge_as_number(egde))))
                outer_edges.push(edge);
        }
    }
    
    // compute z-field
    z_field = [];
    for (var i = 0; i < w*h; i += 1) {
    var y = Math.floor(i / w);
    var x = i % w;
    var z = 0;
    var z_determined = false;
    for(var j = 0; j < tris.length; ++j)
        if(in_tri(x, y, x3s[tris[j][0]], y3s[tris[j][0]], x3s[tris[j][1]], y3s[tris[j][1]], x3s[tris[j][2]], y3s[tris[j][2]])) {
            z = z_in_tri(x, y, 
                x3s[tris[j][0]], y3s[tris[j][0]], z3s[tris[j][0]], 
                x3s[tris[j][1]], y3s[tris[j][1]], z3s[tris[j][1]], 
                x3s[tris[j][2]], y3s[tris[j][2]], z3s[tris[j][2]]);
            z_determined = true;
        }
    if(!z_determined) {
        for(var j = 0; j < outer_edges.length; ++j) {
            if(in_edge(x, y, x3s[outer_edges[j][0]], y3s[outer_edges[j][0]], x3s[outer_edges[j][1]], y3s[outer_edges[j][1]])) {
                z = z_in_edge(x, y, x3s[outer_edges[j][0]], y3s[outer_edges[j][0]], z3s[outer_edges[j][0]], x3s[outer_edges[j][1]], y3s[outer_edges[j][1]], z3s[outer_edges[j][1]]);
                z_determined = true;
            }
        }
    }
    if(!z_determined)
        z = z3s[closest_3d_point(x, y)];
    z_field.push(z);
    }
}

function draw_canvas3d(client_x, client_y, do_guides){
    var canvas = document.getElementById("canvas3d");
    var context = canvas.getContext("2d");
    
    // draw z-field
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        const color = Math.trunc(z_field[Math.floor(i/4)] / 16) * 16;
        pixel_field.data[i + 0] = color;
        pixel_field.data[i + 1] = color;
        pixel_field.data[i + 2] = color;
        pixel_field.data[i + 3] = 0xFF;
    }
    context.putImageData(pixel_field, -0.5, -0.5);
    
    // dots
    context.strokeStyle="#f71134";    
    for(var i = 1; i <= x3s.length; ++i){
        context.beginPath();
        context.arc(x3s[i], y3s[i], 4, 0, 2*Math.PI);
        context.stroke();
        context.closePath();    
    }

    // guides
    if(do_guides){
        const point_i = closest_3d_point(client_x, client_y);
        draw_arrow(context, x3s[point_i], y3s[point_i], client_x, client_y);
    }
        
    // complex
    context.setLineDash([4, 4]);
    for(var i = 0; i < edges.length; ++i) {
     context.beginPath();
        context.moveTo(x3s[edges[i][0]], y3s[edges[i][0]]);
        context.lineTo(x3s[edges[i][1]], y3s[edges[i][1]]);
        context.stroke();
        context.closePath();
    }
    context.setLineDash([]);
}

// UI
function inc(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) + 1;
    eval('change_' + counter_name + '()');
}

function dec(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) - 1;
    eval('change_' + counter_name + '()');
}

function change_weight2d() {
    weight3d = document.getElementById('weight2d').value;
    // ...
}

function change_basis2d() {
    basis2d = document.getElementById('basis2d').value;
    // ...
}

function change_weight3d() {
    weight3d = document.getElementById('weight3d').value;
    compute_edges_and_z_field();
    draw_canvas3d();
}
    </script>
  </head>
  <body>
    <center>
    <p>
...
    </p>
    <canvas id="canvas2d1" width=640 height=640></canvas>
    <form>
Please enter the weight coefficient:
    <button type="button" onclick="dec('weight2d')">-</button>
    <input type="text" style="width: 32pt;" id="weight2d" value="1" oninput="change_weight2d();">
    <button type="button" onclick="inc('weight2d')">+</button>
    </form>    
    <p>
...
    </p>
    <canvas id="canvas2d2" width=640 height=640></canvas>
    <form>
Please enter the basis function order:
    <button type="button" onclick="dec('basis2d')">-</button>
    <input type="text" style="width: 32pt;" id="basis2d" value="1" oninput="change_basis2d();">
    <button type="button" onclick="inc('basis2d')">+</button>
    </form>        
    <p>
...
    </p>
    <canvas id="canvas3d" width=640 height=640></canvas>
    <form>
Please enter the weight coefficient:
    <button type="button" onclick="dec('weight3d')">-</button>
    <input type="text" style="width: 32pt;" id="weight3d" value="2" oninput="change_weight3d();">
    <button type="button" onclick="inc('weight3d')">+</button>
    </form>
    
    <script language="JavaScript">
    init_canvas2d1();
    init_canvas2d2();
    init_canvas3d();
    </script>
    </center>
  </body>
</html>
