<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SWInE</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.results {
    font-family: sans-serif;
    font-size: 14pt;
    width: 505pt;
    text-align: left;
}

.formula {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: italic;
    width: 505pt;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table.footer {
    padding: 64pt 0pt 32pt 0pt;
    background-color: transparent;
    width: 505pt;
}

td.footer {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: normal;
    padding: 0;
    margin: 0;
    border: 0;
}

li {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
    padding-bottom: 6pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

input[type="text"] {
    width: 32pt;
    height: 22pt;
    font-size: 16pt;
    text-align: center;
}

button {
    width: 32pt;
    height: 26pt;
    font-size: 16pt;
    text-align: center;
}
    </style>
    <script language="JavaScript">

// client
var w = 640.0;
var h = 640.0;


var xs = [-1, 140, 500, 500, 140];
var ys = [-1, 140, 140, 500, 500];
var zs = [-1,  64, 128, 196, 255];
// triangles' points are not really ordered
var tris = [[1, 2, 3], [3, 4, 1]];
// but the border's should be. This determines in and out of the model
var border = [[1, 2], [2, 3], [3, 4], [4, 1]];


// point belongs to a triangle
function in_tri(px, py, x1, y1, x2, y2, x3, y3) {
    /* shove it into sympy to get solution
    px, py, x1, y1, x2, y2, x3, y3, a, b = symbols('px py x1 y1 x2 y2 x3 y3 a b')
    solve([
    x1 + a * (x2-x1) + b * (x3-x1) - px,
    y1 + a * (y2-y1) + b * (y3-y1) - py
    ], (a, b))
    */
    var a = (-(px - x1)*(y1 - y3) + (py - y1)*(x1 - x3))/((x1 - x2)*(y1 - y3) - (x1 - x3)*(y1 - y2));
    var b = ((px - x1)*(y1 - y2) - (py - y1)*(x1 - x2))/((x1 - x2)*(y1 - y3) - (x1 - x3)*(y1 - y2));
    return (a >= 0 && b >= 0 && a + b <= 1.);
}

// point projection belongs to an edge
function in_edge(px, py, x1, y1, x2, y2) {
    if((px-x1)*(y2-y1)-(py-x1)*(x2-x1) < 0) // border should be ordered for that
        return false;
    /*
    px, py, x1, y1, x2, y2, a = symbols('px py x1 y1 x2 y2 a')
    solve([(x1 + (x2 - x1) * a - px) * (x2 - x1) + (y1 + (y2 - y1) * a - py) * (y2 - y1)], (a))
    */
    var a = (-px*x1 + px*x2 - py*y1 + py*y2 + x1*x1 - x1*x2 + y1*y1 - y1*y2)/(x1*x1 - 2*x1*x2 + x2*x2 + y1*y1 - 2*y1*y2 + y2*y2);
    return (a >= 0 && a <= 1);
}

// distance squared from (x1, y1) to (x2, y2)
function d2(x1, y1, x2, y2) {
    return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);
}

// project point on edge
function projected_on_edge(px, py, x1, y1, x2, y2) {
     /*
    px, py, x1, y1, x2, y2, a = symbols('px py x1 y1 x2 y2 a')
    solve([(x1 + (x2 - x1) * a - px) * (x2 - x1) + (y1 + (y2 - y1) * a - py) * (y2 - y1)], (a))
    */
    var a = (-px*x1 + px*x2 - py*y1 + py*y2 + x1*x1 - x1*x2 + y1*y1 - y1*y2)/(x1*x1 - 2*x1*x2 + x2*x2 + y1*y1 - 2*y1*y2 + y2*y2);
    return [x1 + (x2 - x1) * a, y1 + (y2 - y1) * a];
}

// distance from (x1, y1) to (x2, y2)
function d(x1, y1, x2, y2) {
    return Math.sqrt(d2(x1, y1, x2, y2));
}

// distance from (x, y) to edge [(x1, y1), (x2, y2)]
function d_e(x, y, x1, y1, x2, y2) {
    const dxe = x2-x1;
    const dye = y2-y1;
    const dx = x-x1;
    const dy = y-y1;
    const area = Math.abs(dxe*dy - dye*dx);
    return area / d(x1, y1, x2, y2);
}

const d_min = 1e-5; // too close

// interpolation on the edge
function z_in_edge(px, py, x1, y1, z1, x2, y2, z2) {
    const pp = projected_on_edge(px, py, x1, y1, x2, y2);
    const d1 = d(pp[0], pp[1], x1, y1);
    const d2 = d(pp[0], pp[1], x2, y2);
    if(d1 < d_min)
        return z1;
    if(d2 < d_min)
        return z2;
    return (z1 / d1 + z2 / d2) / (1./d1 + 1./d2);
}

// interpolation in tri
function z_in_tri(px, py, x1, y1, z1, x2, y2, z2, x3, y3, z3) {
    const d1 = d_e(px, py, x1, y1, x2, y2);
    const d2 = d_e(px, py, x2, y2, x3, y3);
    const d3 = d_e(px, py, x3, y3, x1, y1);
    if(d1 < d_min)
        return z_in_edge(px, py, x1, y1, z1, x2, y2, z2);
    if(d2 < d_min)
        return z_in_edge(px, py, x2, y2, z2, x3, y3, z3);
    if(d3 < d_min)
        return z_in_edge(px, py, x3, y3, z3, x1, y1, z1);
    return (z_in_edge(px, py, x1, y1, z1, x2, y2, z2) / d1 
          + z_in_edge(px, py, x2, y2, z2, x3, y3, z3) / d2 
          + z_in_edge(px, py, x3, y3, z3, x1, y1, z1) / d3) 
        / (1./ d1 + 1./ d2 + 1./ d3);
}

function closest_point_starting_from(x, y, i) {
    for(var j = i + 1; j < xs.length; ++j)
        if(d2(x, y, xs[j], ys[j]) < d2(x, y, xs[i], ys[i]))
            return closest_point_starting_from(x, y, j);
    return i;
}
// finds a closest point from xs, ys to x, y
function closest_point(x, y){
    return closest_point_starting_from(x, y, 1);
}

function init_canvas(){
    var canvas = document.getElementById("canvas");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
    }, false);
     
    canvas.addEventListener('mousemove', function(e){
        if(e.buttons == 1){
            canvas_rect = canvas.getBoundingClientRect();
            draw_canvas();
        }
    }, false);
    
    canvas.addEventListener('mouseup', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        draw_canvas();
    }, false);
    
    draw_canvas();
}

function draw_canvas(){
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    
    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var y = Math.floor(Math.floor(i / 4) / w);
        var x = Math.floor(i / 4) % w;
        var z = 0;
        if(in_tri(x, y, xs[tris[0][0]], ys[tris[0][0]], xs[tris[0][1]], ys[tris[0][1]], xs[tris[0][2]], ys[tris[0][2]]))
            z = z_in_tri(x, y, 
                xs[tris[0][0]], ys[tris[0][0]], zs[tris[0][0]], 
                xs[tris[0][1]], ys[tris[0][1]], zs[tris[0][1]], 
                xs[tris[0][2]], ys[tris[0][2]], zs[tris[0][2]]);
        else if(in_tri(x, y, xs[tris[1][0]], ys[tris[1][0]], xs[tris[1][1]], ys[tris[1][1]], xs[tris[1][2]], ys[tris[1][2]]))
            z = z_in_tri(x, y, 
                xs[tris[1][0]], ys[tris[1][0]], zs[tris[1][0]], 
                xs[tris[1][1]], ys[tris[1][1]], zs[tris[1][1]], 
                xs[tris[1][2]], ys[tris[1][2]], zs[tris[1][2]]);
        else if(in_edge(x, y, xs[border[0][0]], ys[border[0][0]], xs[border[0][1]], ys[border[0][1]]))
            z = z_in_edge(x, y, xs[border[0][0]], ys[border[0][0]], zs[border[0][0]], xs[border[0][1]], ys[border[0][1]], zs[border[0][1]]);
        else if(in_edge(x, y, xs[border[1][0]], ys[border[1][0]], xs[border[1][1]], ys[border[1][1]]))
            z = z_in_edge(x, y, xs[border[1][0]], ys[border[1][0]], zs[border[1][0]], xs[border[1][1]], ys[border[1][1]], zs[border[1][1]]);
        else if(in_edge(x, y, xs[border[2][0]], ys[border[2][0]], xs[border[2][1]], ys[border[2][1]]))
            z = z_in_edge(x, y, xs[border[2][0]], ys[border[2][0]], zs[border[2][0]], xs[border[2][1]], ys[border[2][1]], zs[border[2][1]]);
        else if(in_edge(x, y, xs[border[3][0]], ys[border[3][0]], xs[border[3][1]], ys[border[3][1]]))
            z = z_in_edge(x, y, xs[border[3][0]], ys[border[3][0]], zs[border[3][0]], xs[border[3][1]], ys[border[3][1]], zs[border[3][1]]);
        else
            z = zs[closest_point(x, y)];
        pixel_field.data[i + 0] = z;
        pixel_field.data[i + 1] = z;
        pixel_field.data[i + 2] = z;
        pixel_field.data[i + 3] = 0xFF;
    }
    context.putImageData(pixel_field, -0.5, -0.5);
}

    </script>
  </head>
  <body>
    <center>
    <canvas id="canvas" width=640 height=640></canvas>
    <script language="JavaScript">
    init_canvas();
    </script>
    </center>
  </body>
</html>
