<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Splines from an image</title>
    <meta name="keywords" content="iterative,algorithms,guide,tutorial,learning">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.results {
    font-family: sans-serif;
    font-size: 14pt;
    width: 505pt;
    text-align: left;
}

.formula {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: italic;
    width: 505pt;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table.footer {
    padding: 64pt 0pt 32pt 0pt;
    background-color: transparent;
    width: 505pt;
}

td.footer {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: normal;
    padding: 0;
    margin: 0;
    border: 0;
}

li {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
    padding-bottom: 6pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

input[type="text"] {
    width: 48pt;
    height: 22pt;
    font-size: 16pt;
    text-align: center;
}

input[type="radio"] {
    height: 16pt;
    width: 16pt;
    font-size: 16pt;
}

button {
    width: 128pt;
    height: 26pt;
    font-size: 16pt;
    text-align: center;
}

textarea {
    width: 600pt;
    font-size: 12pt;
    font-family: monospace;
}

.comment {
    font-size: 12pt;
    text-align:center;
    font-family: sans-serif;
    padding-bottom: 24pt;
}
    </style>
    <script language="JavaScript">

// client
var w = 1024.0;
var h = 1024.0;

// algorithm
var pixel_size = 64.0;

var threshold = 0.5;

// pixels
var iw = Math.floor(w / pixel_size) + 1;
var ih = Math.floor(h / pixel_size) + 1;
var pixels = [
// nothing
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

function reset_pixels() {
    pixels = [];
    for(var i = 0; i < ih; ++i) {
        pixelsi = []
        for(var j = 0; j <iw; ++j)
            pixelsi.push(0);
        pixels.push(pixelsi);
    }
}

var splines_points_normals = [];

// solver specific to [0..1] parametrized splines
function spline_for(p1, p1d, p2, p2d) {
//     A = [
//         [1, 0, 0, 0],
//         [0, 1, 0, 0],
//         [1, 1, 1, 1],
//         [0, 1, 2, 3]];
//     B = [p1, p1d, p2, p2d]
    return [
        p1,
        p1d,
        3 * p2 - p2d - 3*p1 - 2*p1d,
        p2d + p1d - 2*p2 + 2*p1
    ];
}

// solver than returns 0, 0 if there is no solution
function solved_linear2_or_zero(A, B) {
    var d = (A[0][0]*A[1][1] - A[0][1]*A[1][0])
    if(d == 0.0)
        return [0.0, 0.0];
    var x1 = (-A[0][1]*B[1] + A[1][1]*B[0]) / d;
    var x2 = ( A[0][0]*B[1] - A[1][0]*B[0]) / d;
    return [x1, x2];
}

// polynomial
function polynomial_in_x(A, x, n){
    var y = 0.0;
    for(var i = 0; i < n; ++i){
        y += A[i] * Math.pow(x, i);
    }
    return y;
}

// algorithm parts
function pixel_in(i, j) {
    if(i >= pixels.length)
        return pixel_in(pixels.length-1, j);
    if(i < 0) 
        return pixel_in(0, j);
    if(j >= pixels[0].length)
        return pixel_in(i, pixels[0].length-1);
    if(j < 0)
        return pixel_in(i, 0);
    return pixels[Math.floor(i)][Math.floor(j)];
}


var nd = 1.5;
var weight = 4;
var shiftd = 1.5;

function weight_of_point(x, y, xj, yi) {
    return Math.pow(2 * Math.pow(0.5, weight), 0.5)
        / (Math.pow(Math.abs(x - xj), weight) + Math.pow(Math.abs(y - yi), weight));
}

function dx_from_linear(x, y) {
    var A = [[0.0, 0.0], [0.0, 0.0]];
    var B = [0.0, 0.0];
    for(var yi = y - nd; yi <= y + nd; yi += 1) {
        for(var xj = x - nd; xj <= x + nd; xj += 1) {
            var w = weight_of_point(x, y, xj, yi);
            A[0][0] += w;
            A[0][1] += w * (xj - x);
            A[1][0] += w * (xj - x);
            A[1][1] += w * Math.pow(xj - x, 2);
            B[0] += w * pixel_in(yi, xj);
            B[1] += w * (xj - x) * pixel_in(yi, xj);
        }
    }
    var px = solved_linear2_or_zero(A, B);
    return px;
}

function dy_from_linear(x, y) {
    var A = [[0.0, 0.0], [0.0, 0.0]];
    var B = [0.0, 0.0];
    for(var yi = y - nd; yi <= y + nd; yi += 1) {
        for(var xj = x - nd; xj <= x + nd; xj += 1) {
            var w = weight_of_point(x, y, xj, yi);
            A[0][0] += w;
            A[0][1] += w * (yi - y);
            A[1][0] += w * (yi - y);
            A[1][1] += w * Math.pow(yi - y, 2);
            B[0] += w * pixel_in(yi, xj);
            B[1] += w * (yi - y) * pixel_in(yi, xj);
        }
    }
    var px = solved_linear2_or_zero(A, B);
    return px;
}

function dxy(x, y) {
    var dx = dx_from_linear(x, y)[1];
    var dy = dy_from_linear(x, y)[1];
    var len = Math.sqrt(dx * dx + dy * dy);
    if(len < 1e-5)
        return [0.0, 0.0];
    return [dx / len, dy / len];
}

function limited_05(x) {
    if(x < -0.5)
        return -0.5;
    if(x > +0.5)
        return +0.5;
    return x;
}

// gradient shift
function gsx(x, y) {
    return limited_05(dxy(x, y)[0] * (0.5 - dy_from_linear(x, y)[0]) * shiftd);
}

function gsy(x, y) {
    return limited_05(dxy(x, y)[1] * (0.5 - dx_from_linear(x, y)[0]) * shiftd);
}

// sign without 0 option
function sign(x) {
    return x >= 0 ? 1 : -1;
}

// the algorithm itself
function turn_pixels_into_splines() {
    var splines = [];
    var points = [];
    var normals = [];
    if(true) {
        // "horizontal" pieces    
        for(var i = 0; i <= ih; i += 1) {
            var old_point = [];
            var old_normal = [];        
            for(var j = 0; j <= iw; j += 1) {
                var margin_to_the_right = 
                    sign(pixel_in(i-1, j+0) - threshold) != 
                    sign(pixel_in(i+0, j+0) - threshold);
                var margin_to_the_left = 
                    sign(pixel_in(i-1, j-1) - threshold) != 
                    sign(pixel_in(i+0, j-1) - threshold);
                var margin_to_the_bottom = 
                    sign(pixel_in(i+0, j-1) - threshold) != 
                    sign(pixel_in(i+0, j+0) - threshold);
                var margin_to_the_top = 
                    sign(pixel_in(i-1, j-1) - threshold) != 
                    sign(pixel_in(i-1, j+0) - threshold);                    
                if(margin_to_the_right || margin_to_the_left) {
                    var point = [j + gsx(j, i), i + gsy(j, i)];
                    var normal = dxy(point[0], point[1]);
                    if(margin_to_the_left && margin_to_the_right && margin_to_the_top && margin_to_the_bottom)
                        normal = [0., 0.];
                    points.push(point);
                    normals.push(normal);
                    if(margin_to_the_left && old_point) {
                        var ds = Math.sign(pixel_in(i - 1, j - 1) - threshold);
                        var Px = spline_for(old_point[0], (-ds)*old_normal[1], point[0], (-ds)*normal[1]);
                        var Py = spline_for(old_point[1], ds*old_normal[0], point[1], ds*normal[0]);
                        splines.push([Px, Py]);
                    }
                    if(margin_to_the_right) {
                        old_point = point;
                        old_normal = normal;                    
                    }   
                }      
            }
        }
    }
    // "vertical" pieces
    if(true) {
        for(var j = 0; j <= iw; j += 1) {
            var old_point = [];
            var old_normal = [];
            for(var i = 0; i <= ih; i += 1) {
                var margin_to_the_right = 
                    sign(pixel_in(i-1, j+0) - threshold) != 
                    sign(pixel_in(i+0, j+0) - threshold);
                var margin_to_the_left = 
                    sign(pixel_in(i-1, j-1) - threshold) != 
                    sign(pixel_in(i+0, j-1) - threshold);            
                var margin_to_the_bottom = 
                    sign(pixel_in(i+0, j-1) - threshold) != 
                    sign(pixel_in(i+0, j+0) - threshold);
                var margin_to_the_top = 
                    sign(pixel_in(i-1, j-1) - threshold) != 
                    sign(pixel_in(i-1, j+0) - threshold);
                if(margin_to_the_bottom || margin_to_the_top) {
                    var point = [j + gsx(j, i), i + gsy(j, i)];
                    var normal = dxy(point[0], point[1]);
                    if(margin_to_the_left && margin_to_the_right && margin_to_the_top && margin_to_the_bottom)
                        normal = [0., 0.];
                    points.push(point);
                    normals.push(normal);
                    if(margin_to_the_top && old_point) {
                        var ds = Math.sign(pixel_in(i - 1, j - 1) - threshold);
                        var Px = spline_for(old_point[0] , ds*old_normal[1], point[0], ds*normal[1]);
                        var Py = spline_for(old_point[1], (-ds)*old_normal[0], point[1], (-ds)*normal[0]);
                        splines.push([Px, Py]);
                    }
                    if(margin_to_the_bottom) {
                        old_point = point;
                        old_normal = normal;                    
                    }   
                }      
            }
        }
    }
    return [splines, points, normals];
}

function draw_the_splines(context, splines) {
    context.beginPath();
    for(var i = 0; i < splines.length; ++i) {
        for(var k = 0; k < pixel_size; k += 1) {
            var t1 = (k) / pixel_size;
            var t2 = (k + 1) / pixel_size;
            var x1 = polynomial_in_x(splines[i][0], t1, 4) * pixel_size;
            var y1 = polynomial_in_x(splines[i][1], t1, 4) * pixel_size;
            var x2 = polynomial_in_x(splines[i][0], t2, 4) * pixel_size;
            var y2 = polynomial_in_x(splines[i][1], t2, 4) * pixel_size;
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
        }
    }
    
    context.strokeStyle="#AA3366";
    context.lineWidth = 3;
    context.stroke();
    context.closePath();    
}

function init_canvas(){
    var canvas = document.getElementById("canvas");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
    }, false);
     
    canvas.addEventListener('mousemove', function(e){
        if(e.buttons == 1){
            canvas_rect = canvas.getBoundingClientRect();
            draw_canvas();
        }
    }, false);
    
    canvas.addEventListener('mouseup', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        var j = e.clientX - canvas_rect.left;
        var i = e.clientY - canvas_rect.top;
        var in_pixels_i = Math.floor(i / pixel_size);
        var in_pixels_j = Math.floor(j / pixel_size);
        pixels[in_pixels_i][in_pixels_j] *= 7;
        if(e.shiftKey)       
            pixels[in_pixels_i][in_pixels_j] += 7;
        else
            pixels[in_pixels_i][in_pixels_j] += 1;
        pixels[in_pixels_i][in_pixels_j] = Math.floor(pixels[in_pixels_i][in_pixels_j]) % 8;
        pixels[in_pixels_i][in_pixels_j] /= 7;
        draw_canvas();
    }, false);
    
    draw_canvas();
}


function draw_canvas(){
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var pixel_value = Math.max(Math.min(pixels[in_pixels_i][in_pixels_j], 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;
    }
    context.putImageData(pixel_field, -0.5, -0.5);
    
    // pixel grid
    context.beginPath();
    for(var i = pixel_size; i <= h; i += pixel_size) {
        context.moveTo(0.0, i);
        context.lineTo(w, i);
    }
    for(var j = pixel_size; j <= w; j += pixel_size) {
        context.moveTo(j, 0.0);
        context.lineTo(j, h);
    }
    context.strokeStyle="#AAAAAA";
    context.lineWidth=1;
    context.setLineDash([4, 4]);
    context.stroke();
    context.setLineDash([]);
    context.closePath();
    
    // spline grid
    context.beginPath();
    for(var i = pixel_size / 2 ; i <= h; i += pixel_size) {
        context.moveTo(0.0, i);
        context.lineTo(w, i);
    }
    for(var j = pixel_size / 2; j <= w; j += pixel_size) {
        context.moveTo(j, 0.0);
        context.lineTo(j, h);
    }
    context.strokeStyle="#bb7799";
    context.lineWidth=1;
    context.stroke();
    context.closePath();    
    
    // contour
    splines_points_normals = turn_pixels_into_splines();
    draw_the_splines(context, splines_points_normals[0]);
    
    // values
    context.font = "16px Arial";
    context.fillStyle = "#777777";
    context.textAlign = "center";
    context.textBaseline = "middle";    
    for(var i = 0; i < pixels.length; ++i)
        for(var j = 0; j < pixels[0].length; ++j) {
            context.fillText(pixels[i][j], (j + 0.5)*pixel_size, (i + 0.5)*pixel_size);
        }
}

// pgm import
function space_divided(text) {
    var new_text = text.replace('\r', ' ');
    new_text = new_text.replace('\n', ' ');
    new_text = new_text.replace('\t', ' ');
    while(true) {
        new_new_text = new_text.replace('  ', ' ');
        if(new_new_text.length == new_text.length)
            return new_text;
        new_text = new_new_text;    
    }
}

function reimport_image() {
    var text = document.getElementById("import_PGM").value;
    document.getElementById("import_status").innerHTML = "";
    var lines = text.split("\n");
    var no_comments = []
    for(var i = 0; i < lines.length; ++i) {
        var new_line = lines[i].trim();
        if (new_line == "" || new_line[0] == '#')
            continue;
        no_comments.push(new_line);
    }
    var numbers = space_divided(no_comments.join(' ')).split(' ');
    if(numbers[0] != "P2") {
        document.getElementById("import_status").innerHTML = "Sorry, I can only import grayscale Netpbm (*.pgm = 'P2...')";
        return;
    }
    try {
        var new_w = parseInt(numbers[1]);
        var new_h = parseInt(numbers[2]);
        var new_depth = parseInt(numbers[3]);
        if(numbers.length > new_w * new_h + 4) {
            document.getElementById("import_status").innerHTML = "Sorry, there's some extra data I couldn't parse.";
            return;
        }
        if(numbers.length < new_w * new_h + 4) {
            document.getElementById("import_status").innerHTML = "Sorry, not enough data to form an image.";
            return;
        }
        h = 1024.0 * new_h / new_w;
        document.getElementById("canvas").height = h;
        pixel_size = w / new_w;
        iw = new_w;
        ih = new_h;
        reset_pixels();
        for(var i = 0; i < new_h; ++i)
            for(var j = 0; j < new_w; ++j)
                pixels[i][j] = parseInt(numbers[4 + i*new_w + j]) / new_depth;
    } catch (error) {
        document.getElementById("import_status").innerHTML = "Sorry, couldn't parse that. " + error.message;
    }
    draw_canvas();  
}

// ui
function reset_all() {
    reset_pixels();
    draw_canvas();
}

function reset_magic_numbers() {
    nd = parseFloat(document.getElementById("nd").value);
    weight = parseFloat(document.getElementById("weight").value);
    shiftd = parseFloat(document.getElementById("shiftd").value);
    threshold = parseFloat(document.getElementById("threshold").value);
    draw_canvas();
}

  </script>
  </head>
  <body>
    <center>
    <br>
    <br>
    <!--
    <textarea id="import_PGM" rows=14 onInput="reimport_image()">
P2
# Shows the word "FEEP" (example from Netpbm man page on PGM)
24 7
15
0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0
0  3  3  3  3  0  0  7  7  7  7  0  0 11 11 11 11  0  0 15 15 15 15  0
0  3  0  0  0  0  0  7  0  0  0  0  0 11  0  0  0  0  0 15  0  0 15  0
0  3  3  3  0  0  0  7  7  7  0  0  0 11 11 11  0  0  0 15 15 15 15  0
0  3  0  0  0  0  0  7  0  0  0  0  0 11  0  0  0  0  0 15  0  0  0  0
0  3  0  0  0  0  0  7  7  7  7  0  0 11 11 11 11  0  0 15  0  0  0  0
0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 
    </textarea>
    -->
    <textarea id="import_PGM" rows=14 onInput="reimport_image()">
P2
# Shows the word "FEEP" (example from Netpbm man page on PGM)
3 3
15
0 0 0 0 7 0 0 0 0
    </textarea>
    <p id="import_status" class="comment">
    </p>
    <br>    
    <canvas id="canvas" width=1024 height=1024></canvas>
    <form>
        Click to change: 
        <input type="radio" name="tool" id="tool_1" value="image" checked=true><label for="tool_1">image; </label>
        <input type="radio" name="tool" id="tool_2" value="points"><label for="tool_2">points; </label>
        <input type="radio" name="tool" id="tool_3" value="tangents"><label for="tool_3">tangents; </label>
        <br>

        nd: <input type="text" id="nd" value="1.5">
        weight: <input type="text" id="weight" value="4">
        shiftd: <input type="text" id="shiftd" value="1.5">
        threshold: <input type="text" id="threshold" value="0.5">
        <button type="button" onclick="reset_magic_numbers()">&larr; Apply</button> 
        <button type="button" style="width: 108pt;" onclick="reset_all()">Reset pixels</button>        
    </form>
    <br>

    <script language="JavaScript">
    init_canvas();    
    reset_magic_numbers();
    reimport_image();    
    </script>
           
    </center>
  </body>
</html>
