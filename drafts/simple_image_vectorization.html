<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Simple image vectorization</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
    width: 300pt;
}

table {
    border-width: 0pt;
}

td {
    vertical-align: top;
    padding: 6pt 12pt 6pt 12pt;
    font-size: 16pt;
    border: 1px solid black;
    width: 600pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

input[type="text"] {
    width: 48pt;
    height: 22pt;
    font-size: 16pt;
    text-align: center;
}

input[type="radio"] {
    height: 16pt;
    width: 16pt;
    font-size: 16pt;
}

button {
    width: 128pt;
    height: 26pt;
    font-size: 16pt;
    text-align: center;
}

textarea {
    width: 505pt;
    font-size: 12pt;
    font-family: monospace;
}

.comment {
    font-size: 12pt;
    text-align:center;
    font-family: sans-serif;
    padding-bottom: 24pt;
}

.formula {
    font-family: sans-serif;
    font-size: 15pt;
    font-style: italic;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

    </style>
    <script language="JavaScript">
// client
var w = 640.0;
var h = 640.0;

// algorithm
var threshold = 0.5;

// pixels
var pixels = [];
var pixel_size;

function reset_pixels(w, h) {
    pixels = [];
    for(var i = 0; i < h; ++i) {
        pixelsi = []
        for(var j = 0; j <w; ++j)
            pixelsi.push(0);
        pixels.push(pixelsi);
    }
}

var points_and_tangents = [];
var splines = [];

// solver specific to [0..1] parametrized splines
function spline_for(p1, p1d, p2, p2d) {
//     A = [
//         [1, 0, 0, 0],
//         [0, 1, 0, 0],
//         [1, 1, 1, 1],
//         [0, 1, 2, 3]];
//     B = [p1, p1d, p2, p2d]
    return [
        p1,
        p1d,
        3 * p2 - p2d - 3*p1 - 2*p1d,
        p2d + p1d - 2*p2 + 2*p1
    ];
}

// polynomial
function polynomial_in_x(A, x){
    var y = 0.0;
    for(var i = 0; i < A.length; ++i){
        y += A[i] * Math.pow(x, i);
    }
    return y;
}

// pixel value with out of bounds checks
function pixel_in(pixels, i, j) {
    if(i >= pixels.length)
        return pixel_in(pixels, pixels.length-1, j);
    if(i < 0) 
        return pixel_in(pixels, 0, j);
    if(j >= pixels[0].length)
        return pixel_in(pixels, i, pixels[0].length-1);
    if(j < 0)
        return pixel_in(pixels, i, 0);
    return pixels[i][j];
}

// linear interpolation
function value_in(pixels, x, y) {
    var j = Math.floor(x - 0.5);
    var tj = x - 0.5 - j;
    var i = Math.floor(y - 0.5);
    var ti = y - 0.5 - i;
    return pixel_in(pixels, i, j) * (1 - ti) * (1 - tj)
         + pixel_in(pixels, i, j+1) * (1 - ti) * (tj)
         + pixel_in(pixels, i+1, j+1) * (ti) * (tj)
         + pixel_in(pixels, i+1, j) * (ti) * (1 - tj);
}

// gradient
function gradient(pixels, x, y) {
    const epsilon = 1e-5;
    return [(value_in(pixels, x + epsilon, y) - value_in(pixels, x, y)) / epsilon,
            (value_in(pixels, x, y + epsilon) - value_in(pixels, x, y)) / epsilon];
}

// how far should you shift the point to meet the isoline 
// if value_in were a distance function
function gradient_shift(pixels, threshold, x, y) {
    var g = gradient(pixels, x, y);
    var g_norm = Math.sqrt(g[0]*g[0] + g[1]*g[1]);
    var d = threshold - value_in(pixels, x, y);
    return [g[0] * d / g_norm / g_norm, g[1] * d / g_norm / g_norm];
}

// brings a point closer to the threshold isoline
function fit_point_better(pixels, threshold, point) {
    const small_enough_error = 1/255;
    if(Math.abs(value_in(pixels, point[0], point[1]) - threshold) < small_enough_error)
        return point;
    gs = gradient_shift(pixels, threshold, point[0], point[1])
    return fit_point_better(pixels, threshold, [point[0] + gs[0], point[1] + gs[1]]);
}

// the algorithm itself
function turn_pixels_into_points_and_tangents(pixels, threshold) {
    var points = [];
    var tangents = [];

    // "horizontal" pieces    
    for(var i = 0; i <= pixels.length; i += 1) {
        var old_point = [];
        var old_tangent = [];
        for(var j = 0; j <= pixels[0].length; j += 1) {
            // if right, left, top, and bottom pixels have a sign change, there should be a spline there
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;
            if(sign_change_on_the_right || sign_change_on_the_left) {
                // fits the point on a threshold isoline
                var point = fit_point_better(pixels, threshold, [j, i]);
                var g = gradient(pixels, point[0], point[1]);
                
                // we want our tangent to be X-positive for horizontal pieces
                var tangent = g[1] >= 0 ? [g[1], -g[0]] : [-g[1], g[0]];
                
                // this is an T or X junction, the tangent is ambiguous
                if(sign_change_on_the_left + sign_change_on_the_right + sign_change_on_the_top + sign_change_on_the_bottom > 2)
                    tangent = [0., 0.];
                    
                // store the point+tangent and the previous point+tangent if there is one
                if(sign_change_on_the_left && old_point) {                    
                    points.push([old_point, point]);
                    tangents.push([old_tangent, tangent]);
                }
                
                // save the point+tangent for later
                if(sign_change_on_the_right) {
                    old_point = point;
                    old_tangent = tangent;
                }   
            }      
        }
    }

    // "vertical" pieces
    for(var j = 0; j <= pixels[0].length; j += 1) {
        var old_point = [];
        var old_tangent = [];
        for(var i = 0; i <= pixels.length; i += 1) {
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;
            if(sign_change_on_the_bottom || sign_change_on_the_top) {
                var point = fit_point_better(pixels, threshold, [j, i]);
                var g = gradient(pixels, point[0], point[1]);             
                var tangent = g[0] < 0 ? [g[1], -g[0]] : [-g[1], g[0]];
                if(sign_change_on_the_left + sign_change_on_the_right + sign_change_on_the_top + sign_change_on_the_bottom > 2)
                    tangent = [0., 0.];
                if(sign_change_on_the_top && old_point) {
                    points.push([old_point, point]);
                    tangents.push([old_tangent, tangent]);
                }
                if(sign_change_on_the_bottom) {
                    old_point = point;
                    old_tangent = tangent;
                }   
            }      
        }
    }
    return [points, tangents];
}

function turn_points_and_tangents_into_splines(points_and_tangents)
{
    var splines = [];
    var points = points_and_tangents[0];
    var tangents = points_and_tangents[1];
    for(var i = 0; i < points.length; ++i) {
        var Px = spline_for(points[i][0][0], tangents[i][0][0], points[i][1][0], tangents[i][1][0]);
        var Py = spline_for(points[i][0][1], tangents[i][0][1], points[i][1][1], tangents[i][1][1]);
        splines.push([Px, Py]);
    }
    return splines
}

function draw_the_splines(context, splines) {
    context.beginPath();
    for(var i = 0; i < splines.length; ++i) {
        for(var k = 0; k < pixel_size; k += 1) {
            var t1 = (k) / pixel_size;
            var t2 = (k + 1) / pixel_size;
            var x1 = polynomial_in_x(splines[i][0], t1) * pixel_size;
            var y1 = polynomial_in_x(splines[i][1], t1) * pixel_size;
            var x2 = polynomial_in_x(splines[i][0], t2) * pixel_size;
            var y2 = polynomial_in_x(splines[i][1], t2) * pixel_size;
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
        }
    }
    
    context.strokeStyle="#AA3366";
    context.lineWidth = 3;
    context.stroke();
    context.closePath();    
}

// gray-scale canvas
function draw_greyscale_canvas() {
    var canvas = document.getElementById("greyscale_canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var pixel_value = Math.max(Math.min(pixels[in_pixels_i][in_pixels_j], 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;
    }
    context.putImageData(pixel_field, -0.5, -0.5);
    
    // pixel grid
    context.beginPath();
    for(var i = pixel_size; i <= h; i += pixel_size) {
        context.moveTo(0.0, i);
        context.lineTo(w, i);
    }
    for(var j = pixel_size; j <= w; j += pixel_size) {
        context.moveTo(j, 0.0);
        context.lineTo(j, h);
    }
    context.strokeStyle="#AAAAAA";
    context.lineWidth=1;
    context.setLineDash([4, 4]);
    context.stroke();
    context.setLineDash([]);
    context.closePath();
    
    context.font = "14px Arial";
    context.fillStyle = "#000000";
    context.textAlign = "center";
    context.textBaseline = "middle"; 
    for(var i = 0; i < pixels.length; ++i) {
        for(var j = 0; j< pixels[0].length; ++j) {
           context.fillText(Math.floor(255 * pixels[i][j]).toString(), (j + 0.5) * pixel_size, (i + 0.5) * pixel_size);
        }
    }
}

// gray-scale canvas contour
function draw_greyscale_canvas_contour() {
    var canvas = document.getElementById("greyscale_canvas_contour");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var pixel_value = Math.max(Math.min(pixels[in_pixels_i][in_pixels_j], 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;
        if ( pixel_in(pixels, in_pixels_i, in_pixels_j) < threshold 
          != pixel_in(pixels, Math.floor((on_canvas_i - 1) / pixel_size), in_pixels_j) < threshold 
        ||   pixel_in(pixels, in_pixels_i, in_pixels_j) < threshold 
          != pixel_in(pixels, in_pixels_i, Math.floor((on_canvas_j - 1) / pixel_size)) < threshold) {
            pixel_field.data[i + 0] = 0x11;
            pixel_field.data[i + 1] = 0x11;
            pixel_field.data[i + 2] = 0x11;
        }
           
    }
    context.putImageData(pixel_field, -0.5, -0.5);
    
    // pixel grid
    context.beginPath();
    for(var i = pixel_size; i <= h; i += pixel_size) {
        context.moveTo(0.0, i);
        context.lineTo(w, i);
    }
    for(var j = pixel_size; j <= w; j += pixel_size) {
        context.moveTo(j, 0.0);
        context.lineTo(j, h);
    }
    context.strokeStyle="#AAAAAA";
    context.lineWidth=1;
    context.setLineDash([4, 4]);
    context.stroke();
    context.setLineDash([]);
    context.closePath();
}

// interpolation canvas
function draw_interpolation_canvas() {
    var canvas = document.getElementById("interpolation_canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var interpolated_in = function (pixels, x, y) {
        return value_in(pixels, x, y);
    }
    if(document.getElementById("interpolation_1").checked) {
        interpolated_in = function (pixels, x, y) {
            return pixel_in(pixels, Math.floor(y), Math.floor(x));
        }
    }
    
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var x = on_canvas_j / pixel_size;
        var y = on_canvas_i / pixel_size;
        var pixel_value = Math.max(Math.min(interpolated_in(pixels, x, y), 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;
        if ( interpolated_in(pixels, x, y) < threshold 
          != interpolated_in(pixels, x - 1 / pixel_size, y) < threshold 
        ||   interpolated_in(pixels, x, y) < threshold 
          != interpolated_in(pixels, x, y - 1 / pixel_size) < threshold) {
            pixel_field.data[i + 0] = 0x11;
            pixel_field.data[i + 1] = 0x11;
            pixel_field.data[i + 2] = 0x11;
        }
           
    }
    context.putImageData(pixel_field, -0.5, -0.5);
}

// fitting
function fit_point_several_times(pixels, threshold, point, n) {
    const small_enough_error = 1/255;
    if(n == 0)
        return point;
    gs = gradient_shift(pixels, threshold, point[0], point[1])
    return fit_point_several_times(pixels, threshold, [point[0] + gs[0], point[1] + gs[1]], n-1);
}

var fit_iterations = 0;

function fit_the_point_iteration() {
    fit_iterations++;
    if(fit_iterations > 0 && fit_iterations < 4)
        document.getElementById("fitting_button").innerHTML = "Fit more";        
    else if (fit_iterations == 4)
        document.getElementById("fitting_button").innerHTML = "Start over"; 
    else if (fit_iterations == 5) {
        document.getElementById("fitting_button").innerHTML = "Fit the contour"; 
        fit_iterations = 0;
    }
    draw_fitting_canvas();
}

function draw_fitting_canvas(){
    var canvas = document.getElementById("fitting_canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var x = on_canvas_j / pixel_size;
        var y = on_canvas_i / pixel_size;
        var pixel_value = Math.max(Math.min(value_in(pixels, x, y), 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;          
    }
    context.putImageData(pixel_field, -0.5, -0.5);
    
    // contour
    context.beginPath();
    // "horizontal" pieces    
    for(var i = 0; i <= pixels.length; i += 1) {
        var old_point = [];
        for(var j = 0; j <= pixels[0].length; j += 1) {
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;
            if(sign_change_on_the_right || sign_change_on_the_left) {
                var point = fit_point_several_times(pixels, threshold, [j, i], fit_iterations);
                    
                // draw the line
                if(sign_change_on_the_left && old_point) {                    
                    context.moveTo(old_point[0] * pixel_size, old_point[1] * pixel_size);
                    context.lineTo(point[0] * pixel_size, point[1] * pixel_size);
                }
                
                // save the point+tangent for later
                if(sign_change_on_the_right) {
                    old_point = point;
                }   
            }      
        }
    }

    // "vertical" pieces
    for(var j = 0; j <= pixels[0].length; j += 1) {
        var old_point = [];
        for(var i = 0; i <= pixels.length; i += 1) {
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;
            if(sign_change_on_the_bottom || sign_change_on_the_top) {
                var point = fit_point_several_times(pixels, threshold, [j, i], fit_iterations);
                if(sign_change_on_the_top && old_point) {
                    context.moveTo(old_point[0] * pixel_size, old_point[1] * pixel_size);
                    context.lineTo(point[0] * pixel_size, point[1] * pixel_size);
                }
                if(sign_change_on_the_bottom) {
                    old_point = point;
                }   
            }      
        }
    }
    context.strokeStyle="#AA3366";
    context.lineWidth = 3;
    context.stroke();
    context.closePath(); 
}

// cubic
var cubic_xs = [300, 150, 500, 600];
var cubic_ys = [200, 400, 550, 100];
var cubic_n = 4;
var cubic_i = 0;

// todo: remove
function client_to_x(x) {return x;}
function client_to_y(x) {return x;}
function x_to_client(x) {return x;} 
function y_to_client(x) {return x;}

function init_cubic(){
    cubic = document.getElementById("cubic_canvas");
    var canvas_rect = cubic.getBoundingClientRect();
    draw_cubic_canvas(0, 0, false);

    cubic.addEventListener('mousemove', function(e){
        var canvas_rect = cubic.getBoundingClientRect();
        draw_cubic_canvas(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1){
            cubic_xs[cubic_i] = client_to_x(e.clientX - canvas_rect.left);
            cubic_ys[cubic_i] = client_to_y(e.clientY - canvas_rect.top);
            draw_cubic_canvas(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
        }
    }, false);

    cubic.addEventListener('mousedown', function(e){
        var canvas_rect = cubic.getBoundingClientRect();
        cubic_xs[cubic_i] = client_to_x(e.clientX - canvas_rect.left);
        cubic_ys[cubic_i] = client_to_y(e.clientY - canvas_rect.top);
        draw_cubic_canvas(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
    }, false);

    cubic.addEventListener('mouseleave', function(e){
        draw_cubic_canvas(0, 0, false);
    }, false);
}

function draw_cubic_canvas(client_x, client_y, do_guides){
    cubic = document.getElementById("cubic_canvas");
    var context = cubic.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // cubic
    /*var A = [];
    var B = [];

    A[0] = [];
    for(var j = 0; j < cubic_n-1; ++j)
        A[0][j+1] = Math.pow(cubic_xs[1], j) * (j+1);
    A[0][0] = 0.0;
    B[0] = (cubic_ys[1] - cubic_ys[0]) / (cubic_xs[1] - cubic_xs[0]);

    for(var i = 1; i < cubic_n-1; ++i){
        A[i] = [];
        for(var j = 0; j < cubic_n; ++j){
            A[i][j] = Math.pow(cubic_xs[i], j);
        }
        B[i] = cubic_ys[i];
    }

    A[cubic_n-1] = [];
    for(var j = 0; j < cubic_n-1; ++j)
        A[cubic_n-1][j+1] = Math.pow(cubic_xs[cubic_n-2], j) * (j+1);
    A[cubic_n-1][0] = 0.0;
    B[cubic_n-1] = (cubic_ys[cubic_n-1] - cubic_ys[cubic_n-2]) / (cubic_xs[cubic_n-1] - cubic_xs[cubic_n-2]);

    X = solved_linear(A, B, cubic_n);

    // back
    context.beginPath();
    for(var j = 1; j < w; ++j){
        x1 = client_to_x(j-1);
        x2 = client_to_x(j);
        y1 = polynomial_in_x(X, x1, cubic_n);
        y2 = polynomial_in_x(X, x2, cubic_n);
        context.moveTo(x_to_client(x1), y_to_client(y1));
        context.lineTo(x_to_client(x2), y_to_client(y2));
    }
    context.strokeStyle="#FF9988";
    context.stroke();
    context.closePath();
    // front
    context.beginPath();
    for(var j = 1; j < w; ++j){
        x1 = client_to_x(j-1);
        x2 = client_to_x(j);
        if(x1 > cubic_xs[1] && x2 < cubic_xs[2]){
            y1 = polynomial_in_x(X, x1, cubic_n);
            y2 = polynomial_in_x(X, x2, cubic_n);
            context.moveTo(x_to_client(x1), y_to_client(y1));
            context.lineTo(x_to_client(x2), y_to_client(y2));
        }
    }
    context.strokeStyle="#661100";
    context.stroke();
    context.closePath();*/
    
    var Px = spline_for(cubic_xs[1], cubic_xs[0] - cubic_xs[1], cubic_xs[2], cubic_xs[3] - cubic_xs[2]);
    var Py = spline_for(cubic_ys[1], cubic_ys[0] - cubic_ys[1], cubic_ys[2], cubic_ys[3] - cubic_ys[2]);
    
    context.beginPath();
    for(var i = 0; i < w; ++i) {    
        var t1 = (i) / w;
        var t2 = (i + 1) / w;
        var x1 = polynomial_in_x(Px, t1);
        var y1 = polynomial_in_x(Py, t1);
        var x2 = polynomial_in_x(Px, t2);
        var y2 = polynomial_in_x(Py, t2);
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
    }
    context.strokeStyle="#AA3311";
    context.stroke();
    context.closePath();
    
    // dots
    context.beginPath();
    for(var i = 0; i < cubic_n; ++i){
        context.moveTo(x_to_client(cubic_xs[i])-5.5, y_to_client(cubic_ys[i])+5.5);
        context.lineTo(x_to_client(cubic_xs[i])+5.5, y_to_client(cubic_ys[i])-5.5);
        context.moveTo(x_to_client(cubic_xs[i])+5.5, y_to_client(cubic_ys[i])+5.5);
        context.lineTo(x_to_client(cubic_xs[i])-5.5, y_to_client(cubic_ys[i])-5.5);
    }
    context.strokeStyle="#AA3311";
    context.stroke();
    context.closePath();

    // tangents
    context.beginPath();
    context.setLineDash([4, 4]);
    context.moveTo(x_to_client(cubic_xs[0]), y_to_client(cubic_ys[0]));
    context.lineTo(x_to_client(cubic_xs[1]), y_to_client(cubic_ys[1]));
    context.moveTo(x_to_client(cubic_xs[cubic_n-2]), y_to_client(cubic_ys[cubic_n-2]));
    context.lineTo(x_to_client(cubic_xs[cubic_n-1]), y_to_client(cubic_ys[cubic_n-1]));
    context.strokeStyle="#AA3311";
    context.stroke();
    context.setLineDash([]);
    context.closePath();

    // guides
    if(do_guides){
        min_d = Math.pow(cubic_xs[0] - client_to_x(client_x), 2) + Math.pow(cubic_ys[0] - client_to_y(client_y), 2);
        min_i = 0;
        for(var i = 1; i < cubic_n; ++i){
            var di = Math.pow(cubic_xs[i] - client_to_x(client_x), 2) + Math.pow(cubic_ys[i] - client_to_y(client_y), 2);
            if(di < min_d){
                min_d = di;
                min_i = i;
            }
        }
        cubic_i = min_i;
        context.setLineDash([4, 4]);
        context.beginPath();
        context.moveTo(x_to_client(cubic_xs[min_i]), y_to_client(cubic_ys[min_i]));
        context.lineTo(client_x, client_y);
        context.strokeStyle="#AA3311";
        context.stroke();
        context.closePath();
        context.setLineDash([]);
    }
}

// the main canvas
var cur_point_indexes = [];
var cur_point_in_pair_indexes = [];
var cur_tangent_index = -1;
var cur_tangent_in_pair_index = -1;
function init_canvas(){
    var canvas = document.getElementById("canvas");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        var x = e.clientX - canvas_rect.left;
        var y = e.clientY - canvas_rect.top;
        if(document.getElementById("tool_2").checked) { // points
            cur_point_indexes = [];
            cur_point_in_pair_indexes = [];
            var points = points_and_tangents[0];
            var min_d2 = (w+h)*(w+h);
            for(var i = 0; i < points.length; ++i) {
                for(var j = 0; j < 2; ++ j) {
                    var px = pixel_size * points[i][j][0];
                    var py = pixel_size * points[i][j][1];
                    var d2 = (px - x)*(px - x) + (py - y)*(py - y);
                    if(cur_point_indexes.length == 0 || d2 < min_d2) {
                        cur_point_indexes = [i];
                        cur_point_in_pair_indexes = [j];
                        min_d2 = d2;
                    }else if(d2 == min_d2) {
                        cur_point_indexes.push(i);
                        cur_point_in_pair_indexes.push(j);
                    }
                }
            }
        } else if(document.getElementById("tool_3").checked) { // tangents
            cur_tangent_index = -1;
            cur_tangent_in_pair_index = -1;
            var points = points_and_tangents[0];
            var tangents = points_and_tangents[1];
            var min_d2 = (w+h)*(w+h);
            for(var i = 0; i < points.length; ++i) {
                for(var j = 0; j < 2; ++ j) {
                    var px = pixel_size * (points[i][j][0] + tangents[i][j][0]);
                    var py = pixel_size * (points[i][j][1] + tangents[i][j][1]);
                    var d2 = (px - x)*(px - x) + (py - y)*(py - y);
                    if(cur_tangent_index == -1 || d2 < min_d2) {
                        cur_tangent_index = i;
                        cur_tangent_in_pair_index = j;
                        min_d2 = d2;
                    }
                }
            }
        }
    }, false);
     
    canvas.addEventListener('mousemove', function(e){
        if(e.buttons == 1){
            canvas_rect = canvas.getBoundingClientRect();
            var x = e.clientX - canvas_rect.left;
            var y = e.clientY - canvas_rect.top;
            if(document.getElementById("tool_2").checked) { // points
                var points = points_and_tangents[0];
                for(var i = 0; i < cur_point_indexes.length; ++i) {
                    points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][0] = x / pixel_size;
                    points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][1] = y / pixel_size;
                }               
            } else if(document.getElementById("tool_3").checked) { // tangents
                var points = points_and_tangents[0];
                var tangents = points_and_tangents[1];
                tangents[cur_tangent_index][cur_tangent_in_pair_index][0] = x / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][0];
                tangents[cur_tangent_index][cur_tangent_in_pair_index][1] = y / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][1];
                splines = turn_points_and_tangents_into_splines(points_and_tangents);  
            }
            splines = turn_points_and_tangents_into_splines(points_and_tangents);
            draw_canvas();
        }
    }, false);
    
    canvas.addEventListener('mouseup', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        var x = e.clientX - canvas_rect.left;
        var y = e.clientY - canvas_rect.top;
        if(document.getElementById("tool_1").checked) {
            var in_pixels_i = Math.floor(y / pixel_size);
            var in_pixels_j = Math.floor(x / pixel_size);
            pixels[in_pixels_i][in_pixels_j] *= 7;
            if(e.shiftKey)       
                pixels[in_pixels_i][in_pixels_j] += 7;
            else
                pixels[in_pixels_i][in_pixels_j] += 1;
            pixels[in_pixels_i][in_pixels_j] = Math.floor(pixels[in_pixels_i][in_pixels_j]) % 8;
            pixels[in_pixels_i][in_pixels_j] /= 7;
            points_and_tangents = turn_pixels_into_points_and_tangents(pixels, threshold);
            splines = turn_points_and_tangents_into_splines(points_and_tangents);
        } else if(document.getElementById("tool_2").checked) { // points
            var points = points_and_tangents[0];
            for(var i = 0; i < cur_point_indexes.length; ++i) {
                points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][0] = x / pixel_size;
                points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][1] = y / pixel_size;
            }
            splines = turn_points_and_tangents_into_splines(points_and_tangents);  
        } else if(document.getElementById("tool_3").checked) { // tangents
            var points = points_and_tangents[0];
            var tangents = points_and_tangents[1];
            tangents[cur_tangent_index][cur_tangent_in_pair_index][0] = x / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][0];
            tangents[cur_tangent_index][cur_tangent_in_pair_index][1] = y / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][1];
            splines = turn_points_and_tangents_into_splines(points_and_tangents);  
        }
        draw_canvas();            
    }, false);
    
    draw_canvas();
}


function draw_canvas(){
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // pixels
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
        var on_canvas_j = Math.floor(i / 4) % w;
        var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
        var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
        var pixel_value = Math.max(Math.min(pixels[in_pixels_i][in_pixels_j], 1.0), 0.0);
        pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
        pixel_field.data[i + 2] = 0xFF;
        pixel_field.data[i + 3] = 0xFF;
    }
    context.putImageData(pixel_field, -0.5, -0.5);
    
    // pixel grid
    context.beginPath();
    for(var i = pixel_size; i <= h; i += pixel_size) {
        context.moveTo(0.0, i);
        context.lineTo(w, i);
    }
    for(var j = pixel_size; j <= w; j += pixel_size) {
        context.moveTo(j, 0.0);
        context.lineTo(j, h);
    }
    context.strokeStyle="#AAAAAA";
    context.lineWidth=1;
    context.setLineDash([4, 4]);
    context.stroke();
    context.setLineDash([]);
    context.closePath();
    
    // contour
    draw_the_splines(context, splines);
    
    // points if needed
    if(document.getElementById("tool_2").checked) {
        var points = points_and_tangents[0];
        for(var i = 0; i < points.length; ++i) {
            for(var j = 0; j < 2; ++j) {
                context.beginPath();
                context.arc(pixel_size * points[i][j][0], pixel_size * points[i][j][1], 3, 0, 2*Math.PI);
                context.fillStyle="#6633AA";
                context.fill();
                context.closePath();        
            }
        }
    }
    
    // tangents if needed
    if(document.getElementById("tool_3").checked) {
        var points = points_and_tangents[0];
        var tangents = points_and_tangents[1];
        for(var i = 0; i < points.length; ++i) {
            for(var j = 0; j < 2; ++j) {
                context.beginPath();
                context.arc(pixel_size * points[i][j][0], pixel_size * points[i][j][1], 3, 0, 2*Math.PI);
                context.fillStyle="#AA3366";
                context.fill();
                context.closePath();
                
                context.beginPath();
                context.lineWidth=1;
                context.moveTo(pixel_size * points[i][j][0], pixel_size * points[i][j][1]);
                context.lineTo(pixel_size * (points[i][j][0] + tangents[i][j][0]), pixel_size * (points[i][j][1] + tangents[i][j][1]));
                context.strokeStyle="#6633AA";
                context.setLineDash([2, 2]);
                context.stroke();
                context.setLineDash([]);
                context.closePath();
                
                context.beginPath();
                context.arc(
                    pixel_size * (points[i][j][0] + tangents[i][j][0]), 
                    pixel_size * (points[i][j][1] + tangents[i][j][1]), 3, 0, 2*Math.PI);
                context.fillStyle="#6633AA";
                context.fill();
                context.closePath();        
            }
        }
    }
}

// import from PGM
function reimport_image() {
    space_divided = function(text) {
        var new_text = text.replace('\r', ' ');
        new_text = new_text.replace('\n', ' ');
        new_text = new_text.replace('\t', ' ');
        while(true) {
            new_new_text = new_text.replace('  ', ' ');
            if(new_new_text.length == new_text.length)
                return new_text;
            new_text = new_new_text;    
        }
    }
    var text = document.getElementById("import_PGM").value;
    document.getElementById("import_status").innerHTML = "";
    var lines = text.split("\n");
    var no_comments = []
    for(var i = 0; i < lines.length; ++i) {
        var new_line = lines[i].trim();
        if (new_line == "" || new_line[0] == '#')
            continue;
        no_comments.push(new_line);
    }
    var numbers = space_divided(no_comments.join(' ')).split(' ');
    if(numbers[0] != "P2") {
        document.getElementById("import_status").innerHTML = "Sorry, I can only import grayscale Netpbm (*.pgm = 'P2...')";
        return;
    }
    try {
        var new_w = parseInt(numbers[1]);
        var new_h = parseInt(numbers[2]);
        var new_depth = parseInt(numbers[3]);
        if(numbers.length > new_w * new_h + 4) {
            document.getElementById("import_status").innerHTML = "Sorry, there's some extra data I couldn't parse.";
            return;
        }
        if(numbers.length < new_w * new_h + 4) {
            document.getElementById("import_status").innerHTML = "Sorry, not enough data to form an image.";
            return;
        }
        h = w * new_h / new_w;
        document.getElementById("canvas").height = h;
        pixel_size = w / new_w;
        reset_pixels(new_w, new_h);
        for(var i = 0; i < new_h; ++i)
            for(var j = 0; j < new_w; ++j)
                pixels[i][j] = parseInt(numbers[4 + i*new_w + j]) / new_depth;
        points_and_tangents = turn_pixels_into_points_and_tangents(pixels, threshold);
        splines = turn_points_and_tangents_into_splines(points_and_tangents);
    } catch (error) {
        document.getElementById("import_status").innerHTML = "Sorry, couldn't parse that. " + error.message;
    }
    draw_canvas();  
}


// export to SVG
function export_splines() {
    const printable = function(x) {
        return Math.floor(x * 100);
    };
    var svg = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n";
    svg += "<svg width=\"" + printable(pixels[0].length) + "\" height=\"" + printable(pixels.length);
    svg += "\"\n  viewBox=\"0 0 " + printable(pixels[0].length) + " " + printable(pixels.length) + "\" xmlns=\"http://www.w3.org/2000/svg\">\n";
    for(var i = 0; i < points_and_tangents[0].length; ++i) {
        var p1 = points_and_tangents[0][i][0];
        var p2 = points_and_tangents[0][i][1];
        var p1_n = points_and_tangents[1][i][0];
        var p2_n = points_and_tangents[1][i][1];
        svg += "<path fill=\"none\" stroke=\"rgb(0,0,0)\" \n  d=\"M " + printable(p1[0]) + "," + printable(p1[1]) + " ";
        svg += "C " + printable(p1[0] + p1_n[0] / 3.) + "," + printable(p1[1] + p1_n[1] / 3.); 
        svg += " " +  printable(p2[0] - p2_n[0] / 3.) + "," + printable(p2[1] - p2_n[1] / 3.) + " " + printable(p2[0]) + "," + printable(p2[1]) + "\"/>\n";
    }
    svg += "</svg>\n";
    document.getElementById("export_SVG").value = svg;
}

// ui
function reset_threshold() {
    threshold = parseFloat(document.getElementById("threshold").value);
}

function change_interpolation() {
    draw_interpolation_canvas();
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Simple image vectorization
    </h1>
    <p>
Image vectorization is when you have some soapy raster image and you make a crisp vector picture out of it.
    </p>
    <img style="width: 505pt;" src="https://upload.wikimedia.org/wikipedia/commons/6/6b/Bitmap_VS_SVG.svg"/>
    <p class="comment">
Yug, modifications by 3247 [<a href="https://creativecommons.org/licenses/by-sa/2.5">CC BY-SA 2.5</a>]
    </p>
    <p>
It's especially useful when you want to turn a satellite photo into a map. Or if you want to scan some blueprint and turn it into a CAD model. Or if you want to reissue an old game with low-resolution graphics and you don't want to redraw all the art-work from scratch.
    </p>
    <p>
The algorithm I'm going to show you has nothing to do with all these things. It's a basic vectorization technique which, in its original form, has little to none applications in the industry.
    </p>
    <p>
On the plus side, it illustrates the basic approach rather well. It shows how things like bi-linear interpolation, gradient descent, and parametric splines work together to solve a real world problem. At the very least, it makes learning about all these things a little more compelling.
    </p>
    
    <h2>
An input image
    </h2>
    <p>
A raster image is essentially a rectangular table of things. If it's a full-color RGB, then it's a table of triplets. Each element of a triplet represents a value in a reg, green, or blue channel of a colored image.
    </p>
    <p>
Medical images, such as obtained from computer tomography, are usually the tables of a single 12-bit or 16-bit integer. It's not a color really, since the values come from invisible X-ray radiation, but they are called gray-values nevertheless.
    </p>
    <p>
Satellite images may have a lot or channels. Apart from the colors from the visible specter they may contain ultra-violet and infra-red light. Channels may be represented by integers or floating point values.
    </p>
    <p>
Our image will be a simple gray-scale bitmap.
    </p>
    <canvas id="greyscale_canvas" width=640 height=640></canvas>
    <p>
Technically, we can turn it into some kind of vector representation with little effort. Let's just agree on some threshold, and find the contour of the pixels that have the values exceeding this threshold.
    </p>
    <canvas id="greyscale_canvas_contour" width=640 height=640></canvas>
    <p>
Well, it's simple, but it's not what we wanted. We want curves, not corners. And for that, we have to make our image less cornery.
    </p>
    <h2>
Image interpolation
    </h2>
    <p>
Let's say our image is not a table of values. Let's say we only know the values in the centers of the pixels, and we have to guess the values between them somehow.
    </p>
    <p>
This is called interpolation. The simplest case would be nearest neighbor interpolation, where for every point on an image, the value is the value from the nearest pixel center. But this simply turns it back into a table.
    </p>
    <p>
A little more advanced is the bilinear interpolation. The value is the linear sum of the four neighboring values. It looks like this.
    </p>
    <table>
    <tr><td>
    <pre>
// pixel value with out of bounds checks
function pixel_in(pixels, i, j) {
    if(i &gt;= pixels.length)
        return pixel_in(pixels, pixels.length-1, j);
    if(i &lt; 0) 
        return pixel_in(pixels, 0, j);
    if(j &gt;= pixels[0].length)
        return pixel_in(pixels, i, pixels[0].length-1);
    if(j &lt; 0)
        return pixel_in(pixels, i, 0);
    return pixels[i][j];
}

// linear interpolation
function value_in(pixels, x, y) {
    var j = Math.floor(x - 0.5);
    var tj = x - 0.5 - j;
    var i = Math.floor(y - 0.5);
    var ti = y - 0.5 - i;
    return pixel_in(pixels, i, j) * (1 - ti) * (1 - tj)
         + pixel_in(pixels, i, j+1) * (1 - ti) * (tj)
         + pixel_in(pixels, i+1, j+1) * (ti) * (tj)
         + pixel_in(pixels, i+1, j) * (ti) * (1 - tj);
}    
    </pre>
    </td></tr>
    </table>
    <p>
If we darken the pixels where the interpolated value meets the threshold, we'll get some kind of a contour.
    </p>
    <canvas id="interpolation_canvas" width=640 height=640></canvas>
    <form>
        Interpolation: 
        <input type="radio" name="interpolation" id="interpolation_1" value="neighbor" onclick="draw_interpolation_canvas()"><label for="interpolation_1">nearest neighbor; </label>
        <input type="radio" name="interpolation" id="interpolation_2" value="linear" checked=true onclick="draw_interpolation_canvas()"><label for="interpolation_2">bilinear. </label>
        <br>
    </form>
    <p>
There are another methods. Plenty of them. But linear interpolation solves the cornery border problem just fine. Except the border is still just smaller pixels. It's not a vector representation yet. 
    </p>
    <h2>
Turning an interpolated image into a contour
    </h2>
    <p>
We can borrow an idea from the <a href="https://wordsandbuttons.online/the_simplest_possible_smooth_contouring_algorithm.html">simplest possible smooth contouring</a> algorithm. We'll build initial border as a cornery pixel border, and then we'll use the smooth interpolated image to move each contour point onto the closest point where the image meets the threshold value.
    </p>
    <p>
With the distance field, it's easy. You just take its gradient, take the difference between the value you have and the threshold value. Since it's the distance field, the value difference is exactly the distance you should move your point for. And the gradient is the exact opposite direction. You just inverse, multiply, add — and you're there.
    </p>
    <p>
Unfortunately, we don't have a distance field. We have a continuous image which only looks like one.
    </p>
    <p>
But the principle still works. If you move along the gradient, you will get closer to the threshold value. And the more the difference, the further you have to go. It's just you wouldn't always get there in one try.
    </p>
    <p>
So let's try several times then. Let's make an <a href="https://wordsandbuttons.online/interactive_introduction_to_iterative_algorithms.html">iterative algorithm</a> out of it.
    </p>
    <table>
    <tr><td>
    <pre>
// gradient
function gradient(pixels, x, y) {
    const eps = 1e-5;
    return [(value_in(pixels, x + eps, y) - value_in(pixels, x, y)) / eps,
            (value_in(pixels, x, y + eps) - value_in(pixels, x, y)) / eps];
}

// how far should you shift the point to meet the isoline 
// if value_in were a distance function
function gradient_shift(pixels, threshold, x, y) {
    var g = gradient(pixels, x, y);
    var g_norm = Math.sqrt(g[0]*g[0] + g[1]*g[1]);
    var d = threshold - value_in(pixels, x, y);
    return [g[0] * d / g_norm / g_norm, g[1] * d / g_norm / g_norm];
}

// brings a point closer to the threshold isoline
function fit_point_better(pixels, threshold, point) {
    const ok_error = 1/255;
    if(Math.abs(value_in(pixels, point[0], point[1]) - threshold) &lt; ok_error)
        return point;
    gs = gradient_shift(pixels, threshold, point[0], point[1])
    var new_point = [point[0] + gs[0], point[1] + gs[1]];
    return fit_point_better(pixels, threshold, new_point);
}
    </pre>
    </td></tr>
    </table>    
    <p>
We'll just jump along the gradient several times until we're close enough to the point
    </p>
    <canvas id="fitting_canvas" width=640 height=640></canvas>
        <form>
        <button type="button" id="fitting_button" style="width: 200pt;" onclick="fit_the_point_iteration();">Fit the contour</button> 
    </form>
    <p>
That's all fine, but we can do better. Let's make the contour smooth.
    </p>
    
    <h2>
Cubic splines
    </h2>
    <p>
All we have to do to make the contour smooth is to turn each line segment into a parametric cubic curve.
    </p>
    <p>
It's probably sounds more complicated than it is. A parametric cubic curve is just a pair of polynomials. If you have the points and partial derivatives in this points, you can get the coefficients for them from this pair of <a href="https://wordsandbuttons.online/programmers_introduction_to_linear_equations.html">linear systems</a>:
    </p>
    <p class="formula" style="text-align: left; margin-left: 10em;">
Px(t<sub>1</sub>)' = 3a<sub>x</sub>t<sub>1</sub><sup>2</sup> + 2b<sub>x</sub>t<sub>1</sub> + c = dx<sub>1</sub>/dt
<br>
Px(t<sub>1</sub>) = a<sub>x</sub>t<sub>1</sub><sup>3</sup> + b<sub>x</sub>t<sub>1</sub><sup>2</sup> + c<sub>x</sub>t<sub>1</sub> + d = x<sub>1</sub>
<br>
Px(t<sub>2</sub>) = a<sub>x</sub>t<sub>2</sub><sup>3</sup> + b<sub>x</sub>t<sub>2</sub><sup>2</sup> + c<sub>x</sub>t<sub>2</sub> + d = x<sub>2</sub>
<br>
Px(t<sub>2</sub>)' = 3a<sub>x</sub>t<sub>2</sub><sup>2</sup> + 2b<sub>x</sub>t<sub>2</sub> + c = dx<sub>2</sub>/dt
    <br>
    <br>
Py(t<sub>1</sub>)' = 3a<sub>y</sub>t<sub>1</sub><sup>2</sup> + 2b<sub>y</sub>t<sub>1</sub> + c = dy<sub>1</sub>/dt
<br>
Py(t<sub>1</sub>) = a<sub>y</sub>t<sub>1</sub><sup>3</sup> + b<sub>y</sub>t<sub>1</sub><sup>2</sup> + c<sub>y</sub>t<sub>1</sub> + d = y<sub>1</sub>
<br>
Py(t<sub>2</sub>) = a<sub>y</sub>t<sub>2</sub><sup>3</sup> + b<sub>y</sub>t<sub>2</sub><sup>2</sup> + c<sub>y</sub>t<sub>2</sub> + d = y<sub>2</sub>
<br>
Py(t<sub>2</sub>)' = 3a<sub>y</sub>t<sub>2</sub><sup>2</sup> + 2b<sub>y</sub>t<sub>2</sub> + c = dy<sub>2</sub>/dt
    </p>    
    <p>
The curve itself will then look like this.
    </p>
    <canvas id="cubic_canvas" width=640 height=640></canvas>
        
    <h2>
Import PGM
    </h2>
    <p>
PGM is a 1-channel ASCII image format. You can make a PGM file in GIMP.
    </p>
    <textarea id="import_PGM" rows=20>
P2
16 16
255
0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   
0   77  125 38  0   0   0   0   0   0   0   0   0   0   0   0   
0   120 255 254 203 144 96  3   0   0   0   0   0   0   0   0   
0   34  253 255 255 255 255 230 154 94  8   0   0   0   0   0   
0   0   196 255 255 255 255 255 255 252 241 139 83  6   0   0   
0   0   149 255 255 255 255 255 255 255 255 255 250 213 80  0   
0   0   98  255 255 255 255 255 255 255 255 255 255 224 58  0   
0   0   2   224 255 255 255 255 255 255 255 242 152 4   0   0   
0   0   0   145 255 255 255 255 255 255 255 154 1   0   0   0   
0   0   0   82  251 255 255 255 255 255 255 253 156 1   0   0   
0   0   0   6   237 255 255 255 255 255 255 255 252 146 3   0   
0   0   0   0   149 255 255 243 149 252 255 255 255 240 21  0   
0   0   0   0   69  249 255 152 1   150 252 255 238 71  0   0   
0   0   0   0   0   211 224 4   0   1   137 240 86  0   0   0   
0   0   0   0   0   73  57  0   0   0   2   20  0   0   0   0   
0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0
    </textarea>
<!--
    <textarea id="import_PGM" rows=14>    
P2
3 3
15
0 0 0
0 14 0
0 0 0
    </textarea>
-->
    <form>
        Grey value threshold: <input type="text" id="threshold" value="0.5">
        <button type="button" style="width: 200pt;" onclick="reset_threshold(); reimport_image()">Reimport the PGM</button> 
    </form>
    <p id="import_status" class="comment">
    </p>
    <br>
    <h2>
Edit image and vectors
    </h2>
    <p>
Image editing overrides vectors. Click on a canvas to increase a pixel's luminosity. Click holding the Shift key to reduce it.
    </p>
    <canvas id="canvas" width=640 height=640></canvas>
    <form>
        Click to change: 
        <input type="radio" name="tool" id="tool_1" value="image" checked=true onclick="draw_canvas()"><label for="tool_1">image; </label>
        <input type="radio" name="tool" id="tool_2" value="points" onclick="draw_canvas()"><label for="tool_2">points; </label>
        <input type="radio" name="tool" id="tool_3" value="tangents" onclick="draw_canvas()"><label for="tool_3">tangents; </label>
        <br>  
    </form>
    <br>
    
    <h2>
Vector export
    </h2>
    <p>
Only the outline is supported. No filling, no coloring.
    </p>
    <form>
        <button type="button" onclick="export_splines()">Export to SVG</button>  
    </form>
    <br>
    <textarea id="export_SVG" rows=14>

    </textarea>

    <script language="JavaScript">
    reimport_image();    
    init_canvas();    
    draw_greyscale_canvas();
    draw_greyscale_canvas_contour();
    draw_interpolation_canvas();
    draw_fitting_canvas();
    init_cubic();
    </script>

    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
        <a href="index.html"><img src="favicon.ico"></a>
    </td>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        &nbsp;&larr; there's more.
    </td>
    <td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
        +
        <a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
        <a href="https://twitter.com/wordsandbuttons">Twitter</a> &
        <a href="https://news.ycombinator.com/from?site=wordsandbuttons.online">Hacker News</a>
    </td>
    </tr>
    </table>
    </center>
  </body>
</html>
