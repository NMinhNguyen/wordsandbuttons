<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Outperforming LAPACK with C metaprogramming</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.footer {
    margin-top: 64pt;
    padding-bottom: 32pt;
    font-family: sans-serif;
    font-size: 14pt;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
    width: 300pt;
}

.code_piece {
    font-family: monospace;
    padding-left: 4pt;
    padding-right: 4pt;
}


table {
    border-width: 0pt;
}

td {
    vertical-align: top;
    padding: 6pt 12pt 6pt 12pt;
    font-size: 16pt;
    border: 1px solid black;
    width: 505pt;
}

button{
    width: 248pt;
    height: 42pt;
    margin-left:4pt;
    margin-right:4pt;
    font-size: 16pt;
}

u {
    border-bottom: 1px dotted #000;
    text-decoration: none;
    cursor: pointer;
}
    </style>
    <script language="JavaScript">
function next(slides){
    var first_slide = document.getElementById(slides + "_" + 1);
    for(var i = 1; i < 9; ++i)
    {
        var this_slide = document.getElementById(slides + "_" + i);
        var next_slide = document.getElementById(slides + "_" + (i+1));
        if(this_slide)
            if(this_slide.style.display == "block")
                {
                this_slide.style.display = "none";
                if(next_slide)
                    next_slide.style.display = "block";
                else
                    first_slide.style.display = "block";
                return;
                }
    }
}

function draw_results(){
    var d = document.getElementById("results");
    var d_context = d.getContext("2d");
    d_context.font = "16px sans-serif";
    // background
    d_context.fillStyle="#eeeeee";
	d_context.fillRect(0, 0, 700, 500);
	
	var x = 0.0;
	var y = 0.0;
	// static
	x = 0.5;
	y = 499.5;
	d_context.fillStyle="#882200";
	d_context.fillText("0.00 static", x + 4, y - 8);
	d_context.beginPath();
	d_context.strokeStyle="#882200";
	d_context.moveTo(x, y);
	d_context.lineTo(x+99, y);
	d_context.stroke();
	d_context.closePath();
	
	// static A
	x = 100.5;
	y = 499.5 - Math.floor(499 * 0.04 / 2.10);
	d_context.fillStyle="#882200";
	d_context.fillText("0.04 static a", x + 4, y - 8);
	d_context.beginPath();
	d_context.strokeStyle="#882200";
	d_context.moveTo(x, y);
	d_context.lineTo(x+99, y);
	d_context.stroke();
	d_context.closePath();
	
	// static B
	x = 200.5;
	y = 499.5 - Math.floor(499 * 0.10 / 2.10);
	d_context.fillStyle="#882200";
	d_context.fillText("0.10 static b", x + 4, y - 8);
	d_context.beginPath();
	d_context.strokeStyle="#882200";
	d_context.moveTo(x, y);
	d_context.lineTo(x+99, y);
	d_context.stroke();
	d_context.closePath();
	
	// unrolled
	x = 300.5;
	y = 499.5 - Math.floor(499 * 0.10 / 2.10);
	d_context.fillStyle="#882200";
	d_context.fillText("0.10 unrolled", x + 4, y - 8);
	d_context.beginPath();
	d_context.strokeStyle="#882200";
	d_context.moveTo(x, y);
	d_context.lineTo(x+99, y);
	d_context.stroke();
	d_context.closePath();
	
	// triangular
	x = 400.5;
	y = 499.5 - Math.floor(499 * 0.08 / 2.10);
	d_context.fillStyle="#886600";
	d_context.fillText("0.08 triangular", x + 4, y - 8);
	d_context.beginPath();
	d_context.strokeStyle="#886600";
	d_context.moveTo(x, y);
	d_context.lineTo(x+99, y);
	d_context.stroke();
	d_context.closePath();
	
	// lapack
	x = 500.5;
	y = 499.5 - Math.floor(499 * 0.65 / 2.10);
	d_context.fillStyle="#002288";
	d_context.fillText("0.65 LAPACK", x + 4, y - 8);
	d_context.beginPath();
	d_context.strokeStyle="#002288";
	d_context.moveTo(x, y);
	d_context.lineTo(x+99, y);
	d_context.stroke();
	d_context.closePath();
	
	// runtime
	x = 600.5;
	y = 0.05;
	d_context.fillStyle="#AA0011";
	d_context.fillText("2.10 recursive", x - 8, y + 16);
	d_context.beginPath();
	d_context.strokeStyle="#AA0011";
	d_context.moveTo(x, y);
	d_context.lineTo(x+99, y);
	d_context.stroke();
	d_context.closePath();
}

function init_results(){
    draw_results();
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Outperforming LAPACK with C metaprogramming
    </h1>
    <p>
We don't have much tools for metaprogramming in C. We don't have C++' templates or <a href="http://en.cppreference.com/w/cpp/language/constexpr">constexprs</a>, we don't have D's <a href="https://dlang.org/mixin.html">mixins</a>, and we certainly don't have Lisp's and Julia's <a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconicity</a>. All we have in C is the preprocessor and its macroses. We don't have recursive macroses neither as in macroses that recurrently call themselves, nor as in macroses that define macroses. Apparently you can't implement something as awesome as <a href="https://github.com/kw-udon/constexpr-8cc">a compile time compiler</a> with this.
    </p>
    <p>
Yet with preprocessor macroses only you can help your compiler build you the most efficient code. You can make it compute rather elaborate things statically, and you can make it generate zero-overhead code to win quite a lot in performance. I'll show you a pair of tricks that will turn a crude and inefficient algorithm for solving small linear systems into something that can outrun LAPACK.
    </p>
    <h2>
1. Quasi-recursive inlinable functions
    </h2>
    <p>
Function inlining is the basics of compiler optimization. When the body of function is small and the arguments are numerous it makes perfect sense to build the body into the code directly without arranging the conventional data configurating and jumping there and back in the memory. However, there are things that effectively prevent function inlining and one of them is the recursion.
    </p>
    <p>
Ideed, when a function calls itself simply building its body into its body will not work. You can force GCC to do that, but it will only eat up all the memory and hang up.
    </p>
    <p>
The trick is to promice a compiler that the recursion will soon end. You have to unroll a recursive call into a finite number of specific function calls. And you can do this with macroses.
    </p>
    <p>
Yes, the compiler would have to generate extra code on the first steps of compilation, but it will eventually eliminate the dead calls once the variables are proven to be constant during the runtime. GCC is rather good in doing that. In fact, you don't even have to help it with const modifiers. If it can, it will minimize the runtime computation to the very possible extend. 
    </p>
    <p>
In this example we will make in compute a quasi-recursive factorial function statically. Please press the "next step" button to see how the preprocessor and the compiler work together. 
    </p>
    <table><tr>
    <td>
    <pre><span id="slides_recursive_1" style="display:block"><div style="color:#994466"><b>Step 1. C source code</b></div>
<b>#define RECURSIVE(PREFIX, CHUNK1, SUFFIX, END_SUFFIX) \
inline PREFIX##_8 END_SUFFIX \
inline PREFIX##_7 CHUNK1##_8 SUFFIX \
inline PREFIX##_6 CHUNK1##_7 SUFFIX \
inline PREFIX##_5 CHUNK1##_6 SUFFIX \
inline PREFIX##_4 CHUNK1##_5 SUFFIX \
inline PREFIX##_3 CHUNK1##_4 SUFFIX \
inline PREFIX##_2 CHUNK1##_3 SUFFIX \
inline PREFIX##_1 CHUNK1##_2 SUFFIX \
inline PREFIX##_0 CHUNK1##_1 SUFFIX </b>

RECURSIVE(int f, (int i)
  {return i == 1 
    ? 1 
    : i*f, (i-1);},   
  (int i){return 0;})
    
#include "stdio.h"

int main(){
  printf("%d", f_0(4));  
}
   
    </span><span id="slides_recursive_2" style="display:none"><div style="color:#992244"><b>Step 2. C pseudo-code after preprocessing</b></div>
inline int f_8(int i) {return 1;}
inline int f_7(int i) {return i == 1 ? 1 : i*f_8(i-1);}
inline int f_6(int i) {return i == 1 ? 1 : i*f_7(i-1);}
inline int f_5(int i) {return i == 1 ? 1 : i*f_6(i-1);}
inline int f_4(int i) {return i == 1 ? 1 : i*f_5(i-1);}
inline int f_3(int i) {return i == 1 ? 1 : i*f_4(i-1);}
inline int f_2(int i) {return i == 1 ? 1 : i*f_3(i-1);}
inline int f_1(int i) {return i == 1 ? 1 : i*f_2(i-1);}
inline int f_0(int i) {return i == 1 ? 1 : i*f_1(i-1);}

#include "stdio.h"

int main(){
  printf("%d", f_0(4));
}








    </span><span id="slides_recursive_3" style="display:none"><div style="color:#881122"><b>Step 3. Pseudo-code after inlining</b></div>
int main(){
  printf("%d", (int i){
  i == 1 
    ? 1 
    : i*(i == 1 
      ? 1 
      : i*(i == 1 
        ? 1 
        : i*(i == 1 
          ? 1 
          : i*(i == 1 
            ? 1 
            : i*(i == 1 
              ? 1 
              : i*(i == 1 
                ? 1 
                : i*(i == 1 
                  ? 1 
                  : i*1;);););););););}(4));  
}



    </span><span id="slides_recursive_4" style="display:none"><div style="color:#881122"><b>Step 4. Pseudo-code after constant propagation</b></div>









int main(){
  printf("%d", 4*(4-1)*(4-1-1)*1);
}











    </span><span id="slides_recursive_5" style="display:none"><div style="color:#880000"><b>Step 5. Assembly</b></div>
	.cfi_startproc
	leal	4(%esp), %ecx
	.cfi_def_cfa 1, 0
	andl	$-16, %esp
	pushl	-4(%ecx)
	pushl	%ebp
	.cfi_escape 0x10,0x5,0x2,0x75,0
	movl	%esp, %ebp
	pushl	%ecx
	.cfi_escape 0xf,0x3,0x75,0x7c,0x6
	subl	$8, %esp
	<span style="color:#880000"><b>pushl	$24
	pushl	$.LC0
	pushl	$1
	call	__printf_chk</b></span>
	movl	-4(%ebp), %ecx
	.cfi_def_cfa 1, 0
	addl	$16, %esp
	xorl	%eax, %eax
	leave
	.cfi_restore 5
	leal	-4(%ecx), %esp
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc</span></pre>
    </td>
    </td></tr></table>
    <p style="text-align:right">
    <button type="button" onclick="next('slides_recursive')">Next step</button>
    </p>
    <p>
Of course, this hack has its limits. For instance, when you have to do several calls from a quasi-recursive function, the compiler would have to build not a list of bodies, but a whole tree. This slows down compilation enormously. It takes noticeable time to compile 4-depth 4-branches quasi-recursion on a modern desktop. 6-depth 6-branches might turn it catatonic.
    </p>
    <h2>
2. Forced loop unroll
    </h2>
    <p>
Compilers are usually good in unrolling loops. In fact, they are usually better than us, regular people. The good side of the loop unrolling is that it once again loses the overhead on index counting and comparison. The bad side is bigger code. Sometimes we would win more from a small loop running completely in instruction cahce than from a huge unrolled loop that has to be read from uncached memory.
    </p>
    <p>
Sometimes however we know better than the compiler. We know that the loop is short, and finite, and even if it has inner loops it should still be eligeable for unrolling. Here is the trick that will no options to the C compiler.
    </p>
    <table><tr>
    <td>
    <pre><span id="unroll_1" style="display:block"><div style="color:#994466"><b>Step 1. C source code</b></div> 
<b>#define LOOP_TO_0(ID, N, BODY) {int ID; switch(N){\
case 4: ID=4;{BODY};\
case 3: ID=3;{BODY};\
case 2: ID=2;{BODY};\
case 1: ID=1;{BODY};\
case 0: ID=0;{BODY};\
}}</b>

#define STATIC_SORT_INT(a) \
  LOOP_TO_0(i, sizeof(a)/sizeof(a[0]) - 2, LOOP_TO_0(j, i, \
    int k = i-j; \
    int s = a[k]+a[k+1]; \
    int d = abs(a[k]-a[k+1]); \
    a[k] = (s-d)/2; \
    a[k+1] = (s+d)/2; \
  ));

#include "stdio.h"

int main(){
  int a[4] = {1, 5, 2, 4};
  STATIC_SORT_INT(a);
  printf("%d %d %d %d\n", a[0], a[1], a[2], a[3]);
}



    </span><span id="unroll_2" style="display:none"><div style="color:#992244"><b>Step 2. C pseudo-code after preprocessing</b></div> 
#include "stdio.h"

int main(){
  int a[4] = {1, 5, 2, 4};
  int i; switch(2){
    case 4: i=4; {
    int j; switch(4){
      case 4: j=4; int k=i-j; int s=a[k]+a[k+1]; 
        int d=abs(a[k]-a[k+1]); a[k] = (s-d)/2; a[k+1] = (s+d)/2;
      case 3: j=3; int k=i-j; int s=a[k]+a[k+1]; 
        int d=abs(a[k]-a[k+1]); a[k] = (s-d)/2; a[k+1] = (s+d)/2;
      case 2: j=2; int k=i-j; int s=a[k]+a[k+1]; 
        int d=abs(a[k]-a[k+1]); a[k] = (s-d)/2; a[k+1] = (s+d)/2;
      case 1: j=1; int k=i-j; int s=a[k]+a[k+1]; 
        int d=abs(a[k]-a[k+1]); a[k] = (s-d)/2; a[k+1] = (s+d)/2;
      case 0: j=0; int k=i-j; int s=a[k]+a[k+1]; 
        int d=abs(a[k]-a[k+1]); a[k] = (s-d)/2; a[k+1] = (s+d)/2;
      }
      case 3: i=3; {
      ...
      }
    ...
    }
  }
  printf("%d %d %d %d\n", a[0], a[1], a[2], a[3]);
}

    </span><span id="unroll_3" style="display:none"><div style="color:#992244"><b>Step 3. C pseudo-code after dead cases elimination</b></div>  
#include "stdio.h"

int main(){
  int a[4] = {1, 5, 2, 4};
  int i; 
  i = 2;
  j = 2; int k=i-j; int s=a[k]+a[k+1]; int d=abs(a[k]-a[k+1]);
    a[k] = (s-d)/2; a[k+1] = (s+d)/2;
  j = 1; int k=i-j; int s=a[k]+a[k+1]; int d=abs(a[k]-a[k+1]);
    a[k] = (s-d)/2; a[k+1] = (s+d)/2;
  j = 0; int k=i-j; int s=a[k]+a[k+1]; int d=abs(a[k]-a[k+1]);
    a[k] = (s-d)/2; a[k+1] = (s+d)/2;
  i = 1;
   j = 1; int k=i-j; int s=a[k]+a[k+1]; int d=abs(a[k]-a[k+1]);
    a[k] = (s-d)/2; a[k+1] = (s+d)/2;
  j = 0; int k=i-j; int s=a[k]+a[k+1]; int d=abs(a[k]-a[k+1]);
    a[k] = (s-d)/2; a[k+1] = (s+d)/2;
  i = 0;   
  j = 0; int k=i-j; int s=a[k]+a[k+1]; int d=abs(a[k]-a[k+1]);
    a[k] = (s-d)/2; a[k+1] = (s+d)/2;
  }
  printf("%d %d %d %d\n", a[0], a[1], a[2], a[3]);
}




    </span><span id="unroll_4" style="display:none"><div style="color:#881122"><b>Step 4. Pseudo-code after constant propagation</b></div> 










#include "stdio.h"

int main(){
  <span style="color:#881122"><b>printf("%d %d %d %d\n", 1, 2, 4, 5);</b></span>
}












    </span><span id="unroll_5" style="display:none"><div style="color:#880000"><b>Step 5. Assembly</b></div>
	.cfi_startproc
	leal	4(%esp), %ecx
	.cfi_def_cfa 1, 0
	andl	$-16, %esp
	pushl	-4(%ecx)
	pushl	%ebp
	.cfi_escape 0x10,0x5,0x2,0x75,0
	movl	%esp, %ebp
	pushl	%ecx
	.cfi_escape 0xf,0x3,0x75,0x7c,0x6
	subl	$12, %esp
<span style="color:#880000"><b>	pushl	$5
	pushl	$4
	pushl	$2
	pushl	$1
	pushl	$.LC0
	pushl	$1
	call	__printf_chk</b></span>
	movl	-4(%ebp), %ecx
	.cfi_def_cfa 1, 0
	addl	$32, %esp
	xorl	%eax, %eax
	leave
	.cfi_restore 5
	leal	-4(%ecx), %esp
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc</span></pre>
    </td>
    </td></tr></table>
    <p style="text-align:right">
    <button type="button" onclick="next('unroll')">Next step</button>
    </p>
    <p>
Technically, one can do the very same hack via the inlined pseudo-recursion from before. But this compiles faster and it has shown itself easier to debug. 
    </p>
    <h2>
Racing LAPACK
    </h2>
    <p>
... 
    </p> 
    <table><tr>
    <td>
    <pre><span id="slides_1_1" style="display:block"> 
1. ...
    </span><span id="slides_1_2" style="display:none"> 
2. ...
    </span><span id="slides_1_3" style="display:none"> 
3. ...
    </span></pre>
    </td>
    </td></tr></table>
    <p style="text-align:right">
    <button type="button" onclick="next('slides_1')">Next step</button>
    </p>
    <p>
...
    </p>
    <canvas id="results" width=700 height=500></canvas>
    <script language="JavaScript">
    init_results();
    </script>
    <p> 
    <p>
...
    </p>

    <p class="footer">
    There are more words and buttons on <a href="index.html">wordsandbuttons.online</a>.<br>
    Also please follow us on <a href="https://twitter.com/wordsandbuttons">Twitter</a>.
    </p>
    </center>
  </body>
</html>
