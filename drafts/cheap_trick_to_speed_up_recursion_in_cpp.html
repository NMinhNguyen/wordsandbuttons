<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cheap trick to speed up recursion in C++</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
    width: 300pt;
}

.code_piece {
    font-family: monospace;
    padding-left: 4pt;
    padding-right: 4pt;
}


table {
    border-width: 0pt;
}

td {
    vertical-align: top;
    padding: 6pt 12pt 6pt 12pt;
    font-size: 16pt;
    border: 1px solid black;
    width: 600pt;
}

button{
    width: 248pt;
    height: 42pt;
    margin-left:4pt;
    margin-right:4pt;
    font-size: 16pt;
}

u {
    border-bottom: 1px dotted #000;
    text-decoration: none;
    cursor: pointer;
}
    </style>
    <script language="JavaScript">
function next(slides){
    // show the next slide
    var first_slide = document.getElementById(slides + "_" + 1);
    for(var i = 1; i < 9; ++i)
    {
        var this_slide = document.getElementById(slides + "_" + i);
        var next_slide = document.getElementById(slides + "_" + (i+1));
        if(this_slide)
            if(this_slide.style.display == "block")
                {
                this_slide.style.display = "none";
                if(next_slide)
                    next_slide.style.display = "block";
                else
                    first_slide.style.display = "block";
                break;
                }
    }
    // name the button
    var button = document.getElementById(slides + "_button")
    for(var i = 1; i < 9; ++i)
    {
        var this_slide = document.getElementById(slides + "_" + i);
        var next_slide = document.getElementById(slides + "_" + (i+1));
        if (this_slide && !next_slide && this_slide.style.display == "block") {
            button.innerHTML = "Back to the 1-st slide";
            break;
        }
        else
            button.innerHTML = "Next slide";
    }
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Cheap trick to speed up recursion in C++
    </h1>
    <p>
<b>Disclaimer.</b> The trick I am about to show is not an example of good engineering. It depends on implementation specific optimization and as such is unreliable. In some contexts it may give you some noticeable performance gains, but in other it may even lead to performance degradation. 
    </p>
    <p>
However, quoting Donald Knuth, “in established engineering disciplines a 12% improvement, easily obtained, is never considered marginal; and I believe the same viewpoint should prevail in software engineering.” 
    </p>
    <h2>
Tail call optimization vs. no tail call optimization
    </h2>
    <p>
C++ has tail call optimiztion. It's when a recursive function that ends with self-call is replaced with the simple loop. Let me show you how this works.
    </p>
    <table><tr>
    <td>
    <pre><span id="slides_tco_1" style="display:block"><div style="color:#994466"><b>1. C++ source code</b></div>
int sum_of_first(int n) {
    return (n == 1) ? 1 : n + sum_of_first(n-1);
}

int main() {
    return sum_of_first(65536);
}












</span><span id="slides_tco_2" style="display:none"><div style="color:#992244"><b>2. Disassembly</b></div>
sum_of_first(int):
        cmp     edi, 1
        je      .L4
        xor     eax, eax
.L3:
        add     eax, edi
        sub     edi, 1
        cmp     edi, 1
        jne     .L3
        add     eax, 1
        ret
.L4:
        mov     eax, 1
        ret
        
        
        
        
        
</span><span id="slides_tco_3" style="display:none"><div style="color:#770022"><b>3. Valgrind measurements</b></div>
==10788== Command: ./tco
==10788== 
--10788-- warning: L3 cache found, using its data for the LL simulation.
==10788== 
==10788== I   refs:      353,280
==10788== I1  misses:        754
==10788== LLi misses:        745
==10788== I1  miss rate:    0.21%
==10788== LLi miss rate:    0.21%
==10788== 
==10788== D   refs:       34,378  (23,753 rd   + 10,625 wr)
==10788== D1  misses:      1,710  ( 1,215 rd   +    495 wr)
==10788== LLd misses:      1,526  ( 1,053 rd   +    473 wr)
==10788== D1  miss rate:     5.0% (   5.1%     +    4.7%  )
==10788== LLd miss rate:     4.4% (   4.4%     +    4.5%  )
==10788== 
==10788== LL refs:         2,464  ( 1,969 rd   +    495 wr)
==10788== LL misses:       2,271  ( 1,798 rd   +    473 wr)
==10788== LL miss rate:      0.6% (   0.5%     +    4.5%  )</span></pre></td>
    </td></tr></table>
    <p style="text-align:right">
    <button type="button" id="slides_tco_button" onclick="next('slides_tco')">Next step</button>
    </p>
    <p>
From disassembly you can see that there is no actual self call in the “recursive” <i>sum_of_first</i> function. From the valgrind report you can also see why this is important. 
    </p>
    <p>
Normally, every time you call a function, you have to store its return adress in a stack. Even if the address is the same. This means that if you call your function 65536 times in a nested way, you will be writing the same address 65536 times only to read it all back on returns. It is pure overhead. But if the self call is a tail call, meaning that all the nested calls will eventually return to the same place, you don't have to do the calls at all. Simple loop will be enough.
    </p>
    <p>
Compilers can do that for you. They rewrite your code to minimize overhead whenever they can. But what if they can't?
    </p>
    <table><tr>
    <td>
    <pre><span id="slides_no_tco_1" style="display:block"><div style="color:#994466"><b>1. C++ source code</b></div>
int sum_of_first(int n) {
    if(n == 0)
        return 0;
    auto temp_sum = sum_of_first(n-1);
    return n == 1 ? 1 : (temp_sum + n);
}

int main() {
    return sum_of_first(65536);
}









</span><span id="slides_no_tco_2" style="display:none"><div style="color:#992244"><b>2. Disassembly</b></div>
sum_of_first(int):
        xor     eax, eax
        test    edi, edi
        jne     .L10
        ret
.L10:
        push    rbx
        mov     ebx, edi
        lea     edi, [rdi-1]
        call    sum_of_first(int)
        mov     edx, 1
        add     eax, ebx
        cmp     ebx, 1
        cmove   eax, edx
        pop     rbx
        ret
        
        
             
</span><span id="slides_no_tco_3" style="display:none"><div style="color:#770022"><b>3. Valgrind measurements</b></div>
==10789== Command: ./no_tco
==10789== 
--10789-- warning: L3 cache found, using its data for the LL simulation.
==10789== 
==10789== I   refs:      943,105
==10789== I1  misses:        754
==10789== LLi misses:        745
==10789== I1  miss rate:    0.08%
==10789== LLi miss rate:    0.08%
==10789== 
==10789== D   refs:      296,520  (154,824 rd   + 141,696 wr)
==10789== D1  misses:     33,991  ( 17,129 rd   +  16,862 wr)
==10789== LLd misses:     17,838  (  1,053 rd   +  16,785 wr)
==10789== D1  miss rate:    11.5% (   11.1%     +    11.9%  )
==10789== LLd miss rate:     6.0% (    0.7%     +    11.8%  )
==10789== 
==10789== LL refs:        34,745  ( 17,883 rd   +  16,862 wr)
==10789== LL misses:      18,583  (  1,798 rd   +  16,785 wr)
==10789== LL miss rate:      1.5% (    0.2%     +    11.8%  )</span></pre></td>
    </td></tr></table>
    <p style="text-align:right">
    <button type="button" id="slides_no_tco_button" onclick="next('slides_no_tco')">Next step</button>
    </p>
    <p>
When the self-call is not a tail call, and can't even be made a tail call, the compiler skips the TCO optimization. And yes, you get all the overheads: all the amount of needless reads and writes.
    </p>
    <h2>
    </h2>



    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
        <a href="index.html"><img src="favicon.ico"></a> 
    </td>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        &nbsp;&larr; there's more.
    </td>
    <td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
        + 
        <a href="https://github.com/akalenuk/wordsandbuttons">Github</a> & 
        <a href="https://twitter.com/wordsandbuttons">Twitter</a> & 
        <a href="https://news.ycombinator.com/from?site=wordsandbuttons.online">Hacker News</a>
    </td>
    </tr>
    </table>
    </center>
  </body>
</html>
