<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Visual mnemonics for dot and cross vector products</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
    width: 300pt;
}

table {
    border-width: 0pt;
}

td {
    vertical-align: top;
    padding: 6pt 12pt 6pt 12pt;
    font-size: 16pt;
    border: 1px solid black;
    width: 600pt;
}

button{
    width: 248pt;
    height: 42pt;
    margin-left:4pt;
    margin-right:4pt;
    font-size: 16pt;
}

u {
    border-bottom: 1px dotted #000;
    text-decoration: none;
    cursor: pointer;
}
    </style>
    <script language="JavaScript">
// client
var w = 640.0;
var h = 640.0;

// visible region for dot
var dot_x_min = -1.0;
var dot_y_min = -1.0;
var dot_x_max = 7.0;
var dot_y_max = 7.0;

var dot_client_x_center = w*(0-dot_x_min)/(dot_x_max-dot_x_min);
var dot_client_x_step = (w/(dot_x_max-dot_x_min));

var dot_client_y_center = h - h*(0-dot_y_min)/(dot_y_max-dot_y_min);
var dot_client_y_step = (h/(dot_y_max-dot_y_min));


function dot_client_to_x(client_x){
    return (client_x - dot_client_x_center) / dot_client_x_step;
}

function dot_client_to_y(client_y){
    return (dot_client_y_center - client_y) / dot_client_y_step;
}

function dot_x_to_client(x){
    return x * dot_client_x_step + dot_client_x_center;
}

function dot_y_to_client(y){
    return dot_client_y_center - y * dot_client_y_step;
}

function draw_dot_grid_on(context){
    // grid
    context.beginPath();
    context.moveTo(0, dot_client_y_center);
    context.lineTo(w, dot_client_y_center);
    context.lineTo(w - 12, dot_client_y_center - 5);
    context.moveTo(w, dot_client_y_center);
    context.lineTo(w - 12, dot_client_y_center + 5);
    context.moveTo(dot_client_x_center, h);
    context.lineTo(dot_client_x_center, 0);
    context.lineTo(dot_client_x_center - 5, 12);
    context.moveTo(dot_client_x_center, 0);
    context.lineTo(dot_client_x_center + 5, 12);
    context.fillStyle="#000000";
    for(var i = dot_x_min + 1; i <= dot_x_max - 1; i++){
        if(i != 0) {
            context.moveTo(dot_client_x_center + i*dot_client_x_step, dot_client_y_center);
            context.lineTo(dot_client_x_center + i*dot_client_x_step, dot_client_y_center - 5);
            context.fillText(i, dot_client_x_center + i*dot_client_x_step + 4, dot_client_y_center + 16);
        }
    }
    for(var i = dot_y_min + 1; i <= dot_y_max - 1; i++){
        if(i != 0) {
            context.moveTo(dot_client_x_center, dot_client_y_center - i*dot_client_y_step);
            context.lineTo(dot_client_x_center + 5, dot_client_y_center - i*dot_client_y_step);
        }
        context.fillText(i, dot_client_x_center + 5, dot_client_y_center - i*dot_client_y_step + 16);
    }
    context.strokeStyle = "#000000";
    context.stroke();
    context.closePath();
}

// visible region for cross
var cross_x_min = -0.25;
var cross_y_min = -0.25;
var cross_x_max = 1.25;
var cross_y_max = 1.25;

var cross_client_x_center = w*(0-cross_x_min)/(cross_x_max-cross_x_min);
var cross_client_x_step = (w/(cross_x_max-cross_x_min));

var cross_client_y_center = h - h*(0-cross_y_min)/(cross_y_max-cross_y_min);
var cross_client_y_step = (h/(cross_y_max-cross_y_min));

function cross_client_to_x(client_x){
    return (client_x - cross_client_x_center) / cross_client_x_step;
}

function cross_client_to_y(client_y){
    return (cross_client_y_center - client_y) / cross_client_y_step;
}

function cross_x_to_client(x){
    return x * cross_client_x_step + cross_client_x_center;
}

function cross_y_to_client(y){
    return cross_client_y_center - y * cross_client_y_step;
}

function draw_cross_grid_on(context){
    // grid
    context.beginPath();
    context.moveTo(0, cross_client_y_center);
    context.lineTo(w, cross_client_y_center);
    context.lineTo(w - 12, cross_client_y_center - 5);
    context.moveTo(w, cross_client_y_center);
    context.lineTo(w - 12, cross_client_y_center + 5);
    context.moveTo(cross_client_x_center, h);
    context.lineTo(cross_client_x_center, 0);
    context.lineTo(cross_client_x_center - 5, 12);
    context.moveTo(cross_client_x_center, 0);
    context.lineTo(cross_client_x_center + 5, 12);
    context.fillStyle="#000000";
    for(var i = cross_x_min + 0.25; i <= cross_x_max; i++){
        if(i != 0) {
            context.moveTo(cross_client_x_center + i*cross_client_x_step, cross_client_y_center);
            context.lineTo(cross_client_x_center + i*cross_client_x_step, cross_client_y_center - 5);
            context.fillText(i, cross_client_x_center + i*cross_client_x_step + 4, cross_client_y_center + 16);
        }
    }
    for(var i = cross_y_min + 0.25; i <= cross_y_max; i++){
        if(i != 0) {
            context.moveTo(cross_client_x_center, cross_client_y_center - i*cross_client_y_step);
            context.lineTo(cross_client_x_center + 5, cross_client_y_center - i*cross_client_y_step);
        }
        context.fillText(i, cross_client_x_center + 5, cross_client_y_center - i*cross_client_y_step + 16);
    }
    context.strokeStyle = "#000000";
    context.stroke();
    context.closePath();
}


// helper
function draw_arrow(context, x1, y1, x2, y2, color) {
    var d = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.moveTo(x2 - (y2 - y1) * 6 / d - (x2 - x1) * 16 / d, y2 - (y2 - y1) * 16 / d + (x2 - x1) * 6 / d);    
    context.lineTo(x2, y2);
    context.moveTo(x2 + (y2 - y1) * 6 / d - (x2 - x1) * 16 / d, y2 - (y2 - y1) * 16 / d - (x2 - x1) * 6 / d);    
    context.lineTo(x2, y2);    
    
    
    context.strokeStyle = color;
    context.stroke();
    context.closePath();    
}

// visuals

// earth, sun, vector
var dot_x = [1, 4, 1];
var dot_y = [1, 4, 3];


var cross_x = [0.5, 0.75, 1];
var cross_y = [0.5, 0.75, 1];

function nearest_in(xs, ys, x, y) {
    var nearest_i = 0;
    for(var i = 1; i < dot_x.length; ++i)
        if((Math.pow(x - xs[i], 2) + Math.pow(y - ys[i], 2)) < (Math.pow(x - xs[nearest_i], 2) + Math.pow(y - ys[nearest_i], 2)))
            nearest_i = i;
    return nearest_i;
}


function init_dot(){
    var dot = document.getElementById("dot");
    var canvas_rect = dot.getBoundingClientRect();
    draw_dot(0, 0, false);

    dot.addEventListener('mousemove', function(e){
        var canvas_rect = dot.getBoundingClientRect();
        draw_dot(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1){          
            var x = dot_client_to_x(e.clientX - canvas_rect.left);
            var y = dot_client_to_y(e.clientY - canvas_rect.top);
            var dot_i = nearest_in(dot_x, dot_y, x, y);
            if(dot_i == 0) {
                var dx = dot_x[2] - dot_x[0];
                var dy = dot_y[2] - dot_y[0];
                dot_x[2] = x + dx;
                dot_y[2] = y + dy;
                dot_x[dot_i] = x;
                dot_y[dot_i] = y;
            } else if(dot_i == 1) {
                dot_x[dot_i] = x;
                dot_y[dot_i] = y;            
            } else if(dot_i == 2) {
                var dx = x - dot_x[0];
                var dy = y - dot_y[0];
                var dn = Math.sqrt(dx*dx + dy*dy);
                dot_x[dot_i] = dot_x[0] + 2 * dx / dn;
                dot_y[dot_i] = dot_y[0] + 2 * dy / dn;
            }

            draw_dot(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
        }
    }, false);

    dot.addEventListener('mousedown', function(e){
        var canvas_rect = dot.getBoundingClientRect();
        var x = dot_client_to_x(e.clientX - canvas_rect.left);
        var y = dot_client_to_y(e.clientY - canvas_rect.top);
        var dot_i = nearest_in(dot_x, dot_y, x, y);
        if(dot_i == 0) {
            var dx = dot_x[2] - dot_x[0];
            var dy = dot_y[2] - dot_y[0];
            dot_x[2] = x + dx;
            dot_y[2] = y + dy;
            dot_x[dot_i] = x;
            dot_y[dot_i] = y;
        } else if(dot_i == 1) {
            dot_x[dot_i] = x;
            dot_y[dot_i] = y;            
        } else if(dot_i == 2) {
            var dx = x - dot_x[0];
            var dy = y - dot_y[0];
            var dn = Math.sqrt(dx*dx + dy*dy);
            dot_x[dot_i] = dot_x[0] + 2 * dx / dn;
            dot_y[dot_i] = dot_y[0] + 2 * dy / dn;
        }
        draw_dot(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
    }, false);

    dot.addEventListener('mouseleave', function(e){
        draw_dot(0, 0, false);
    }, false);
}

function draw_dot(client_x, client_y, do_guides){
    var dot = document.getElementById("dot");
    var context = dot.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // "earth"
    var ew = 2 * dot_client_x_step;
    var eh = 2 * dot_client_y_step;
    var ej = dot_x_to_client(dot_x[0]) - dot_client_x_step;
    var ei = dot_y_to_client(dot_y[0]) - dot_client_y_step;
    
    var pixel_field = context.createImageData(ew, eh);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        var on_canvas_i = Math.floor(Math.floor(i / 4) / ew) + ei;
        var on_canvas_j = Math.floor(i / 4) % ew + ej;
        var x = dot_client_to_x(on_canvas_j);
        var y = dot_client_to_y(on_canvas_i);
        var ex = x - dot_x[0];
        var ey = y - dot_y[0];
        
        if(ex * ex + ey * ey > 1.) {
            pixel_field.data[i + 0] = 0xEE;
            pixel_field.data[i + 1] = 0xEE;
            pixel_field.data[i + 2] = 0xEE;
            pixel_field.data[i + 3] = 0xFF;
        } else {
            var ez = 1 - ex*ex - ey*ey;
            
            var dx = dot_x[1] - dot_x[0];
            var dy = dot_y[1] - dot_y[0];
            var dz = -ez;
            var dn = Math.pow(dx * dx + dy * dy + dz * dz, 0.5);
            
            var light = ex * dx / dn + ey * dy / dn + ez * dz / dn;
            if(light < 0)
                light = 0;
            // 2751b3
            pixel_field.data[i + 0] = 0x27 + (0xDD - 0x27) * light;
            pixel_field.data[i + 1] = 0x51 + (0xDD - 0x51) * light;
            pixel_field.data[i + 2] = 0xB3 + (0xDD - 0xB3) * light;
            pixel_field.data[i + 3] = 0xFF;
        }        
    }
    context.putImageData(pixel_field, ej-0.5, ei-0.5);
    
    draw_arrow(context, 
        dot_x_to_client(dot_x[0] / 2 + dot_x[2] / 2), dot_y_to_client(dot_y[0] / 2 + dot_y[2] / 2), 
        dot_x_to_client(dot_x[2]), dot_y_to_client(dot_y[2]), "#2751b3");
        
    var to_sun_x = dot_x[1] - (dot_x[0] / 2 + dot_x[2] / 2);
    var to_sun_y = dot_y[1] - (dot_y[0] / 2 + dot_y[2] / 2);
    var to_sun_d = Math.sqrt(to_sun_x * to_sun_x + to_sun_y * to_sun_y);
    draw_arrow(context, 
        dot_x_to_client(dot_x[0] / 2 + dot_x[2] / 2), dot_y_to_client(dot_y[0] / 2 + dot_y[2] / 2),
        dot_x_to_client(dot_x[0] / 2 + dot_x[2] / 2 + to_sun_x / to_sun_d), dot_y_to_client(dot_y[0] / 2 + dot_y[2] / 2 + to_sun_y / to_sun_d), "#b3aa27");

    // sun
    context.beginPath();    
    for(var i = 0; i < 11; ++i) {
        var dx = 5 * Math.sin(2*Math.PI * i / 11);
        var dy = 5 * Math.cos(2*Math.PI * i / 11);
        context.moveTo(dot_x_to_client(dot_x[1]) + dx, dot_y_to_client(dot_y[1]) + dy);
        context.lineTo(dot_x_to_client(dot_x[1]), dot_y_to_client(dot_y[1]));
    }
    context.strokeStyle = "#b3aa27";
    context.stroke();
    context.closePath(); 

    // text
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.font = "16px sans-serif";
    context.fillStyle = "#b3273c";
    var label_x = dot_x_to_client(3 * dot_x[0] / 4 + dot_x[2] / 4);
    var label_y = dot_y_to_client(3 * dot_y[0] / 4 + dot_y[2] / 4);
    var normal_x = (dot_x[2] - dot_x[0]) / 2;
    var normal_y = (dot_y[2] - dot_y[0]) / 2;
    var dot_product = normal_x * to_sun_x / to_sun_d + normal_y * to_sun_y / to_sun_d;
    context.fillText(dot_product.toFixed(2), label_x, label_y);

    // grid
    draw_dot_grid_on(context);
}

function init_cross(){
    var cross = document.getElementById("cross");
    var canvas_rect = cross.getBoundingClientRect();
    draw_cross(0, 0, false);

    cross.addEventListener('mousemove', function(e){
        var canvas_rect = cross.getBoundingClientRect();
        draw_cross(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1){
            var x = cross_client_to_x(e.clientX - canvas_rect.left);
            var y = cross_client_to_y(e.clientY - canvas_rect.top);
            var cross_i = nearest_in(cross_x, cross_y, x, y);
            cross_x[cross_i] = x;
            cross_y[cross_i] = y;
            draw_cross(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
        }
    }, false);

    cross.addEventListener('mousedown', function(e){
        var canvas_rect = cross.getBoundingClientRect();
        var x = cross_client_to_x(e.clientX - canvas_rect.left);
        var y = cross_client_to_y(e.clientY - canvas_rect.top);
        var cross_i = nearest_in(cross_x, cross_y, x, y);
        cross_x[cross_i] = x;
        cross_y[cross_i] = y;
        draw_cross(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
    }, false);

    cross.addEventListener('mouseleave', function(e){
        draw_cross(0, 0, false);
    }, false);
}

function draw_cross(client_x, client_y, do_guides){
    var cross = document.getElementById("cross");
    var context = cross.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // grid
    draw_cross_grid_on(context);

    // points
    for(var i = 0; i < cross_x.length; ++i) {
        context.fillStyle="#008800";
        context.beginPath();
        context.arc(cross_x_to_client(cross_x[i]), cross_y_to_client(cross_y[i]), 2, 0, 2*Math.PI);
        context.fill();
        context.closePath();
    }
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Visual mnemonics for dot and cross vector products
    </h1>
    <p>
...
    </p>
    <canvas id="dot" width=640 height=640></canvas>
    <p>
...
    </p>
    <canvas id="cross" width=640 height=640></canvas>
    <p>
...
    </p>
    <script language="JavaScript">
    init_dot();
    init_cross();
    </script>    


    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
        <a href="index.html"><img src="favicon.ico"></a>
    </td>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        &nbsp;&larr; there's more.
    </td>
    <td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
        +
        <a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
        <a href="https://twitter.com/wordsandbuttons">Twitter</a> &
        <a href="https://news.ycombinator.com/from?site=wordsandbuttons.online">Hacker News</a>
    </td>
    </tr>
    </table>
    </center>
  </body>
</html>
