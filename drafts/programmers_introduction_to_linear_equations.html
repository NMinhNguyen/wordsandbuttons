<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Вступ до лінійних рявнянь для програмістів</title>
    <meta name="keywords" content="programming,linear equations,linear systems,tutorial,introduction,learning">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.results {
    font-family: sans-serif;
    font-size: 14pt;
    width: 505pt;
    text-align: left;
}

.comment {
    font-size: 12pt;
    text-align:center;
    font-family: sans-serif;
    padding-bottom: 24pt;
}

.formula {
    font-family: monospace;
    font-size: 16pt;
    font-style: italic;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table.footer {
    padding: 64pt 0pt 32pt 0pt;
    background-color: transparent;
    width: 505pt;
}

td.footer {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: normal;
    padding: 0;
    margin: 0;
    border: 0;
}

li {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
    padding-bottom: 6pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
}

table {
    border-width: 0pt;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    font-family: monospace;
    text-align: center;
}

table td {
    padding: 0pt 3pt 0pt 3pt;
    margin: 0 0 0 0;
    border-width: 0pt;
}

.brackets {
    font-size:32pt;
    padding-bottom:2pt;
    font-family: sans-serif;
    font-weight: 100;
    font-style: normal;
}

input[type="text"] {
    width: 20pt;
    height: 22pt;
    margin: 0;
    padding-left: 1pt;
    font-size: 14pt;
}

button {
    width: 108pt;
    height: 28pt;
    margin-left:4pt;
    margin-right:4pt;
    font-size: 16pt;
}

.incdec {
    width: 22pt;
    height: 22pt;
    margin-left: 1pt;
    margin-right: 1pt;
    font-size: 14pt;
}
    </style>
    <script language="JavaScript">
// quest count
var quests = [0, 0, 0, 0, 0, 0, 0, 0, 0];
var hidden_quests = [0, 0, 0];

// client
var w = 640.0;
var h = 512.0;

// visible region
var x_min = -1.0;
var y_min = -1.0;
var x_max = 5.0;
var y_max = 4.0;

// colors
var line_colors = ["#d64562", "#457fd6", "#62d645"];
var fill_colors = ["#e3bfc3", "#bfc7e3", "#c4e3bf"];


var client_x_center = w*(0-x_min)/(x_max-x_min);
var client_x_step = (w/(x_max-x_min));

var client_y_center = h - h*(0-y_min)/(y_max-y_min);
var client_y_step = (h/(y_max-y_min));

function client_to_x(client_x){
    return (client_x - client_x_center) / client_x_step;
}

function client_to_y(client_y){
    return (client_y_center - client_y) / client_y_step;
}

function x_to_client(x){
    return x * client_x_step + client_x_center;
}

function y_to_client(y){
    return client_y_center - y * client_y_step;
}

function draw_grid_on(context){
    context.font = "16px sans-serif";
    // axes
    context.beginPath();
    context.moveTo(0, client_y_center);
    context.lineTo(w, client_y_center);
    context.lineTo(w - 12, client_y_center - 5);
    context.moveTo(w, client_y_center);
    context.lineTo(w - 12, client_y_center + 5);
    context.moveTo(client_x_center, h);
    context.lineTo(client_x_center, 0);
    context.lineTo(client_x_center - 5, 12);
    context.moveTo(client_x_center, 0);
    context.lineTo(client_x_center + 5, 12);
    context.fillStyle="#000000";
    // numbers
    for(var i = x_min + 1; i <= x_max - 1; i++){
        context.moveTo(client_x_center + i*client_x_step, client_y_center);
        context.lineTo(client_x_center + i*client_x_step, client_y_center - 5);
        context.fillText(i, client_x_center + i*client_x_step + 4, client_y_center + 16);
    }
    for(var i = y_min + 1; i <= y_max - 1; i++){
        context.moveTo(client_x_center, client_y_center - i*client_y_step);
        context.lineTo(client_x_center + 5, client_y_center - i*client_y_step);
        context.fillText(i, client_x_center + 5, client_y_center - i*client_y_step + 16);
    }
    // letters
    context.fillText("X1", client_x_center + x_max*client_x_step - 24, client_y_center - 16);
    context.fillText("X2", client_x_center - 30, client_y_center - y_max*client_y_step + 16);

    context.strokeStyle="#000000";
    context.stroke();
    context.closePath();
}

function dot_of(a11, a12, a21, a22){
    return a11*a21 + a12*a22;
}

function length_of(a1, a2){
    return Math.sqrt(dot_of(a1, a2, a1, a2));
}

function projected_x(x, y, a1, a2, b){
    return x + a1 * (b - dot_of(x, y, a1, a2)) / dot_of(a1, a2, a1, a2);
}

function projected_y(x, y, a1, a2, b){
    return y + a2 * (b - dot_of(x, y, a1, a2)) / dot_of(a1, a2, a1, a2);
}

function get_points_on_the_ends(a1, a2, b) {    // I need a beter algo (classifier) for this
    var xys = []

    if(a1 == 0.0)
        return [[x_min, b / a2], [x_max, b / a2]];
    if(a2 == 0.0)
        return [[b / a1, y_min], [b / a1, y_max]];

    var x_in_y_min = (b - a2 * y_min) / a1;
    if(x_in_y_min >= x_min && x_in_y_min < x_max)
        xys.push([x_in_y_min, y_min]);

    var x_in_y_max = (b - a2 * y_max) / a1;
    if(x_in_y_max >= x_min && x_in_y_max < x_max)
        xys.push([x_in_y_max, y_max]);

    var y_in_x_min = (b - a1 * x_min) / a2;
    if(y_in_x_min >= y_min && y_in_x_min < y_max)
        xys.push([x_min, y_in_x_min]);

    var y_in_x_max = (b - a1 * x_max) / a2;
    if(y_in_x_max >= y_min && y_in_x_max < y_max)
        xys.push([x_max, y_in_x_max]);

    if(xys.length < 2)
        return get_points_on_the_ends(a1 + 0.001, a2 - 0.001, b + 0.001);
    return xys;
}

function equation_for_two_points(x1, y1, x2, y2) {
    return [1.0, (-x1 + x2)/(y1 - y2), (-x1*y2 + x2*y1)/(y1 - y2)];
}

function new_equation_for_one_point(a1, a2, b, x, y) {
    var xys = get_points_on_the_ends(a1, a2, b);
    if(length_of(x - xys[0][0], y - xys[0][1]) > length_of(x - xys[1][0], y - xys[1][1])) {
        return equation_for_two_points(x, y, xys[0][0], xys[0][1]);
    } else {
        return equation_for_two_points(x, y, xys[1][0], xys[1][1]);
    }
}

function solve_2(a11, a12, b1, a21, a22, b2) {
    sx = (-a12*b2 + a22*b1)/(a11*a22 - a12*a21);
    sy = (a11*b2 - a21*b1)/(a11*a22 - a12*a21);
    return [sx, sy];
}


//////
/// simple plots
function find_nearest_eqution_id(name, client_x, client_y) {
    var x = client_to_x(client_x);
    var y = client_to_y(client_y);
    var closest_eq_i = 0;
    var eq0 = eval(name + "_eq_1");
    var x0 = projected_x(x, y, eq0[0], eq0[1], eq0[2]);
    var y0 = projected_y(x, y, eq0[0], eq0[1], eq0[2]);
    var closest_distance = length_of(x - x0, y - y0);
    for(var i = 1; i < eval(name + "_eqs"); ++i) {
        var eq = eval(name + "_eq_" + (i+1));
        var xi = projected_x(x, y, eq[0], eq[1], eq[2]);
        var yi = projected_y(x, y, eq[0], eq[1], eq[2]);
        var distancei = length_of(x - xi, y - yi);
        if (distancei < closest_distance) {
            closest_distance = distancei;
            closest_eq_i = i;
        }
    }
    return closest_eq_i + 1;
}

function invalidate_plot_named(name) {
    var temp_id = eval(name + "_eq_temp_id");
    eval(name + "_eq_" + temp_id + " = " + name + "_eq_" + temp_id + "_temp;");
    draw_plot_named(name, 0, 0, false);
    update_system(name);
    update_matrix(name);
}

function init_plot_named(name) {
    plot = document.getElementById(name);
    var canvas_rect = plot.getBoundingClientRect();
    invalidate_plot_named(name);

    plot.addEventListener('mousemove', function(e){
       var canvas_rect = plot.getBoundingClientRect();
       draw_plot_named(name, e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
       if(e.buttons == 1){
           invalidate_plot_named(name);
       } else if(e.buttons == 0){
            nearest_eq_id = find_nearest_eqution_id(name, e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
            eval(name + "_eq_temp_id = nearest_eq_id;");
       }
    }, false);

    plot.addEventListener('mousedown', function(e){
        invalidate_plot_named(name);
        var canvas_rect = plot.getBoundingClientRect();
        nearest_eq_id = find_nearest_eqution_id(name, e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
        eval(name + "_eq_temp_id = nearest_eq_id;");
    }, false);

    plot.addEventListener('mouseup', function(e){
        invalidate_plot_named(name);
    }, false);

    plot.addEventListener('mouseleave', function(e){
       draw_plot_named(name, 0, 0, false);
    }, false);
}

function draw_plot_named(name, client_x, client_y, do_guides) {
    plot = document.getElementById(name);
    var context = plot.getContext("2d");

    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // equations
    for(var i = 0; i < eval(name + "_eqs"); ++i) {
        context.beginPath();
        var eq = eval(name + "_eq_" + (i+1));
        var xys = get_points_on_the_ends(eq[0], eq[1], eq[2]);
        context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
        context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
        context.strokeStyle = line_colors[i];
        context.lineWidth = 2;
        context.stroke();
        context.closePath();
        context.lineWidth = 1;
    }

    // grid
    draw_grid_on(context);

    if(do_guides){
        // draw the quide
        var closest_eq_id = eval(name + "_eq_temp_id");
        var closest_eq = eval(name + "_eq_" + closest_eq_id);
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);
        var temp_eq = new_equation_for_one_point(closest_eq[0], closest_eq[1], closest_eq[2], x, y);
        eval(name + "_eq_" + closest_eq_id + "_temp = temp_eq;");
        context.beginPath();
        var xys = get_points_on_the_ends(temp_eq[0], temp_eq[1], temp_eq[2]);
        context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
        context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
        context.strokeStyle = line_colors[closest_eq_id - 1];
        context.setLineDash([4, 4]);
        context.stroke();
        context.setLineDash([]);
        context.closePath();
    }
}



//////
/// equations and matrix
function printable(a) {
    a_trimmed = Number(a.toFixed(2));
    if (Math.floor(a_trimmed) == a_trimmed)
        return a_trimmed;
    return a.toFixed(2);
}

function coefficient1(a, x) {
    a_trimmed = Number(a.toFixed(2));
    if (a_trimmed == 1)
        return x;
    if (a_trimmed == -1)
        return "-" + x;
    if (a_trimmed == 0)
        return "";
    return printable(a) + x;
}

function coefficient2(a, x) {
    a_trimmed = Number(a.toFixed(2));
    if (a_trimmed == 1)
        return " + " + x;
    if (a_trimmed == -1)
        return " - " + x;
    if (a_trimmed == 0)
        return "";
    if (a_trimmed > 0)
        return " + " + printable(a) + x;
    if (a_trimmed < 0)
        return " - " + -printable(a) + x;
}

function printable_eq(a1, x1, a2, x2, b) {
    if (Number(a1.toFixed(2)) == 0.0 && Number(a2.toFixed(2)) == 0.0)
        return "Not a valid equation; both coefficients are 0."
    if (Number(a1.toFixed(2)) == 0.0)
        return coefficient1(a2, x2) + " = " + printable(b);
    return coefficient1(a1, x1) + coefficient2(a2, x2) + " = " + printable(b);
}

function update_matrix(name) {
    if(document.getElementById(name + "_matrix_col1") == null)
        return;

    var eq1 = eval(name + "_eq_1");
    var eq2 = eval(name + "_eq_2");
    document.getElementById(name + "_matrix_col1").innerHTML =
        printable(eq1[0]) + "<br>" + printable(eq2[0]);
    document.getElementById(name + "_matrix_col2").innerHTML =
        printable(eq1[1]) + "<br>" + printable(eq2[1]);
    document.getElementById(name + "_matrix_col3").innerHTML =
        printable(eq1[2]) + "<br>" + printable(eq2[2]);
}

function update_system(name) {
    if(document.getElementById(name + "_system_row1") == null)
        return;

    var eq1 = eval(name + "_eq_1");
    var eq2 = eval(name + "_eq_2");
    document.getElementById(name + "_system_row1").innerHTML =
        printable_eq(eq1[0], "x<sub>1</sub>", eq1[1], "x<sub>2</sub>", eq1[2]);
    document.getElementById(name + "_system_row2").innerHTML =
        printable_eq(eq2[0], "x<sub>1</sub>", eq2[1], "x<sub>2</sub>", eq2[2]);
}



//////
/// systems
const system_1_eqs = 2;
var system_1_eq_1;
var system_1_eq_2;

var system_1_eq_temp_id = 1;
var system_1_eq_1_temp;
var system_1_eq_2_temp;

function set_system_1() {
    system_1_eq_1 = [1.0, -1.35, 0.4];
    system_1_eq_2 = [1.0, 2.0, 7.0];

    system_1_eq_temp_id = 1;
    system_1_eq_1_temp = system_1_eq_1;
    system_1_eq_2_temp = system_1_eq_2;
}
set_system_1();

function reset_system_1() {
    set_system_1();
    draw_plot_named('system_1', 0, 0, false);
    update_matrix('system_1');
    update_system('system_1');
}

// system 2
const system_2_eqs = 3;
var system_2_eq_1;
var system_2_eq_2;
var system_2_eq_3;

var system_2_eq_temp_id = 1;
var system_2_eq_1_temp;
var system_2_eq_2_temp;
var system_2_eq_3_temp;

function set_system_2() {
    system_2_eq_1 = [1.0, -1.35, 0.4];
    system_2_eq_2 = [1.0, 2.0, 7.0];
    system_2_eq_3 = [1.0, 0.3, 1.6];

    system_2_eq_temp_id = 1;
    system_2_eq_1_temp = system_2_eq_1;
    system_2_eq_2_temp = system_2_eq_2;
    system_2_eq_3_temp = system_2_eq_3;
}
set_system_2();

function reset_system_2() {
    set_system_2();
    draw_plot_named('system_2', 0, 0, false);
}

// system 3
const system_3_eqs = 2;
var system_3_eq_1;
var system_3_eq_2;

var system_3_eq_temp_id = 1;
var system_3_eq_1_temp;
var system_3_eq_2_temp;

function set_system_3() {
    system_3_eq_1 = [1.0, 1.5, 4.5];
    system_3_eq_2 = [1.0, -3.5, -3.0];

    system_3_eq_temp_id = 1;
    system_3_eq_1_temp = system_3_eq_1;
    system_3_eq_2_temp = system_3_eq_2;
}
set_system_3();

function reset_system_3() {
    set_system_3();
    draw_plot_named('system_3', 0, 0, false);
    update_system('system_3');
}


//////
/// solver

// lines
var solver_1_eqs = 2;
var solver_1_eq_1;
var solver_1_eq_2;

// start
var start_x;
var start_y;

// margin
var end_step_length;

// current id
var solver_1_eq_temp_id = 1;

// temps
var solver_1_eq_1_temp;
var solver_1_eq_2_temp;
var end_step_length_temp;

function set_solver_1() {
    solver_1_eq_1 = [-0.9, 1.0, -1.0]
    solver_1_eq_2 = [-0.15, 1.0, 2.5]
    start_x = 1.0;
    start_y = 1.0;
    end_step_length = 0.3

    solver_1_eq_2_temp = solver_1_eq_2;
    solver_1_eq_1_temp = solver_1_eq_1;
    end_step_length_temp = end_step_length;
}
set_solver_1();

function invalidate_solver_1(client_x, client_y){
    var solver = document.getElementById("solver_1");
    var canvas_rect = solver.getBoundingClientRect();
    if(document.getElementById("button_1").disabled) {
           eval("solver_1_eq_" + solver_1_eq_temp_id + " = " + name + "solver_1_eq_" + solver_1_eq_temp_id + "_temp;");
    } else if(document.getElementById("button_2").disabled) {
        start_x = client_to_x(client_x - canvas_rect.left);
        start_y = client_to_y(client_y - canvas_rect.top);
    } else if(document.getElementById("button_3").disabled) {
        end_step_length = temp_end_step_length;
    }
    draw_solver_1(0, 0, false);
    draw_solver_2(0, 0, false);
}

function init_solver_1(){
    var solver = document.getElementById("solver_1");
    var canvas_rect = solver.getBoundingClientRect();
    draw_solver_1(0, 0, false);

    solver.addEventListener('mousemove', function(e){
        var canvas_rect = solver.getBoundingClientRect();
        draw_solver_1(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1) {
            invalidate_solver_1(e.clientX, e.clientY);
        } else if(e.buttons == 0) {
            solver_1_eq_temp_id = find_nearest_eqution_id("solver_1", e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
        }
    }, false);

    solver.addEventListener('mousedown', function(e){
        invalidate_solver_1(e.clientX, e.clientY);
        var canvas_rect = solver.getBoundingClientRect();
        solver_1_eq_temp_id = find_nearest_eqution_id("solver_1", e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
    }, false);

    solver.addEventListener('mouseup', function(e){
        invalidate_solver_1(e.clientX, e.clientY);
    }, false);

    solver.addEventListener('mouseleave', function(e){
        draw_solver_1(0, 0, false);
    }, false);
}

var last_iterations = 100;
var last_error = 100.;
function draw_solver_1(client_x, client_y, do_guides){
    var solver = document.getElementById("solver_1");
    var context = solver.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);


    // lines and stop criterias
    context.globalAlpha = 0.6;
    for(var i = 0; i < solver_1_eqs; ++i){
        var eq = eval("solver_1_eq_" + (i + 1));
        // stop
        context.beginPath();
        var db2 = end_step_length * length_of(eq[0], eq[1]);
        context.moveTo(x_to_client(x_min), y_to_client((eq[2] - db2 - eq[0]*(x_min))/eq[1]));
        context.lineTo(x_to_client(x_max), y_to_client((eq[2] - db2 - eq[0]*(x_max))/eq[1]));
        context.lineTo(x_to_client(x_max), y_to_client((eq[2] + db2 - eq[0]*(x_max))/eq[1]));
        context.lineTo(x_to_client(x_min), y_to_client((eq[2] + db2 - eq[0]*(x_min))/eq[1]));
        context.lineTo(x_to_client(x_min), y_to_client((eq[2] - db2 - eq[0]*(x_min))/eq[1]));
        context.strokeStyle = line_colors[i];
        context.stroke();
        context.closePath();
        context.fillStyle = fill_colors[i];
        context.fill();
    }
    context.globalAlpha = 1.0;
    for(var i = 0; i < solver_1_eqs; ++i){
        var eq = eval("solver_1_eq_" + (i + 1));
        // line
        context.beginPath();
        context.lineWidth = 2;
        var xys = get_points_on_the_ends(eq[0], eq[1], eq[2]);
        context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
        context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
        context.strokeStyle = line_colors[i];
        context.stroke();
        context.lineWidth = 1;
        context.closePath();
    }

    // solver
    context.beginPath();
    context.moveTo(x_to_client(start_x), y_to_client(start_y));
    var prev_x = start_x + end_step_length + 1.;    // not to fall as done
    var prev_y = start_y;
    var cur_x = start_x;
    var cur_y = start_y;
    var i;
    for(i = 0; i <= 100; i++) // max iterations = 100
    {
        if(length_of(prev_x - cur_x, prev_y - cur_y) < end_step_length)
            break;  // done
        prev_x = cur_x;
        prev_y = cur_y;
        if(i % 2 == 0){
            cur_x = projected_x(prev_x, prev_y, solver_1_eq_1[0], solver_1_eq_1[1], solver_1_eq_1[2]);
            cur_y = projected_y(prev_x, prev_y, solver_1_eq_1[0], solver_1_eq_1[1], solver_1_eq_1[2]);
        }else{
            cur_x = projected_x(prev_x, prev_y, solver_1_eq_2[0], solver_1_eq_2[1], solver_1_eq_2[2]);
            cur_y = projected_y(prev_x, prev_y, solver_1_eq_2[0], solver_1_eq_2[1], solver_1_eq_2[2]);
        }
        context.lineTo(x_to_client(cur_x), y_to_client(cur_y));
    }
    last_iterations = i;
    context.strokeStyle="#002200";
    context.setLineDash([2, 2]);
    context.stroke();
    context.setLineDash([]);
    context.closePath();

    // grid
    draw_grid_on(context);

    // mouse move
    if(do_guides){
        if(document.getElementById("button_1").disabled){
            var eq = eval("solver_1_eq_" + solver_1_eq_temp_id);
            var x = client_to_x(client_x);
            var y = client_to_y(client_y);
            var temp_eq = new_equation_for_one_point(eq[0], eq[1], eq[2], x, y);
            eval("solver_1_eq_" + solver_1_eq_temp_id + "_temp = temp_eq;");

            context.beginPath();
            var xys = get_points_on_the_ends(temp_eq[0], temp_eq[1], temp_eq[2]);
            context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
            context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
            context.strokeStyle = line_colors[solver_1_eq_temp_id - 1];
            context.setLineDash([4, 4]);
            context.stroke();
            context.setLineDash([]);
            context.closePath();

        }else if(document.getElementById("button_2").disabled){
            context.beginPath();
            context.setLineDash([4, 4]);
            context.moveTo(x_to_client(start_x), y_to_client(start_y));
            context.lineTo(client_x, client_y);
            context.strokeStyle="#557755";
            context.stroke();
            context.setLineDash([]);
            context.closePath();
        }else if(document.getElementById("button_3").disabled){
            var a11 = solver_1_eq_1[0];
            var a12 = solver_1_eq_1[1];
            var b1 = solver_1_eq_1[2];
            var a21 = solver_1_eq_2[0];
            var a22 = solver_1_eq_2[1];
            var b2 = solver_1_eq_2[2];
            var x = client_to_x(client_x);
            var y = client_to_y(client_y);
            var x1 = projected_x(x, y, a11, a12, b1);
            var y1 = projected_y(x, y, a11, a12, b1);
            var x2 = projected_x(x, y, a21, a22, b2);
            var y2 = projected_y(x, y, a21, a22, b2);
            var d1 = length_of(x-x1, y-y1);
            var d2 = length_of(x-x2, y-y2);
            if(d1 < d2){
                temp_end_step_length = d1;
            }else{
                temp_end_step_length = d2;
            }
            // red
            context.beginPath();
            context.setLineDash([4, 4]);
            var db1 = temp_end_step_length * length_of(a11, a12);
            context.moveTo(x_to_client(x_min), y_to_client((b1 - db1 - a11*(x_min))/a12));
            context.lineTo(x_to_client(x_max), y_to_client((b1 - db1 - a11*(x_max))/a12));
            context.moveTo(x_to_client(x_min), y_to_client((b1 + db1 - a11*(x_min))/a12));
            context.lineTo(x_to_client(x_max), y_to_client((b1 + db1 - a11*(x_max))/a12));
            context.strokeStyle="#ff8866";
            context.stroke();
            context.setLineDash([]);
            context.closePath();
            // blue
            context.beginPath();
            context.setLineDash([4, 4]);
            var db2 = temp_end_step_length * length_of(a21, a22);
            context.moveTo(x_to_client(x_min), y_to_client((b2 - db2 - a21*(x_min))/a22));
            context.lineTo(x_to_client(x_max), y_to_client((b2 - db2 - a21*(x_max))/a22));
            context.moveTo(x_to_client(x_min), y_to_client((b2 + db2 - a21*(x_min))/a22));
            context.lineTo(x_to_client(x_max), y_to_client((b2 + db2 - a21*(x_max))/a22));
            context.strokeStyle="#6699ff";
            context.stroke();
            context.setLineDash([]);
            context.closePath();
        }
    }

    // iteration count
    results = document.getElementById("results");
    if(last_iterations > 100){
        results.innerHTML = "Ітерацій > 100";
    }else{
        results.innerHTML = "Ітерацій = " + last_iterations;
    }
    // solution
    var sxy = solve_2(solver_1_eq_1[0], solver_1_eq_1[1], solver_1_eq_1[2],  solver_1_eq_2[0], solver_1_eq_2[1], solver_1_eq_2[2]);
    results.innerHTML += "<br>";
    results.innerHTML += "Знайдений розв'язок: (" + cur_x.toFixed(3) + "; " + cur_y.toFixed(3) + "), ";
    results.innerHTML += "<i>точний: (" + sxy[0].toFixed(3) + "; " + sxy[1].toFixed(3) + ")</i>";
    error = length_of(sxy[0] - cur_x, sxy[1] - cur_y);
    results.innerHTML += "<br>";
    results.innerHTML += "Припустима довжина переходу: " + end_step_length.toFixed(3) + ", справжня похибка: " + error.toFixed(3);
    last_error = error;
}

function reset_solver() {
    set_solver_1();
    set_solver_2();
    draw_solver_1(0, 0, false);
    draw_solver_2(0, 0, false);
}

function radio(n) {
    for(var i = 1; i <= 3; i++){
        radio_i = document.getElementById("button_" + i);
        radio_i.disabled = false;
    }
    radio_n = document.getElementById("button_" + n);
    radio_n.disabled = true;
}

///////
/// solver 2
var solver_2_eqs = 2;
var solver_2_eq_1_temp;
var solver_2_eq_2_temp;
function set_solver_2() {
    solver_2_eq_2_temp = solver_1_eq_2;
    solver_2_eq_1_temp = solver_1_eq_1;
}

function invalidate_solver_2(client_x, client_y) {
    var solver = document.getElementById("solver_2");
    var canvas_rect = solver.getBoundingClientRect();
    eval("solver_1_eq_" + solver_1_eq_temp_id + " = " + name + "solver_2_eq_" + solver_1_eq_temp_id + "_temp;");
    draw_solver_1(0, 0, false);
    draw_solver_2(0, 0, false);
}

function init_solver_2(){
    var solver = document.getElementById("solver_2");
    var canvas_rect = solver.getBoundingClientRect();
    draw_solver_2(0, 0, false);

    solver.addEventListener('mousemove', function(e){
        var canvas_rect = solver.getBoundingClientRect();
        draw_solver_2(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1) {
            invalidate_solver_2(e.clientX, e.clientY);
        } else if(e.buttons == 0) {
            solver_1_eq_temp_id = find_nearest_eqution_id("solver_1", e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
        }
    }, false);

    solver.addEventListener('mousedown', function(e){
        invalidate_solver_2(e.clientX, e.clientY);
        var canvas_rect = solver.getBoundingClientRect();
        solver_1_eq_temp_id = find_nearest_eqution_id("solver_1", e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
    }, false);

    solver.addEventListener('mouseup', function(e){
        invalidate_solver_2(e.clientX, e.clientY);
    }, false);

    solver.addEventListener('mouseleave', function(e){
        draw_solver_2(0, 0, false);
    }, false);
}

function draw_solver_2(client_x, client_y, do_guides){
    var solver = document.getElementById("solver_2");
    var context = solver.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // only lines now
    for(var i = 0; i < solver_1_eqs; ++i){
        var eq = eval("solver_1_eq_" + (i + 1));
        // line
        context.beginPath();
        context.lineWidth = 2;
        var xys = get_points_on_the_ends(eq[0], eq[1], eq[2]);
        context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
        context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
        context.strokeStyle = line_colors[i];
        context.stroke();
        context.lineWidth = 1;
        context.closePath();
    }

    // solver
    context.beginPath();
    context.moveTo(x_to_client(0), y_to_client(0));
    var ixy = solve_2(solver_1_eq_1[0], solver_1_eq_1[1], 0,  solver_1_eq_2[0], solver_1_eq_2[1], solver_1_eq_2[2]);
    context.lineTo(x_to_client(ixy[0]), y_to_client(ixy[1]));
    var sxy = solve_2(solver_1_eq_1[0], solver_1_eq_1[1], solver_1_eq_1[2],  solver_1_eq_2[0], solver_1_eq_2[1], solver_1_eq_2[2]);
    context.lineTo(x_to_client(sxy[0]), y_to_client(sxy[1]));
    context.strokeStyle="#002200";
    context.lineWidth = 2;
    context.setLineDash([2, 2]);
    context.stroke();
    context.lineWidth = 1;
    context.setLineDash([]);
    context.closePath();

    // grid
    draw_grid_on(context);

    // mouse move
    if(do_guides){
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);
        var eq = eval("solver_1_eq_" + solver_1_eq_temp_id);

        var temp_eq = new_equation_for_one_point(eq[0], eq[1], eq[2], x, y);
        eval("solver_2_eq_" + solver_1_eq_temp_id + "_temp = temp_eq;");

        context.beginPath();
        var xys = get_points_on_the_ends(temp_eq[0], temp_eq[1], temp_eq[2]);
        context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
        context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
        context.strokeStyle = line_colors[solver_1_eq_temp_id - 1];
        context.setLineDash([4, 4]);
        context.stroke();
        context.setLineDash([]);
        context.closePath();
    }
}


///////
/// linear multiplier
function inc(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) + 1;
    eval('change_' + counter_name + '()');
}

function dec(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) - 1;
    eval('change_' + counter_name + '()');
}

function change_linear_multiplier() {
    var multiplier = Number(document.getElementById('linear_multiplier').value);
    var row = document.getElementById('linear_row2');
    if(multiplier != 0) {
        row.innerHTML = printable_eq(multiplier, "x<sub>1</sub>", 2 * multiplier, "x<sub>2</sub>", 3 * multiplier);
    } else {
        row.innerHTML = "Except for 0, yes.";
        hidden_quests[0] = 1;
    }
}

//////
/// underspecified
function change_s3_1_1() {}
function change_s3_1_2() {}
function change_s3_1_3() {}
function change_s3_1_4() {}
function change_s3_2_1() {}
function change_s3_2_2() {}
function change_s3_2_3() {}
function change_s3_2_4() {}


//////
/// elimination
function do_one_elimination_step() {
    if(Math.abs(system_3_eq_1[1] / system_3_eq_1[0] - system_3_eq_2[1] / system_3_eq_2[0]) < 0.05) {
        document.getElementById('step_name').innerHTML = "Авжеж! На паралельних прямих цей метод не працює. Чудово що визнайшли це самі!";
        hidden_quests[1] = 1;
    } else if (system_3_eq_1[0] == 1.0 && system_3_eq_1[1] == 0.0 && system_3_eq_2[0] == 0.0 && system_3_eq_2[1] == 1.0) {
        document.getElementById('step_name').innerHTML = "Вже розв'язано!";
    } else if (system_3_eq_2[1] != system_3_eq_1[1] && system_3_eq_2[1] != 1.0 && system_3_eq_1[1] != 0) {
        document.getElementById('step_name').innerHTML = "Поділили друге рівняння на його ж другий коефіцієнт.";
        system_3_eq_2[0] /= system_3_eq_2[1];
        system_3_eq_2[2] /= system_3_eq_2[1];
        system_3_eq_2[1] = 1.0;
    } else if (system_3_eq_2[1] != system_3_eq_1[1] && system_3_eq_1[1] != 0) {
        document.getElementById('step_name').innerHTML = "Помножили друге рівняння на другий коефіцієнт першого.";
        system_3_eq_2[0] *= system_3_eq_1[1];
        system_3_eq_2[1] = system_3_eq_1[1];
        system_3_eq_2[2] *= system_3_eq_1[1];
    } else if (system_3_eq_2[1] == system_3_eq_1[1] && system_3_eq_1[1] != 0) {
        document.getElementById('step_name').innerHTML = "Відняли все друге рівняння із першого.";
        system_3_eq_1[0] -= system_3_eq_2[0];
        system_3_eq_1[1] = 0.0;
        system_3_eq_1[2] -= system_3_eq_2[2];
    } else if (system_3_eq_1[1] == 0.0 && system_3_eq_1[0] != 1.0 && system_3_eq_1[0] != system_3_eq_2[0] && system_3_eq_2[0] != 0.0 ) {
        document.getElementById('step_name').innerHTML = "Поділили перше рівняння на його ж перший коефіцієнт.";
        system_3_eq_1[2] /= system_3_eq_1[0];
        system_3_eq_1[0] = 1.0;
    } else if (system_3_eq_1[1] == 0.0 && system_3_eq_1[0] == 1.0 && system_3_eq_2[0] != 1.0 && system_3_eq_2[0] != 0.0) {
        document.getElementById('step_name').innerHTML = "Помножили перше рівняння на перший коефіцієнт другого рівняння.";
        system_3_eq_1[2] *= system_3_eq_2[0];
        system_3_eq_1[0] = system_3_eq_2[0];
    } else if (system_3_eq_1[1] == 0.0 && system_3_eq_1[0] == system_3_eq_2[0]) {
        document.getElementById('step_name').innerHTML = "Відняли все перше рівняння із другого.";
        system_3_eq_2[0] = 0.0;
        system_3_eq_2[1] -= system_3_eq_1[1];
        system_3_eq_2[2] -= system_3_eq_1[2];
    } else if (system_3_eq_1[1] == 0.0 && system_3_eq_2[0] == 0.0) {
        document.getElementById('step_name').innerHTML = "Поділили рівняння на відповідні ненульові коефіцієнти.";
        system_3_eq_1[2] /= system_3_eq_1[0];
        system_3_eq_1[0] = 1.0;
        system_3_eq_2[2] /= system_3_eq_2[1];
        system_3_eq_2[1] = 1.0;
    }
    update_system("system_3");
    draw_plot_named("system_3");
}

//////
/// quests
function done_system_1_quest_1() {
    var xy = solve_2(system_1_eq_1[0], system_1_eq_1[1], system_1_eq_1[2], system_1_eq_2[0], system_1_eq_2[1], system_1_eq_2[2]);
    if(Math.abs(xy[0]) > 0.25 || Math.abs(xy[1]) > 0.25) {
        document.getElementById("reply_quest_1").innerHTML = "Вибачте, але ні. Спробуте ще раз.";
    } else if(Math.abs(xy[0]) >= 0.01 || Math.abs(xy[1]) >= 0.01) {
        document.getElementById("reply_quest_1").innerHTML = "Майже! Правильно!";
        document.getElementById("buttons_quest_1").style.display = 'none';
        quests[0] = 1;
    } else {
        document.getElementById("reply_quest_1").innerHTML = "Ідеально точно!";
        document.getElementById("buttons_quest_1").style.display = 'none';
        quests[0] = 1;
    }
    draw_plot_named('system_1', 0, 0, false);
}

function done_system_1_quest_2() {
    var xy = solve_2(system_1_eq_1[0], system_1_eq_1[1], system_1_eq_1[2], system_1_eq_2[0], system_1_eq_2[1], system_1_eq_2[2]);
    if(Math.abs(xy[0]) < 25 && Math.abs(xy[1]) < 25) {
        document.getElementById("reply_quest_2").innerHTML = "Вибачте, але рішення все ще існує: <i>x<sub>1</sub> =" + printable(xy[0]) + ", x<sub>2</sub> = " + printable(xy[1]) + "</i>. Спробуйте ще раз.";
    } else {
        document.getElementById("reply_quest_2").innerHTML = "Саме так! Коли прімі паралельні, рішення немає.";
        document.getElementById("buttons_quest_2").style.display = 'none';
        quests[1] = 1;
    }
    draw_plot_named('system_1', 0, 0, false);
}

function done_system_1_quest_3() {
    xyxy1 = get_points_on_the_ends(system_1_eq_1[0], system_1_eq_1[1], system_1_eq_1[2]);
    xyxy2 = get_points_on_the_ends(system_1_eq_2[0], system_1_eq_2[1], system_1_eq_2[2]);
    if(Math.abs(xyxy1[0][0] - xyxy2[0][0]) > 0.1 ||
       Math.abs(xyxy1[0][1] - xyxy2[0][1]) > 0.1 ||
       Math.abs(xyxy1[1][0] - xyxy2[1][0]) > 0.1 ||
       Math.abs(xyxy1[1][1] - xyxy2[1][1]) > 0.1) {
        var xy = solve_2(system_1_eq_1[0], system_1_eq_1[1], system_1_eq_1[2], system_1_eq_2[0], system_1_eq_2[1], system_1_eq_2[2]);
        document.getElementById("reply_quest_3").innerHTML = "Вибачте, але все ще є одне рішення: <i>x<sub>1</sub> =" + printable(xy[0]) + ", x<sub>2</sub> = " + printable(xy[1]) + "</i>. Спробуйте ще раз.";
    } else {
        document.getElementById("reply_quest_3").innerHTML = "Так! Якщо прямі співпадають, то і рішень буде нескінченна кількість. Кожна точка прямої — вже рішення.";
        document.getElementById("buttons_quest_3").style.display = 'none';
        quests[2] = 1;
    }
    draw_plot_named('system_1', 0, 0, false);
}

function done_system_2_quest_4() {
    var xy1 = solve_2(system_2_eq_1[0], system_2_eq_1[1], system_2_eq_1[2], system_2_eq_2[0], system_2_eq_2[1], system_2_eq_2[2]);
    var xy2 = solve_2(system_2_eq_2[0], system_2_eq_2[1], system_2_eq_2[2], system_2_eq_3[0], system_2_eq_3[1], system_2_eq_3[2]);
    var xy3 = solve_2(system_2_eq_3[0], system_2_eq_3[1], system_2_eq_3[2], system_2_eq_1[0], system_2_eq_1[1], system_2_eq_1[2]);
    if(Math.abs(xy1[0] - xy2[0]) > 0.1 ||
       Math.abs(xy1[1] - xy2[1]) > 0.1){
        document.getElementById("reply_quest_4").innerHTML = "Перетини є, але це ще не рішення. Спробуйте ще раз.";
    } else {
        document.getElementById("reply_quest_4").innerHTML = "Так! Рішення буде якщо всі три прямі перетинатимуться в одній точці.";
        document.getElementById("buttons_quest_4").style.display = 'none';
        quests[3] = 1;
    }
    draw_plot_named('system_2', 0, 0, false);
}

function almost(a, b) {
    return Math.abs(a-b) < 1.e-5;
}

function done_system_3_quest_5() {
    var a11 =  Number(document.getElementById("s3_1_1").value);
    var a12 =  Number(document.getElementById("s3_1_2").value);
    var a13 =  Number(document.getElementById("s3_1_3").value);
    var b1 =  Number(document.getElementById("s3_1_4").value);
    var a21 =  Number(document.getElementById("s3_2_1").value);
    var a22 =  Number(document.getElementById("s3_2_2").value);
    var a23 =  Number(document.getElementById("s3_2_3").value);
    var b2 =  Number(document.getElementById("s3_2_4").value);

    if(almost(a11 / a21, a12 / a22) && almost(a11 / a21, a13 / a23))
    {
        if(almost(a11 / a21, b1 / b2))
        {
            document.getElementById("reply_quest_5").innerHTML = "Звісно, вони лінійно залежні. Тобто утворюють одну і ту саму площину. Але кожна точка на площині все ж таки буде рішенням.";
        } else {
            document.getElementById("reply_quest_5").innerHTML = "Правильно! Паралельні площини виглядають так: матрична частина системи рівнянь складається із лінійно залежних рівнянь, а от вся система із вектором свободних членов — вже ні.";
            document.getElementById("buttons_quest_5").style.display = 'none';
            document.getElementById("quest_5_formula").style.display = 'none';
            quests[4] = 1;
        }
    } else {
        document.getElementById("reply_quest_5").innerHTML = "Тут безкінечна кількість рішень. Перетин площин — це пряма. Кожна точка на цій прямій буде рішенням системи.";
    }
}

function done_system_4_quest_6() {
    if(last_iterations == 58) {
        document.getElementById("reply_quest_6").innerHTML = "Саме так! Або треба погіпшити сходимість, або зробити критерій зупинки більш строгим. Звісно, можна і стартову точку теж переносити.";
        document.getElementById("buttons_quest_6").style.display = 'none';
        quests[5] = 1;
    } else {
        document.getElementById("reply_quest_6").innerHTML = "Це ж не точно 58 ітерацій.";
    }
}

function done_system_4_quest_7() {
    if(last_error >= 6.0) {
        document.getElementById("reply_quest_7").innerHTML = "Звісно ж! Похибка залежить не тільки від критерію зупинки. При нашому критерії, чим гостіший кут між прямими, тим гірша буде похибка.";
        document.getElementById("buttons_quest_7").style.display = 'none';
        quests[6] = 1;
    } else {
        document.getElementById("reply_quest_7").innerHTML = "Це все ще менше за 6.0.";
    }
}

function done_system_4_quest_8() {
    var q101 = Math.abs(solver_1_eq_1[0] / solver_1_eq_1[1]);
    var q110 = Math.abs(solver_1_eq_1[1] / solver_1_eq_1[0]);
    var q201 = Math.abs(solver_1_eq_2[0] / solver_1_eq_2[1]);
    var q210 = Math.abs(solver_1_eq_2[1] / solver_1_eq_2[0]);
    if(Math.abs(q101 - q210) < 0.1 || Math.abs(q110 - q201) < 0.1) {
        document.getElementById("reply_quest_8").innerHTML = "Саме так! Якщо прямі ортогональні, рішення завжди знаходиться щобільше за два переходи. Ітерацій тоді буде три, бо третя ітерація тільки зупиняє алгоритм і нікуди далі не йде.";
        document.getElementById("buttons_quest_8").style.display = 'none';
        quests[7] = 1;
    } else if(last_iterations <= 3){
        document.getElementById("reply_quest_8").innerHTML = "Ну воно ніби і так, але якщо посунути стартову точку, то буде вже більше за три ітерації.";
    } else {
        document.getElementById("reply_quest_8").innerHTML = "Вибачте, але ні. Спробуйте ще раз.";
    }
}

function done_quest_9() {
    if(document.getElementById("aq8_1").checked) {
        document.getElementById("reply_quest_9").innerHTML = "Вибачте, але складність набагато більша.";
    }else if(document.getElementById("aq8_2").checked) {
        document.getElementById("reply_quest_9").innerHTML = "Ні, не зовсім. Ви не впустили зовнішній цикл?";
    }else if(document.getElementById("aq8_3").checked) {
        document.getElementById("reply_quest_9").innerHTML = "Саме так! Чотири вкладених цикли, кожен залежить від кількості рівнянь. Отже і складність буде <i>O(n<sup>4</sup>)</i>.";
        document.getElementById("complexity_buttons").style.display = 'none';
        document.getElementById("buttons_quest_9").style.display = 'none';
        quests[8] = 1;
    }else if(document.getElementById("aq8_4").checked) {
        document.getElementById("reply_quest_9").innerHTML = "Майже. Зверніть уваге, що два останніх цикла насправді не вкладені.";
    }else {
        document.getElementById("reply_quest_9").innerHTML = "Оберіть спершу якусь відповідь.";
    }
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Вступ до лінійних рівнянь для програмістів
    </h1>
    <p>
Сучасному програмістові не доводиться самому писати алгоритми для розв'язку систем лінійних рівнянь. Цей вступ, власне, і не про деталі реалізацій. Втім, проблеми, які можна розв'язати у формі лінійних рівнянь, сучасному програмістові зустрічаються. Цей вступ, відповідно, саме про концептуальні основи, які допомогають такі проблеми розпізнати і вирішити.
    </p>
    <p>
Насправді, навіть якщо вас взагалі не збуджує лінійна алгебра, вам все одно можуть бути цікаві деякі ідеї про які тут йдеться. Сходимість, похибка обчислення, складність алгоритмів, — всі ці речі будуть наочно проілюстровані на простих прикладах лінійних систем.
    </p>
    <p>
Лінійна система — це система лінійних рівнянь. Рівняння називається лінійним, якщо воно не містить нічого окрім зваженої суми змінних що дорівнює константі. У двовимірному просторі лінійне рівняння працює ще як рівняння прямої. У тривимірному — площини. У чьотирьох і більше — гіперплощини.
    </p>
    <p>
Систему можна записати просто як множину рівнянь.    
    </p>
    <table class="formula">
    <tr>
    <td rowspan=2 class="brackets">{</td>
    <td id="system_1_system_row1">
    a11x1 + a12x2 = b1
    </td>
    </tr><tr>
    <td id="system_1_system_row2">
    a21x1 + a22x2 = b2
    </td>
    </tr>
    </table>
    <p>
А можна як одне матричне рівняння.
    </p>

    <table class="formula">
    <tr>
    <td class="brackets">[</td>
    <td id="system_1_matrix_col1">
1<br>0
    </td>
    <td id="system_1_matrix_col2">
0<br>1
    </td>
    <td class="brackets">]</td>
    <td class="brackets">[</td>
    <td>
x<sub>1</sub> <br> x<sub>2</sub>
    </td>
    <td class="brackets">]</td>
    <td> = </td>
    <td class="brackets">[</td>
    <td id="system_1_matrix_col3">
0<br>1
    </td>
    <td class="brackets">]</td>
    </tr>
    </table>

    <p>
У двовимірному випадку систему можна навіть намалювати графіками рівнянь. 
    </p>
    <canvas id="system_1" width=640 height=512></canvas>
    <p class="comment">
Цей графік інтерактивний. На ньому можна керувати кривими, а системи згори автоматично перебудуватимуться.
    </p>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="button_1_reset" onclick="reset_system_1()">Reset</button>
    </div>

    <p>
Графічне представлення — це корисна ментальна модель. Зазвичай, про прямі думати простіше ніж про числа і змінні. Наприклад, розв'язком системи є перетин прямих. Дуже просто.
    </p>

    <form>
        <b>Перший квест.</b> Керуючи прямими на графіку згори, зробіть систему, яка матиме розв'язок в нулі: <i>x<sub>1</sub> = 0, x<sub>2</sub> = 0</i>. Зробіть і натисніть кнопку &laquo;Перевірити!&raquo; button.
        <div id="reply_quest_1" style="padding-top:6pt;"></div>
        <div id="buttons_quest_1" style="text-align:right;">
            <button type="button" id="button_1_1" onclick="done_system_1_quest_1()">Перевірити!</button>
        </div>
    </form>

    <p>
Не всі системи в принципі можна розв'язати.
    </p>

    <form>
        <b>Другий квест.</b> Керуючи прямими на графіку згори, зробіть систему, яка в принципі не матимиме розв'язку.
        <div id="reply_quest_2" style="padding-top:6pt;"></div>
        <div id="buttons_quest_2" style="text-align:right;">
            <button type="button" id="button_1_2" onclick="done_system_1_quest_2()">Перевірити!</button>
        </div>
    </form>

    <p>
А буває навпаки, є безкінечна кількість розв'язків.
    </p>

    <form>
        <b>Третій квест.</b> Керуючи прямими на тому ж графіку, зробіть систему із безкінечною кількістю розв'язків.
        <div id="reply_quest_3" style="padding-top:6pt;"></div>
        <div id="buttons_quest_3" style="text-align:right;">
            <button type="button" id="button_1_3" onclick="done_system_1_quest_3()">Перевірити!</button>
        </div>
    </form>

    <p>
Чисельні методи зазвичай розраховані на пошук єдиного розв'язку і такі системи можуть бути для них проблемою. Втім, деякі імплементації не вважають це проблемою і повертають перший ліпший розв'язок.
    </p>
    <p>
Якщо помножити кожен коефіцієнт рівняння разом із константою на одне і те саме число, всі факти про точки, які це рівняння описує, лишаться незмінними. Це буде те саме рівняння. Воно буде рівнянням тієї ж самої прямої. Рівняння, які мають різні коефіцієнти, але описують одну і ту ж пряму, називаються лінійно залежними.
    </p>
    <table class="formula">
    <tr>
    <td id="linear_row1">
    x<sub>1</sub> + 2x<sub>2</sub> = 3
    </td>
    </tr><tr>
    <td>
    <button type="button" class="incdec" onclick="dec('linear_multiplier')">-</button><input type="text" style="width: 32pt;" id="linear_multiplier" value="2" oninput="change_linear_multiplier();"><button type="button" class="incdec" onclick="inc('linear_multiplier')">+</button>
    </td>
    </tr><tr>
    <td id="linear_row2">
    2x<sub>1</sub> + 4x<sub>2</sub> = 6
    </td>
    </tr>
    </table>

    <p>
Система рівнянь може мати більше рівнянь ніж змінних. Такі системи називаються перевизначеними.    
    </p>
    <canvas id="system_2" width=640 height=512></canvas>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="button_2_reset" onclick="reset_system_2()">Reset</button>
    </div>
    <p>
В загальному випадку, такі системи не мають розв'язку. Але в окремих випадках можуть і мати.
    </p>

    <form>
        <b>Четвертий квест.</b> Використовуючи графік із трьома прямими, зробіть систему із єдиним розв'язком.
        <div id="reply_quest_4" style="padding-top:6pt;"></div>
        <div id="buttons_quest_4" style="text-align:right;">
            <button type="button" id="button_2_4" onclick="done_system_2_quest_4()">Перевірити!</button>
        </div>
    </form>

    <p>
Може бути і навпаки. Система може мати більше змінних аніж рівнянь. Такі системи називаються недовизначеними.
    </p>
    <p>
Звісно, у двовимірному випадку, недовизначена система складатиметься з одного рівняння. Кожна точка прямої цього рівняння буде розв'язком. І чи система це взагалі?
    </p>
    <p>
Але у багатовимірних випадках, недоспецифіковані системи можуть взагалі не мати розв'язків.
    </p>

     <form>
        <b>П'ятий квест.</b> Використовуючи матрицю знизу, зробіть недоспецифіковану систему із двох рівнянь, яка не матиме жодного розв'язку.

        <div id="reply_quest_5" style="padding-top:6pt;"></div>
        <div id="quest_5_formula">
            <table class="formula" style="padding:0 0 6pt 0;">
            <tr>
            <td class="brackets">[</td>
            <td id="system_3_matrix_col1_nonupdateable">
<nobr><button type="button" class="incdec" onclick="dec('s3_1_1')">-</button><input type="text" id="s3_1_1" value="1" oninput=""><button type="button" class="incdec" onclick="inc('s3_1_1')">+</button></nobr><br><nobr><button type="button" class="incdec" onclick="dec('s3_2_1')">-</button><input type="text" id="s3_2_1" value="2" oninput=""><button type="button" class="incdec" onclick="inc('s3_2_1')">+</button></nobr>
            </td>
            <td id="system_3_matrix_col2_nonupdateable">
<nobr><button type="button" class="incdec" onclick="dec('s3_1_2')">-</button><input type="text" id="s3_1_2" value="2" oninput=""><button type="button" class="incdec" onclick="inc('s3_1_2')">+</button></nobr><br><nobr><button type="button" class="incdec" onclick="dec('s3_2_2')">-</button><input type="text" id="s3_2_2" value="3" oninput=""><button type="button" class="incdec" onclick="inc('s3_2_2')">+</button></nobr>
            </td>
            <td id="system_3_matrix_col3_nonupdateable">
<nobr><button type="button" class="incdec" onclick="dec('s3_1_3')">-</button><input type="text" id="s3_1_3" value="3" oninput=""><button type="button" class="incdec" onclick="inc('s3_1_3')">+</button></nobr><br><nobr><button type="button" class="incdec" onclick="dec('s3_2_3')">-</button><input type="text" id="s3_2_3" value="4" oninput=""><button type="button" class="incdec" onclick="inc('s3_2_3')">+</button></nobr>
            </td>
            <td class="brackets">]</td>
            <td class="brackets">[</td>
            <td>
x<sub>1</sub><br>x<sub>2</sub><br>x<sub>3</sub>
            </td>
            <td class="brackets">]</td>
            <td> = </td>
            <td class="brackets">[</td>
            <td id="system_3_matrix_col4">
<nobr><button type="button" class="incdec" onclick="dec('s3_1_4')">-</button><input type="text" id="s3_1_4" value="4" oninput=""><button type="button" class="incdec" onclick="inc('s3_1_4')">+</button></nobr><br><nobr><button type="button" class="incdec" onclick="dec('s3_2_4')">-</button><input type="text" id="s3_2_4" value="5" oninput=""><button type="button" class="incdec" onclick="inc('s3_2_4')">+</button></nobr>
            </td>
            <td class="brackets">]</td>
            </tr>
            </table>
        </div>
        <div id="buttons_quest_5" style="text-align:right;">
            <button type="button" id="button_3_5" onclick="done_system_3_quest_5()">Перевірити!</button>
        </div>
    </form>

    <p>
Є два класи алгоритмів які розв'язують системи лінійних рівнянь: ітаративні та точні.
    </p>
    <p>
Ітеративні алгоритми концептуально прості. Вони всі зводяться до трьох кроків.
    </p>
    <ol>
    <li>Починаємо з якоїсь точки.</li>
    <li>Перевіряємо, чи ця точка вже є достатньо добрим рішенням. <br>Якщо так — чудово, ми впорались!</li>
    <li>Якщо ні, робимо щось що має наблизити цю точку по рішення. <br>Йдемо до кроку №2.</li>
    </ol>
    <p>
Давайте зробимо з цього рішалку. Той крок, що наближує точку до рішення буде простою проекцією на одну з прямих. Якщо ми візьмемо довільну точку і спроецюємо на одну з прямиз рівнянь, її проекція буде не дальше від розв'язку аніж сама точка. Точка, проекція, і розв'язок утворюватимуть прямокутний трикутник. Якщо він не вироджений, відрізок від проекції до рішення буде катетом, а від точки до рішення — гіпотенузою. Гіпотенуза не може бути коротшою за катете, отже якщо ми будемо послідовно проецювати точку з прямої на пряму, то рано чи піздно доберемося до якогось задовільно малого околу рішення.
    </p>
    <p>
Якщо звісно система має рішення.
    </p>
    <p>
Щодо умови виходу, ми зробимо ще простіше. Ми мірятимо те, скільки точка мала подолати за свій останній перехід щоб спроецюватися на пряму. Очікувано, із тим як ми наближатимемося до рішення, і переходи ставатимуть коротші. Отже, коли перехід стане зовсім мальким, ми вважатемемо, що рішення достатньо близько щоб зупинитися.
    </p>
    <p>
А от на питання &laquo;де починати&raquo; відповіді не буде. Чудово було б почати одразу біля рішення, але наш алгоритм мав би працювати починаючи з будь-якої точки, отже і сильно думати про це не варто.
    </p>
    <p>
Ось інтерактивна ілюстрація такого алгоритму.
    </p>
    <div id="solver_buttons">
    <center>
        <button type="button" id="button_1" style="width: 180px;" onclick="radio(1)" disabled="true">Прямі</button>
        <button type="button" id="button_2" style="width: 180px;" onclick="radio(2)">Початок</button>
        <button type="button" id="button_3" style="width: 180px;" onclick="radio(3)">Перехід</button>
    </center>
    </div>
    <canvas id="solver_1" width=640 height=512></canvas>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="reset_solver" onclick="reset_solver()">Наново</button>
    </div>

    <p class="results" id="results">
    </p>

    <p>
Якщо подібний до цього алгоритм і справді наближається до розв'язку із кожною ітерацією, то кажуть що він сходиться. Якщо навпаки, віддаляється — розходиться. Сходимість — це друга за важливістю характеристика ітеративного алгоритму. Фактично це його швидкість.
    </p>
    <p>
А найперша за важливістю властивість ітеративного алгоритму — це стабільність. Майже кожна операція на числах з плаваючою точкою може мати якусь нехай невелику похибку. Якщо ми виконуватимемо такі операції багато разів операції підряд, похибка накопичуватиметься і зрештою може стати проблемою. Стабільні алгоритми вміють не накопичуюти похибку. Нехай на кожній окремій ітерації якась похибка і присутня, але вона не впливатиме лінійно на похибку на наступній ітерації.
    </p>
    <p>
Цей конкретний алгоритм стабільний і геометрично не може розходитись. Більш того, його сходимість наочно пов'язана із кутом між прямими.    
    </p>
    <form>
        <b>Шостий квест.</b> Використовуючи графік нагорі, зробіть таку систему і налаштуйте умови, щоб отримати розв'язок рівно за 58 ітерацій.
        <div id="reply_quest_6" style="padding-top:6pt;"></div>
        <div id="buttons_quest_6" style="text-align:right;">
            <button type="button" id="button_4_6" onclick="done_system_4_quest_6()">Перевірити!</button>
        </div>
    </form>
    <p>
Втім, стабільність і сходимість — це ще не все. Цей конкретний алгоритм, наприклад, взагалі непридатний до практичного застосування. Якщо прямі майже паралельні, умова виходу яку ми обрали буде давати завелику похибку.
    </p>
    <form>
        <b>Сьомий квест.</b> Зробіть на графіку вгорі таку систему і такі умови, щоб похибка розв'язку була більше ніж 6.0.
        <div id="reply_quest_7" style="padding-top:6pt;"></div>
        <div id="buttons_quest_7" style="text-align:right;">
            <button type="button" id="button_4_7" onclick="done_system_4_quest_7()">Перевірити!</button>
        </div>
    </form>
    <p>
Точні алгоритми, на відміну від ітеративних, сходимості не мають. Натомість, вони виконуть свою работу за певну наперед визначену кількість операцій. 
    </p>
    <p>
Але при деяких умовах, ітеративні алгоритми поводяться як точні. Теж виконуть работу за наперед визначену кількість ітерацій.
    </p>
    <form>
        <b>Восьмий квест.</b> Зробіть на графіку нагорі систему, яка б завжди розв'язувалась не більше ніж за 3 ітерації.
        <div id="reply_quest_8" style="padding-top:6pt;"></div>
        <div id="buttons_quest_8" style="text-align:right;">
            <button type="button" id="button_4_8" onclick="done_system_4_quest_8()">Перевірити!</button>
        </div>
    </form>
    <p>
Точні алгоритми працюють так завжди, незалежно від системи. Що найцікавіше, ми теж можемо перетворити наш простий ітеративний алгоритм на точний додавши всього одну невелику деталь 
    </p>
    <p>
Ми робимо переходи послідовно проецюючи точку з прямої на пряму. Проекція відбувається ортогонально до наступної прямої. Давайте тепер замість цього проецювати точку на наступну пряму вздовж прямої поточної.
    </p>
    <canvas id="solver_2" width=640 height=512></canvas>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="reset_solver" onclick="reset_solver()">Reset</button>
    </div>
    <p>
Раз алгоритм тепер не ітеративний, критерій виходу йому не потрібен. А ще, так як ми маємо тепер &laquo;абсолютну сходимість&raquo; вибір першої точки теж ні на що не впливає. Хіба це не чудово! Нащо взагалі придумали ці ітеративні алгоритми?
    </p>
    <p>
Питання, звісно, саркастично-риторичне. Так само як практична ефективність ітеративного алгоритма залежить від сходимості, практична ефективність алгоритму точного залежить від його складності. Наприклад, цей конкретний алгоритм як раз непрактично складний.
    </p>
    <p>
<b>Складність</b> — це не те саме що просто кількість операцій. Як і сходимість, складність алгоритму може залежати від багатьох обставин. Інакше кажучи, змінних. Отже, це не число, а функція. Зазвичай, для того щоб записати функцію складності, ми використовуємо О-нотацію. Хитрість в тому, що у цій нотації ми описуємо вид трохи іншої функції — такої, яка обмежує складність алгоритму в залежності віt певних параметрів.
    </p>
    <p>
Якщо, наприклад, треба оцінити цикл який робить щось щонайбільше n раз, ми кажемо що його складність лінійна тобто <i>O(n)</i>. Насправді, навіть якщо в деяких випадках цикл може зоптимізуватися, закінчити роботу не дохходячи до кінця, на оцінку обмежуючої функції це не вприватиме. Ми описуємо функцію від n таку, яку для кожного n справжня складність такого циклу не має права перевищити.
    </p>
    <p>
Якщо цикл має в середині ще один цикл, то оцінка складності стає квадратичною: <i>O(n<sup>2</sup>)</i>. Якщо це три вкладених цикли: <i>O(n<sup>2</sup>)</i>. Оцінка подібного роду називається поліноміальною, і досить часто зустрічачється на практиці. Наприклад, наш новий алгоритм теж має поліноміальну оціночну складність.
    </p>
    <div style="width:505pt;">
    <pre>
def cross_of(A):
  ''' n-dimensional cross product on (n-1) vectors in list A '''
  D = len(A[0])
  N = len(A)

  v_res = [0.] * D
  <b>for</b> i in xrange(0, D):
    <b>for</b> jk in xrange(0, D ** N):
      v_ijk = [i] + [(jk/(D ** (N-j-1))) % D <b>for</b> j in xrange(0, N)]
      t_res = v__E(v_ijk)
      if t_res != 0:
        <b>for</b> k in xrange(0, N):
          t_res *= A[k][v_ijk[k + 1]]
        v_res[i] += t_res
  return v_res


def solution_for(A, B):
  p = [0. for each in B]
  <b>for</b> i in xrange(len(A)):
    plane_n = A[i]
    plane_d = -B[i]
    other_planes_ns = A[:i] + A[i+1:]
    projection_vector = cross_of(other_planes_ns)
    p = project_by_vector(p, projection_vector, plane_n, plane_d)
  return p
    </pre>
    </div>

    <form>
        <b>Дев'ятий квест.</b> Оцініть складність цього алгоритму у O-нотації.<br>
        <div id="complexity_buttons" style="font-family:sans-serif; font-style:italic;"><i>
        <input type="radio" name="q8" id="aq8_1" value="A">O(n<sup>2</sup>)<br>
        <input type="radio" name="q8" id="aq8_2" value="B">O(n<sup>3</sup>)<br>
        <input type="radio" name="q8" id="aq8_3" value="C">O(n<sup>4</sup>)<br>
        <input type="radio" name="q8" id="aq8_4" value="D">O(n<sup>5</sup>)<br>
        </i>
        </div>
        <div id="reply_quest_9" style="padding-top:6pt;"></div>
        <div id="buttons_quest_9" style="text-align:right;">
            <button type="button" id="button_5_9" onclick="done_quest_9()">Перевірити!</button>
        </div>
    </form>
    <p>
Як ви можете собі уявити, така оцінка робить алгоритм не ефективним на великих системах. Для розв'язку системи із тисячею рівнянь нашому алгоритму знадобиться порядка триліона операції. Це немало. Якщо збільшити систему ще на кілька порядків, то Сонце згасне до того як він взагалі закінчить свою работу.
    </p>
    <p>
От ітеративні алгоритми для того і придумали, щоб не чекати тисячі років там де можна почекати кілька хвилин і мати не такий точний, але все-таки розв'язок.
    </p>
    <p>
Це не означає, що вони завжди працюють швидше за точні. Просто вони надають здатність балансувати між точністью і швидкістю. 
    </p>
    <p>
Отже, наші попередні алгоритми годяться тільки для того, щоб навчати на них сходимості і складності. На щастя, ліпші варіанти вже давно знайдені, описані, і реалізовані к коді. Наприплад, алгоритм Гауса, який має складність у <a href="https://en.wikipedia.org/wiki/Gaussian_elimination#Computational_efficiency"><i>O(n<sup>3</sup>)</i></a>. При тому, що теоретична найліпша складність LU-розкладення взагалі <a href="https://en.wikipedia.org/wiki/LU_decomposition#Theoretical_complexity"><i>O(n<sup>2.376</sup>)</i></a>.
    </p>
    <p>
Головна ідея розкладення полягає в тому, що ми можемо змінювати систему як нам заманеться, якщо ми робитимемо це за правилами, які не порушують істиність кожного окремого рівняння.
    </p>
    <p>
Ми вже бачили, що якщо помножити рівняння на якесь ненульове число, її відповідна пряма на змінюється. Рівняння містить ту саму інформацію, що і до множення. А ми ще можемо додати бідь-яке рівняння до будь-якого іншого. Звісно, це змінить пряму, але не точку розв'язку. Бо точка розв'язку для двох рівнянь буде і лишатиместья однією і тією самою.
    </p>
    <p>
Цих двох операцій цілком достатньо, щоб перетворити якусь довільну систему рівнянь на тривіальну.
    </p>
    <canvas id="system_3" width=640 height=512></canvas>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="button_3_reset" onclick="reset_system_3()">Reset</button>
    </div>
    <table class="formula">
    <tr>
    <td rowspan=2 class="brackets">{</td>
    <td id="system_3_system_row1">
    a11x1 + a12x2 = b1
    </td>
    </tr><tr>
    <td id="system_3_system_row2">
    a21x1 + a22x2 = b2
    </td>
    </tr>
    </table>
    <button type="button" id="elimination" onclick="do_one_elimination_step()">One step</button>
    <p class="comment" id="step_name">
    </p>
    <h2>
P. S.
    </h2>
    <p>
That's all fine, but how do you choose a method to solve your particular case? There are a couple of hints.
    </p>
    <ol>
    <li>
If your system is sparse, meaning most of the coefficients are zeroes, you can exploit this with any <a href="https://en.wikipedia.org/wiki/LU_decomposition">decomposition</a> (factorization) or <a href="https://en.wikipedia.org/wiki/System_of_linear_equations#Elimination_of_variables">elimination</a> based method that works on sparse structures.
    </li>
    <li>
If your matrix is diagonally dominant, meaning that largest elements in every equation tend to land on the diagonal, then iterative methods such as <a href="https://en.wikipedia.org/wiki/Jacobi_method">Jacobi</a> or <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method">Gauss-Seidel</a> should work best for you.
    </li>
    <li>
And if your system is very small, like 2 to 4 equations, you're better off without any solver at all. Just solve it symbolically with a <a href="http://live.sympy.org/">SymPy</a> and copy-paste the symbolic solution back to your code. Yes, this will outperform any possible external solver. And no, it's not against the law to do so.
    </li>
    </ol>
    <script language="JavaScript">
        init_plot_named('system_1');
        init_plot_named('system_2');
        init_plot_named('system_3');
        change_linear_multiplier();
        init_solver_1();
        init_solver_2();
    </script>

    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
        <a href="index.html"><img src="favicon.ico"></a>
    </td>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        &nbsp;&larr; there's more.
    </td>
    <td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
        +
        <a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
        <a href="https://twitter.com/wordsandbuttons">Twitter</a> &
        <a href="https://news.ycombinator.com/from?site=wordsandbuttons.online">Hacker News</a>
    </td>
    </tr>
    </table>
    </center>
  </body>
</html>
