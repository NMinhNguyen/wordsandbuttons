v0 = my_vector 			// we want the horizontal sum of this
int64 r0 = get_len ( v0 ) 	// length of vector in bytes
int64 r0 = round_u2 ( r0 ) 	// round up to nearest power of 2
float v0 = set_len ( r0 , v0 ) 	// adjust vector length
while ( uint64 r0 > 4) { 	// loop to calculate horizontal sum
	uint64 r0 > >= 1 	// the vector length is halved
	float v1 = shift_reduce ( r0 , v0 ) // get upper half of vector
	// the result vector has the length of the first operand :
	float v0 = v1 + v0 	// Add upper half and lower half
}
// The sum is now a scalar in v0

Source: https://github.com/ForwardCom/manual/blob/master/forwardcom.pdf
ForwardCom: An open-standard instruction set for high-performance
microprocessors
Agner Fog
14 Code examples




nMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD 
    LOCAL wc:WNDCLASSEX       ; create local variables on stack 
    LOCAL msg:MSG 
    LOCAL hwnd:HWND

    mov   wc.cbSize,SIZEOF WNDCLASSEX      ; fill values in members of wc 
    mov   wc.style, CS_HREDRAW or CS_VREDRAW 
    mov   wc.lpfnWndProc, OFFSET WndProc 
    mov   wc.cbClsExtra,NULL 
    mov   wc.cbWndExtra,NULL 
    push  hInstance 
    pop   wc.hInstance 
    mov   wc.hbrBackground,COLOR_WINDOW+1 
    mov   wc.lpszMenuName,NULL 
    mov   wc.lpszClassName,OFFSET ClassName 
    invoke LoadIcon,NULL,IDI_APPLICATION 
    mov   wc.hIcon,eax 
    mov   wc.hIconSm,eax 
    invoke LoadCursor,NULL,IDC_ARROW 
    mov   wc.hCursor,eax 
    invoke RegisterClassEx, addr wc        ; register our window class 
    invoke CreateWindowEx,NULL, 
        ADDR ClassName, ADDR AppName,\ 
        WS_OVERLAPPEDWINDOW,\ 
        CW_USEDEFAULT, CW_USEDEFAULT,\ 
        CW_USEDEFAULT, CW_USEDEFAULT,\ 
        NULL, NULL, hInst, NULL 
    mov   hwnd,eax 
    invoke ShowWindow, hwnd,CmdShow        ; display our window on desktop 
    invoke UpdateWindow, hwnd              ; refresh the client area

    .WHILE TRUE                            ; Enter message loop 
                invoke GetMessage, ADDR msg,NULL,0,0 
                .BREAK .IF (!eax) 
                invoke TranslateMessage, ADDR msg 
                invoke DispatchMessage, ADDR msg 
   .ENDW 
    mov     eax,msg.wParam                 ; return exit code in eax 
    ret 
WinMain endp

Source: http://win32assembly.programminghorizon.com/tut3.html
Iczelion's Win32 Assembly Homepage
Tutorial 3: A Simple Window






