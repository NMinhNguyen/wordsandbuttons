<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Marching cubes and dual contouring contouring</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
    width: 300pt;
}

.code_piece {
    font-family: monospace;
    padding-left: 4pt;
    padding-right: 4pt;
}

.formula {
    font-family: sans-serif;
    font-size: 15pt;
    font-style: italic;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table {
    border-width: 0pt;
}

td {
    vertical-align: top;
    padding: 6pt 12pt 6pt 12pt;
    font-size: 16pt;
    border: 1px solid black;
    width: 600pt;
}

button{
    width: 248pt;
    height: 42pt;
    margin-left:4pt;
    margin-right:4pt;
    font-size: 16pt;
}

u {
    border-bottom: 1px dotted #000;
    text-decoration: none;
    cursor: pointer;
}
    </style>
    <script language="JavaScript">
const w = 640;
const h = 480;

function draw_marching_cubes(context, d_f, w, h, grid_size, distance) {
    context.beginPath();
    for(var i = 0; i <= h - grid_size; i += grid_size) {
        for(var j = 0; j <= w - grid_size; j += grid_size) {
            var d00 = d_f(j, i);
            var d01 = d_f(j, i + grid_size);
            var d11 = d_f(j + grid_size, i + grid_size);
            var d10 = d_f(j + grid_size, i);
            var t00_01 = (distance - d00) / (d01 - d00);
            var t01_11 = (distance - d01) / (d11 - d01);
            var t11_10 = (distance - d11) / (d10 - d11);
            var t10_00 = (distance - d10) / (d00 - d10);
            var in_00 = d00 < distance;
            var out_00 = !in_00;
            var in_01 = d01 < distance;
            var out_01 = !in_01;
            var in_11 = d11 < distance;
            var out_11 = !in_11;
            var in_10 = d10 < distance;
            var out_10 = !in_10;
            
            if(out_00 && in_01 && in_11 && in_10) {
                context.moveTo(j + grid_size * (1.0 - t10_00), i); // top
                context.lineTo(j, i + grid_size * t00_01);
            }            
            if(in_00 && out_01 && in_11 && in_10) {
                context.moveTo(j, i + grid_size * t00_01); // left
                context.lineTo(j + grid_size * t01_11, i + grid_size);
            }
            if(out_00 && out_01 && in_11 && in_10) {
                context.moveTo(j + grid_size * (1.0 - t10_00), i);
                context.lineTo(j + grid_size * t01_11, i + grid_size); // bottom
            }
            if(in_00 && in_01 && out_11 && in_10) {            
                context.moveTo(j + grid_size * t01_11, i + grid_size);
                context.lineTo(j + grid_size, i + grid_size * (1.0 - t11_10)); // right
            }
            if(out_00 && in_01 && out_11 && in_10) {  
                context.moveTo(j + grid_size * (1.0 - t10_00), i);
                context.lineTo(j + grid_size, i + grid_size * (1.0 - t11_10));
                context.moveTo(j, i + grid_size * t00_01);
                context.lineTo(j + grid_size * t01_11, i + grid_size);
            }
            if(in_00 && out_01 && out_11 && in_10) {  
                context.moveTo(j + grid_size, i + grid_size * (1.0 - t11_10));
                context.lineTo(j, i + grid_size * t00_01);
            }
            if(out_00 && out_01 && out_11 && in_10) {
                context.moveTo(j + grid_size, i + grid_size * (1.0 - t11_10));
                context.lineTo(j + grid_size * (1.0 - t10_00), i);
            }
            if(in_00 && in_01 && in_11 && out_10) {
                context.moveTo(j + grid_size * (1.0 - t10_00), i);
                context.lineTo(j + grid_size, i + grid_size * (1.0 - t11_10));
            }
            if(out_00 && in_01 && in_11 && out_10) {
                context.moveTo(j, i + grid_size * t00_01);
                context.lineTo(j + grid_size, i + grid_size * (1.0 - t11_10));
            }
            if(in_00 && out_01 && in_11 && out_10) {
                context.moveTo(j + grid_size, i + grid_size * (1.0 - t11_10));
                context.lineTo(j, i + grid_size * t00_01);
                context.moveTo(j + grid_size * t01_11, i + grid_size);
                context.lineTo(j + grid_size * (1.0 - t10_00), i);
            }
            if(out_00 && out_01 && in_11 && out_10) {
                context.moveTo(j + grid_size, i + grid_size * (1.0 - t11_10));
                context.lineTo(j + grid_size * t01_11, i + grid_size);
            }
            if(in_00 && in_01 && out_11 && out_10) {
                context.moveTo(j + grid_size * t01_11, i + grid_size);
                context.lineTo(j + grid_size * (1.0 - t10_00), i);
            }
            if(out_00 && in_01 && out_11 && out_10) {
                context.moveTo(j + grid_size * t01_11, i + grid_size);
                context.lineTo(j, i + grid_size * t00_01);
            }
            if(in_00 && out_01 && out_11 && out_10) {
                context.moveTo(j, i + grid_size * t00_01);
                context.lineTo(j + grid_size * (1.0 - t10_00), i);
            }
        }
    }
    context.strokeStyle = "#3333AA";
    context.lineWidth = 3;
    context.stroke();
    context.closePath(); 
    context.lineWidth = 1;
}

var do_contour = false;
function draw_contour() {
    var contour = document.getElementById("contour");
    var context = contour.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);
    context.font = "16px sans-serif";

    // circle function
    var distance_field = context.createImageData(w, h);
    for (var i = 0; i < distance_field.data.length; ++i)
        distance_field.data[i] = 0;
    for (var i = 0; i <= h; ++i)
        for (var j = 0; j <= w; ++j) {
            var d = Math.pow(Math.pow(i - h/2, 2) + Math.pow(j - w/2, 2), 0.5) - 160;
            if (Math.abs(d) < 1.4) {
                distance_field.data[(i*w + j) * 4 + 0] = 0xAA;
                distance_field.data[(i*w + j) * 4 + 1] = 0x55;
                distance_field.data[(i*w + j) * 4 + 2] = 0x55;
                distance_field.data[(i*w + j) * 4 + 3] = 0xFF;
            }
        }
    context.putImageData(distance_field, -0.5, -0.5);

    if(do_contour) {
        draw_marching_cubes(context, function (x, y) {
            return Math.pow(Math.pow(x - w/2, 2) + Math.pow(y - h/2, 2), 0.5);},
            w, h, 80, 160);
    }

    // grid
    const client_y_center = h /2 + 0.5;
    const client_x_center = w / 2 + 0.5;
    const x_min = -4;
    const x_max = +4;
    const y_min = -3;
    const y_max = +3;
    const client_x_step = w / (x_max - x_min);
    const client_y_step = h / (y_max - y_min);
    context.beginPath();
    context.moveTo(0, client_y_center);
    context.lineTo(w, client_y_center);
    context.lineTo(w - 12, client_y_center - 5);
    context.moveTo(w, client_y_center);
    context.lineTo(w - 12, client_y_center + 5);
    context.moveTo(client_x_center, h);
    context.lineTo(client_x_center, 0);
    context.lineTo(client_x_center - 5, 12);
    context.moveTo(client_x_center, 0);
    context.lineTo(client_x_center + 5, 12);
    context.fillStyle="#000000";
    for(var i = x_min + 1; i <= x_max - 1; i++){
        context.moveTo(client_x_center + i*client_x_step, client_y_center);
        context.lineTo(client_x_center + i*client_x_step, client_y_center - 5);
        context.fillText(i, client_x_center + i*client_x_step + 4, client_y_center + 16);
    }
    for(var i = y_min + 1; i <= y_max - 1; i++){
        context.moveTo(client_x_center, client_y_center - i*client_y_step);
        context.lineTo(client_x_center + 5, client_y_center - i*client_y_step);
        context.fillText(i, client_x_center + 5, client_y_center - i*client_y_step + 16);
    }
    context.strokeStyle="#000000";
    context.stroke();
    context.closePath();
}

function toggle_contour() {
    do_contour = !do_contour;
    draw_contour();
    var toggle_contour = document.getElementById("toggle_contour");
    if(do_contour)
        toggle_contour.innerHTML = "Undo contour";
    else
        toggle_contour.innerHTML = "Do contour";
}

function draw_grid_border(context, d_f, w, h, grid_size, distance) {
    context.beginPath();
    for(var i = 0.5; i <= h - grid_size; i += grid_size) {
        for(var j = 0.5; j <= w - grid_size; j += grid_size) {
            var do_horizontal = 
        (d_f(j + 0.5 * grid_size, i - 0.5 * grid_size) - distance ) *
        (d_f(j + 0.5 * grid_size, i + 0.5 * grid_size) - distance ) < 0 ? true : false;
            var do_vertical = 
        (d_f(j - 0.5 * grid_size, i + 0.5 * grid_size) - distance ) *
        (d_f(j + 0.5 * grid_size, i + 0.5 * grid_size) - distance ) < 0 ? true : false;
            if(do_horizontal) {
                context.moveTo(j, i);
                context.lineTo(j + grid_size, i);
            }
            if(do_vertical) {
                context.moveTo(j, i);
                context.lineTo(j, i + grid_size);                
            }            
        }
    }
    context.strokeStyle="#224477";
    context.lineWidth=3;
    context.stroke();
    context.closePath();
    context.lineWidth=1;
}

function draw_grid_border_contour() {
    var grid_border = document.getElementById("grid_border");
    var context = grid_border.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);
    context.font = "16px sans-serif";

    // circle function
    var distance_field = context.createImageData(w, h);
    for (var i = 0; i < distance_field.data.length; ++i)
        distance_field.data[i] = 0;
    for (var i = 0; i <= h; ++i)
        for (var j = 0; j <= w; ++j) {
            var d = Math.pow(Math.pow(i - h/2, 2) + Math.pow(j - w/2, 2), 0.5) - 160;
            if (Math.abs(d) < 1.4) {
                distance_field.data[(i*w + j) * 4 + 0] = 0xAA;
                distance_field.data[(i*w + j) * 4 + 1] = 0x55;
                distance_field.data[(i*w + j) * 4 + 2] = 0x55;
                distance_field.data[(i*w + j) * 4 + 3] = 0xFF;
            }
        }
    context.putImageData(distance_field, -0.5, -0.5);

    // grid
    const grid_size = 32;
    context.beginPath();
    for(var i = 0; i <= h; i += grid_size) {
        context.moveTo(0.0, i);
        context.lineTo(w, i);
    }
    for(var j = 0; j <= w; j += grid_size) {
        context.moveTo(j, 0.0);
        context.lineTo(j, h);
    }
    context.strokeStyle="#000000";
    context.lineWidth=1;
    context.stroke();
    context.closePath();
    
    draw_grid_border(context, function (x, y) {
            return Math.pow(Math.pow(x - w/2, 2) + Math.pow(y - h/2, 2), 0.5);},
            w, h, grid_size, 160);   
    }
    </script>
  </head>
  <body>
    <center>
    <h1>
Marching cubes and dual contouring contouring
    </h1>
    <p>
This is a basic introduction into the marching cubes and the dual contoring techniques. They are mostly known as 3D mesh generating algorithms but since it's hard to explain 3D things using 2D display, we will concentrate on planar analogue of the mesh generation which itself is called contouring.
    </p>
    <p>
The second “contouring” in the title is not a mistake.
    </p>
       
    <h2>
What is contouring?
    </h2>
    <p>
Let's say we have a function.
    </p>
    <p class="formula">
x<sup>2</sup> + y<sup>2</sup> = 4
    </p>
    <p>
This function represents a circle. Now let's say we don't want a perfect circle, but its contour, — a set of line segments that represent the circle within some tolerable error.  
    </p>
    <canvas id="contour" width=640 height=480></canvas>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="toggle_contour" onclick="toggle_contour()">Do contour</button>
    </div>
    <script language="JavaScript">
    draw_contour();
    </script>
    <p>
We can then do things with the contour that would be tricky to do with the circle itself. Like intersecting it with a square or storing it in the same structure as other contours regardless of their original nature. 
    </p>
    <p>
Conceptually, contouring is very easy. Let's rewrite our function:
    </p>
    <p class="formula">
F(x, y) = x<sup>2</sup> + y<sup>2</sup> - 4
    </p>
    <p>
Now we cover some part of a plane with a grid. For every two adjacent cells we can add their common border as a contour line segment if the function <i>F(x,y)</i> changes sign between these two cell's centers.
    </p>
    <canvas id="grid_border" width=640 height=480></canvas>
    <script language="JavaScript">
    draw_grid_border_contour();
    </script>
    <p>
Well, technically it does represent the curve. And the error is predictalbe, it doesn't exceed half of the cell's diagonal. But this contour has way too many corners as for a circle.
    </p>
    <p>
We need something better.
    </p>
    <h2>
Marching cubes    
    </h2>

    <p>
...    
    </p>
    
    <h2>
Dual contouring
    </h2>
    <p>
...    
    </p>


    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
        <a href="index.html"><img src="favicon.ico"></a> 
    </td>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        &nbsp;&larr; there's more.
    </td>
    <td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
        + 
        <a href="https://github.com/akalenuk/wordsandbuttons">Github</a> & 
        <a href="https://twitter.com/wordsandbuttons">Twitter</a> & 
        <a href="https://news.ycombinator.com/from?site=wordsandbuttons.online">Hacker News</a>
    </td>
    </tr>
    </table>
    </center>
  </body>
</html>
