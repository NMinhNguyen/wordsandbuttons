<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Outperforming everything with anything</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.footer {
    margin-top: 64pt;
    padding-bottom: 32pt;
    font-family: sans-serif;
    font-size: 16pt;
    text-align: left;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
    width: 300pt;
}

.code_piece {
    font-family: monospace;
    padding-left: 4pt;
    padding-right: 4pt;
}


table {
    border-width: 0pt;
}

td {
    vertical-align: top;
    padding: 6pt 12pt 6pt 12pt;
    font-size: 16pt;
    border: 1px solid black;
    width: 505pt;
}

button{
    width: 248pt;
    height: 42pt;
    margin-left:4pt;
    margin-right:4pt;
    font-size: 16pt;
}

li {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
    padding-bottom: 6pt;
}

u {
    border-bottom: 1px dotted #000;
    text-decoration: none;
    cursor: pointer;
}
    </style>
    <script language="JavaScript">
function next(slides){
    var first_slide = document.getElementById(slides + "_" + 1);
    for(var i = 1; i < 9; ++i)
    {
        var this_slide = document.getElementById(slides + "_" + i);
        var next_slide = document.getElementById(slides + "_" + (i+1));
        if(this_slide)
            if(this_slide.style.display == "block")
                {
                this_slide.style.display = "none";
                if(next_slide)
                    next_slide.style.display = "block";
                else
                    first_slide.style.display = "block";
                return;
                }
    }
}

function draw_results(){
    var d = document.getElementById("results");
    var d_context = d.getContext("2d");
    d_context.font = "16px sans-serif";
    // background
    d_context.fillStyle="#eeeeee";
	d_context.fillRect(0, 0, 702, 500);
	
	var x = 0.0;
	var y = 0.0;
	// C metaprogramming
	x = 0.5;
	y = 1.5;
	d_context.fillStyle="#BB0022";
	d_context.fillText("70 ms. C with tricks", x + 4, y + 16);
	d_context.beginPath();
	d_context.strokeStyle="#BB0022";
	d_context.moveTo(x, y);
	d_context.lineTo(x+233, y);
	d_context.lineWidth=2;
	d_context.stroke();
	d_context.closePath();
	
	// C++ metaprogramming
	x = 234.5;
	y = 499.5 - Math.floor(499 * 60/ 70);
	d_context.fillStyle="#882200";
	d_context.fillText("60 ms. C++ with a trick", x + 4, y - 8);
	d_context.beginPath();
	d_context.strokeStyle="#882200";
	d_context.moveTo(x, y);
	d_context.lineTo(x+233, y);
	d_context.lineWidth=2;
	d_context.stroke();
	d_context.closePath();
	
	// Python + LLVM
	x = 498.5;
	y = 499.5 - Math.floor(499 * 55 / 70);
	d_context.fillStyle="#668811";
	d_context.fillText("55 ms. Python + LLVM", x + 4, y - 8);
	d_context.beginPath();
	d_context.strokeStyle="#446600";
	d_context.moveTo(x, y);
	d_context.lineTo(x+233, y);
	d_context.lineWidth=2;
	d_context.stroke();
	d_context.closePath();	
}

function init_results(){
    draw_results();
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Outperforming everything with anything
<br>
<sub>Python? Sure, why not?</sub>
    </h1>
    <p>
This is a finishing piece for <a href="http://wordsandbuttons.online/outperforming_lapack_with_c_metaprogramming.html">Outperforming LAPACK with C metaprogramming</a>, and <a href="http://wordsandbuttons.online/vastly_outperforming_lapack_with_cpp_metaprogramming.html"> Vastly outperforming LAPACK with C++ metaprogramming</a>. These two describe tricks to help you help the compiler generate you some highly-performant code. But the tricks described imply that you know what you do better than the compiler does. But if this is the case, do you really need a compiler?
    </p>
    <p>
The alternative would be writing a programm in plain assembly. Although, the horrors of it is vastly egaggerated, this approach has two major flaws.
    </p>
    <ol>
    <li>
Assembly code is not really portable. Sure, sometimes it's not all that important. You may have to implement some specific algorithm for some dedicated hardware and the priority of portability may seem low. But consider this. What if you are actually good at what you do? What if the algorithm you implement survives some five or ten years? At some point you would want to update your hardware and non-portability may suddenly become an issue.
    </li>
    <li>
Although it became mush easier with modern tools, assembly programming still implies a lot of meticulous manual labor. What seems to be just a line of code in C may become a scren full of assembly. And a screen full of C code may become an all-night typing party.
    </li>
    </ol>
    <p>
Thankfully, we all live in the XXI century and both of these problems has already been addressed.
    </p>
    <p>
The solution to the first one would be <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a>. Initially it meant “Low Level Virtual Machine” and that is exactly what we want to ensure portability. Simply put, it takes some code written in very low-level intermediate representation and generates highly optimized native code from it. Single input — many outputs for many hardware platforms.
    </p>
    <p>
With LLVM we have the power of low-level programming, so we can structure our program manually, and we still delegate hardware microoptimizations to the machine.
    </p>
    <p>
And the solution for the second problem is basically any language you want. Lisp, Python, Perl, even bash, and AWK will do. They are all meant to eliminate meticulous job. Every language you use daily for automation may be used to generate highly-performant code. And it's reasonably easy too. I'll show you.
    </p>
    <h2>
Function call substitution with Python
    </h2>
    <table><tr>
    <td>
    <pre><span id="slides_recursive_1" style="display:block"><div style="color:#994466"><b>Step 1. Benchmark C source code</b></div>
1.
    </span><span id="slides_recursive_2" style="display:none"><div style="color:#992244"><b>Step 2. LLVM assembly language</b></div>
2.
    </span><span id="slides_recursive_3" style="display:none"><div style="color:#881122"><b>Step 3. LLVM after the call replacement</b></div>
3.
    </span><span id="slides_recursive_4" style="display:none"><div style="color:#881122"><b>Step 4. Native optimized assembly</b></div>
4.
    </span></pre>
    </td>
    </td></tr></table>
    <p style="text-align:right">
    <button type="button" onclick="next('slides_recursive')">Next step</button>
    </p>
    <p>
...
    </p>

    <p>
The numbers:
    </p>
    <ol>
    <li>
...
    </li>
    <li>
...
    </li>
    <li>
<b>...</b>
    </li>
    </ol>
    <canvas id="results" width=700 height=500></canvas>
    <script language="JavaScript">
    init_results();
    </script>
    <p>
...
    </p>
    <p>
...
    </p>
    <br>
    <p style="font-family: sans-serif; font-size: 14pt;">
All the measurements conducted on Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz, the code is compiled with clang version 3.8.0-2ubuntu4 and g++ 5.4.0 with -march=native -O2. The source code for the benchmark is available on <a href="https://github.com/akalenuk/wordsandbuttons/tree/master/drafts/python_to_llvm">Github</a>.
    </p>

    <p class="footer">
There are more words and buttons on <a href="index.html">wordsandbuttons.online</a>.
    </p>
    </center>
  </body>
</html>
