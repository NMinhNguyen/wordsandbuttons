<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Challenge your performance intuition with C++ magic squares</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.comment {
    font-size: 14pt;
    text-align:center;
    font-family: sans-serif;
    padding-bottom: 24pt;
}

.footer {
    margin-top: 64pt;
    padding-bottom: 32pt;
    font-family: sans-serif;
    font-size: 14pt;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
    width: 360pt;
}

.code {
    background-color: #ccccff;
}

.code_piece {
    background-color: #ccccff;
    font-family: monospace;
    padding-left: 4pt;
    padding-right: 4pt;
}


table {
    text-align: center;
    border-width: 0pt;
}

td {
    padding: 6pt 12pt 6pt 12pt;
    font-size: 16pt;
    border: 1px solid black;
}

button{
    width: 304pt;
    height: 42pt;
    margin-left:4pt;
    margin-right:4pt;
    font-size: 18pt;
}

    </style>
    <script language="JavaScript">
var slider_set = [false, false, false, false,  false, false, false, false,  false, false];
var slider_true_xs = [
    1.0 / (1.0 + 0.9) * 512, 
    0, 
    0, 
    0,  
    0, 
    0, 
    0, 
    0,  
    0, 
    0];
var slider_user_xs = [255, 255, 255, 255,  255, 255, 255, 255,  255, 255];
var slider_xs = [255, 255, 255, 255,  255, 255, 255, 255,  255, 255];

var slider_down = false;

function comment_on_slider(no){
    var left = document.getElementById("left_" + (no + 1));
    var right = document.getElementById("right_" + (no + 1));
    var x = slider_xs[no]
    var xl = x;
    var xr = 511 - x;
    if(x < 255){
        left.style.backgroundColor = "#" + (Math.round(xl)).toString(16) + "ff" + (Math.round(xl)).toString(16);
        right.style.backgroundColor = "#ff" + (Math.round(xl)).toString(16) + (Math.round(xl)).toString(16);
    }else{
        right.style.backgroundColor = "#" + (Math.round(xr)).toString(16) + "ff" + (Math.round(xr)).toString(16);
        left.style.backgroundColor = "#ff" + (Math.round(xr)).toString(16) + (Math.round(xr)).toString(16);
    }
    
    var comment = document.getElementById("comment_" + (no + 1));
    if(xl > xr){
        if(xl > 20*xr){
            comment.innerHTML = "Right is more than 20 times faster!";
        }else if(xl > 10*xr){
            comment.innerHTML = "Right is more than 10 times faster!";
        }else if(xl > 5*xr){
            comment.innerHTML = "Right is more than 5 times faster!";
        }else if(xl > 3*xr){
            comment.innerHTML = "Right is more than 3 times faster!";
        }else if(xl > 2*xr){
            comment.innerHTML = "Right is more than 2 times faster!";
        }else if(xl > 1.5*xr){
            comment.innerHTML = "Right is more than 50% faster.";
        }else if(xl > 1.25*xr){
            comment.innerHTML = "Right is more than 25% faster.";
        }else if(xl > 1.1*xr){
            comment.innerHTML = "Right is more than 10% faster.";
        }else{
            comment.innerHTML = "Right is slightly faster.";
        }
    }else if(xr > xl){
        if(xr > 20*xl){
            comment.innerHTML = "Left is more than 20 times faster!";
        }else if(xr > 10*xl){
            comment.innerHTML = "Left is more than 10 times faster!";
        }else if(xr > 5*xl){
            comment.innerHTML = "Left is more than 5 times faster!";
        }else if(xr > 3*xl){
            comment.innerHTML = "Left is more than 3 times faster!";
        }else if(xr > 2*xl){
            comment.innerHTML = "Left is more than 2 times faster!";
        }else if(xr > 1.5*xl){
            comment.innerHTML = "Left is more than 50% faster.";
        }else if(xr > 1.25*xl){
            comment.innerHTML = "Left is more than 25% faster.";
        }else if(xr > 1.1*xl){
            comment.innerHTML = "Left is more than 10% faster.";
        }else{
            comment.innerHTML = "Left is slightly faster.";
        }  
            
    }else if(xl == xr){
        comment.innerHTML = "They are equally fast.";
    }
}

function position_slider(no, client_x){
    if(!slider_set[no]){
        var slider = document.getElementById("slider_" + (no + 1));    
        var canvas_rect = slider.getBoundingClientRect();
        var x = client_x - canvas_rect.left - 48;
        if(x < 16)
            x = 16;
        if(x > 511 - 16)
            x = 511 - 16;
        slider_xs[no] = x;
                        
        comment_on_slider(no);
    }
}

function init_slider(no){
    draw_slider(no);
    var slider = document.getElementById("slider_" + (no + 1));
    
    slider.addEventListener('mouseleave', function(e){
        slider_down = false;
    }, false);
    
    slider.addEventListener('mouseup', function(e){
        slider_down = false;
    }, false);
    
    slider.addEventListener('mousedown', function(e){
        slider_down = true;
        position_slider(no, e.clientX);
        draw_slider(no);
    }, false);
    
    slider.addEventListener('mousemove', function(e){
        if(slider_down){
            position_slider(no, e.clientX);
            draw_slider(no);
        }
    }, false);
}

function draw_slider(no){
    ctx = document.getElementById("slider_" + (no + 1)).getContext("2d");
    x = slider_xs[no] + 48 + 0.5;
    
    ctx.clearRect(0, 0, 608, 128);
	ctx.beginPath();
	ctx.moveTo(64.5-16, 32.5);
	ctx.lineTo(0.5 + 16, 127.5 - 32);
	ctx.lineTo(607.5 - 16, 127.5 - 32);
	ctx.lineTo(607.5 - 64 + 16, 32.5);
    ctx.lineTo(64.5-16, 32.5);
	ctx.strokeStyle="#000000";
    ctx.stroke();
    ctx.closePath(); 
    ctx.fillStyle="#999999";
  	ctx.fill();
  	
	if(slider_set[no]){
    	x_red = slider_user_xs[no] + 48 + 0.5;
	    ctx.beginPath();
	    ctx.moveTo(x_red, 0);
	    ctx.lineTo(x_red - 64, 127);
	    ctx.lineTo(x_red + 64, 127);
	    ctx.lineTo(x_red, 0);
	    ctx.strokeStyle="#660000";
        ctx.stroke();
        ctx.closePath();
        ctx.fillStyle="#ffcccc";
    	ctx.fill();
    }
	
  	ctx.beginPath();
	ctx.moveTo(x, 0);
	ctx.lineTo(x - 64, 127);
	ctx.lineTo(x + 64, 127);
	ctx.lineTo(x, 0);
	ctx.strokeStyle="#000000";
    ctx.stroke();
    ctx.closePath(); 
    ctx.fillStyle="#cccccc";
  	ctx.fill();
}

function reveal(no){
    slider_set[no] = true;
    slider_user_xs[no] = slider_xs[no];
    slider_xs[no] = slider_true_xs[no];
    draw_slider(no);
    comment_on_slider(no);
    document.getElementById("the_truth_" + (no + 1)).style.display = "block";
    document.getElementById("button_" + (no + 1)).style.display = "none";   
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Challenge your performance intuition with C++ magic squares
    </h1>
    <p>
This was supposed to be a five minute interview question. I came up with it on Thursday, then spent a night looking for a good answer. Then the other night. Then the Saturday morning. Then it finally occurred to me that it might not work terribly well on an interview.
    </p>
    <p>
But it's still a great problem to fiddle with. And it goes like this.
    </p>
    <p>
Here is a magic square:
    </p>
    <table><tr>
    <td>8</td><td>3</td><td>4</td>
    </tr><tr>
    <td>1</td><td>5</td><td>9</td>
    </tr><tr>
    <td>6</td><td>7</td><td>2</td>
    </tr></table>
    <p>
It has all the numbers from 1 to 9 each exactly once. The sum in every row is 15. The sum in every column is 15. And the sum in both diagonals is, of course, also 15. We can write it as a 9-character string like this: <span class="code">"834159672"</span>.
    </p>
    <p>
The problem: propose a function that tells if a 3x3 square written as a string of digits is magic or not. And (sic!) does it in the most effective manner.
    </p>
    <p>
I also came up with this simple measuring code. It has no dependencies, and it's C++11 standard compliant, so it runs in basically every environment.
    </p>
    <pre style="background-color: #bbbbff;">
#include &lt;iostream&gt;
#include &lt;chrono&gt;

using namespace std;

// Here you should implement your 
// magic checker. It should return 
// true if the square is magic, 
// false otherwise.
//
//                8 1 6    this is
// "816357492" =  3 5 7    a magic
//                4 9 2    square
//
bool check_if_magic(const std::string& square)
{
  // add your code here 
  // (or above if you need global stuff)
  
  
  
  
  return false;
}

// this generates all possible combinations 
// of 1-9 digits that may or may not 
// form a magic square
static string buffer = "000000000";
void generate_or_check(int index_or_check = 8)
{
  if(index_or_check == -1){
    if(check_if_magic(buffer))
      cout &lt;&lt; buffer &lt;&lt; " ";
    return;
  }

  for(auto i = 1u; i &lt; 10; ++i){
    buffer[index_or_check] = '0' + i;
    generate_or_check(index_or_check-1);
  }
}

// this runs the generator and measures time
int main()
{
  auto start = std::chrono::system_clock::now();
  generate_or_check();
  auto end = std::chrono::system_clock::now();
  chrono::duration&lt;double&gt; 
    difference = end - start;
  cout &lt;&lt; difference.count() &lt;&lt; "\n\n";
}    
    </pre>
    <p>
I ran it with an empty checker to see how much time the generator takes. Then ran eleven different solutions three times each, and picked the best time for every solution. Now I know what works and what not.
    </p>
    <p>
Let's play a game. There will be ten rounds, each round is a match between two solutions. Or rather between their execution times. Using your intuition and best judgment, please estimate their relative effectiveness. Use the slider below the code samples.
    </p>
    <p class="comment">
My times are measured on Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz. <br>All the code compiled with g++ 5.4.0 -std=c++11 -O2.
    </p>
    
    
    <h2>
Round 1. Direct solution vs. the oddity heuristic
    </h1>
    <p>
The direct solution would be to literally check every row, column, and diagonal sum and then assert that all the numbers are there. We don't have to parse actual numbers, we can go with ASCII codes just fine. Also the simplest way to check is the string is a permutation of digits is to make a simple binary map and check if it can be properly filled with the input. Since we are here for the performance, we would use a single <span class="code_piece">uint_fast64_t</span> instead of a real map.
    </p>
    <p>
The heuristic proposed is meant to end the function as early as possible. It is based on a fact that in a magic square the corner values are always even and the rest are odd. If one of the numbers fails to pass the oddity test, then there is no point in the full magicness check at all. Also, as you can see, this heuristic is rather effective. On random numbers it narrows down our cases with a pretty good 2<sup>9</sup> to 1 ratio. So only one string in 512 will get to the actual check. Well, technically our numbers are not entirely random, we have more odds than evens, but still. 
    </p>
    <p>
Now place your bets!
    </p>
    <table><tr>
    <td id="left_1">
    <pre>
auto c15 = '5' * 3;
uint_fast64_t ideal_char_map = 
    static_cast&lt;uint_fast64_t&gt;(0x1FF) &lt;&lt; 49;
uint_fast64_t char_map_one = 1u;

bool check_if_magic(const std::string& sq)
  {
  if ((sq[0] + sq[1] + sq[2] != c15)
    || (sq[3] + sq[4] + sq[5] != c15)
    || (sq[6] + sq[7] + sq[8] != c15)

    || (sq[0] + sq[3] + sq[6] != c15)
    || (sq[1] + sq[4] + sq[7] != c15)
    || (sq[2] + sq[5] + sq[8] != c15)

    || (sq[0] + sq[4] + sq[8] != c15)
    || (sq[2] + sq[4] + sq[6] != c15))
    return false;

  auto char_map = ideal_char_map;
  for(auto i = 0u; i &lt; 9; ++i)
    char_map ^= char_map_one &lt;&lt; sq[i]; 
  if (char_map != 0)
    return false;

  return true;
  }
    </pre>
    </td>
    <td id="right_1">
    <pre>
auto c15 = '5' * 3;
uint_fast64_t ideal_char_map = 
    static_cast&lt;uint_fast64_t&gt;(0x1FF) &lt;&lt; 49;
uint_fast64_t char_map_one = 1u;

bool check_if_magic(const std::string& sq)
  {
  <b>if ( (sq[0] & 1) != 0 || (sq[1] & 1) == 0 
    || (sq[2] & 1) != 0 || (sq[3] & 1) == 0
    || (sq[4] & 1) == 0 
    || (sq[5] & 1) == 0 || (sq[6] & 1) != 0 
    || (sq[7] & 1) == 0 || (sq[8] & 1) != 0)
    return false;</b>
  
  if ((sq[0] + sq[1] + sq[2] != c15)
    || (sq[3] + sq[4] + sq[5] != c15)
    || (sq[6] + sq[7] + sq[8] != c15)

    || (sq[0] + sq[3] + sq[6] != c15)
    || (sq[1] + sq[4] + sq[7] != c15)
    || (sq[2] + sq[5] + sq[8] != c15)

    || (sq[0] + sq[4] + sq[8] != c15)
    || (sq[2] + sq[4] + sq[6] != c15))
    return false;

  auto char_map = ideal_char_map;
  for(auto i = 0u; i &lt; 9; ++i)
    char_map ^= char_map_one &lt;&lt; sq[i]; 
  if (char_map != 0)
    return false;

  return true;
  }           
    </pre>
    </td></tr></table>
    <canvas id="slider_1" width=608 height=128></canvas> 
    <p class="comment" id="comment_1">
They are equally fast.
    </p>
    <button type="button" onclick="reveal(0)" id="button_1">Reveal the truth</button>
    <p id="the_truth_1" style="display:none;">
The right is only slightly more than 10% faster. The thing is, although this heuristic is great in narrowing, it is rather heavy by itself. We gain some, we lose some.
    </p>
    <script language="JavaScript">
    init_slider(0);
    </script>
    
    



    <p class="footer">
    There are more words and buttons on <a href="index.html">wordsandbuttons.online</a>.<br>
    Also please follow us on <a href="https://twitter.com/wordsandbuttons">Twitter</a>.
    </p>
    </center>
  </body>
</html>
