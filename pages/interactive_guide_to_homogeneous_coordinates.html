<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Interactive guide to homogeneous coordinates</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.quote {
    font-size: 18pt;
    text-align: left;
    font-family: italic;
    padding-left: 65pt;
    text-indent: -9pt;
    width: 440pt;
}

.footer {
    margin-top: 64pt;
    padding-bottom: 32pt;
    font-family: sans-serif;
    font-size: 14pt;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
}

.code {
    background-color: #bbbbff;
}

.code_piece {
    background-color: #bbbbff;
    font-family: monospace;
    padding-left: 2pt;
    padding-right: 2pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

input[type="text"] {
    width: 100pt;
    height: 22pt;
    margin: 8pt 8pt 8pt 8pt;
    padding-left: 3pt;
    font-size: 16pt;
}

button {
    width: 100pt;
    height: 22pt;
    margin-left:8pt;
    margin-right:8pt;
    font-size: 16pt;
}

    </style>
    <script language="JavaScript">

function client_to_x(client_x){
    return (client_x - 256.) / 32.;
}

function client_to_y(client_y){
    return (256 - client_y) / 32.;
}

function x_to_client(x){
    return x * 32. + 256;
}

function y_to_client(y){
    return 256 - y * 32.;
}

var point_x = 0;
var point_y = 0;

var pick_a_point = null;
var slide_a_w = null;
var translation = null;

function init_pick_a_point(){
    pick_a_point = document.getElementById("pick_a_point");
    pick_a_point_draw(256, 256);
    
    pick_a_point.addEventListener('mousemove', function(e){
        if(point_x == 0 && point_y == 0)
    	    pick_a_point_draw(e.clientX, e.clientY);
    }, false);

    pick_a_point.addEventListener('mousedown', function(e){
        var canvas_rect = pick_a_point.getBoundingClientRect();
        point_x = Math.round(client_to_x(e.clientX - canvas_rect.left)*10)/10;
        point_y = Math.round(client_to_y(e.clientY - canvas_rect.top)*10)/10;
	    pick_a_point_draw(e.clientX, e.clientY);
	    document.getElementById("after_the_point_is_picked").style.display = "block";
        document.getElementById("to_fill_with_numbers").innerHTML = 
"Your point (" + point_x + ", " + point_y + ") is the same as " +
"(" + point_x + ", " + point_y + ", 1). <br>" +
"Or (" + point_x*2 + ", " + point_y*2 + ", 2).<br>" +
"Or (" + point_x*0.5 + ", " + point_y*0.5 + ", 0.5). <br>" +
"Or even (" + point_x*1000 + ", " + point_y*1000 + ", 1000). <br>" +
"This is all the same point. ";
       transform();
    }, false);
}

function pick_a_point_draw(client_x, client_y){
    // coordiantes correction
    var canvas_rect = pick_a_point.getBoundingClientRect();
    client_x -= canvas_rect.left;
    client_y -= canvas_rect.top;

    var pick_a_point_context = pick_a_point.getContext("2d"); 
    pick_a_point_context.font = "16px sans-serif";
    // background
    pick_a_point_context.fillStyle="#eeeeee";
	pick_a_point_context.fillRect(0,0,512,512);
	
	// selection
    pick_a_point_context.beginPath();
	pick_a_point_context.moveTo(client_x, 256);
	pick_a_point_context.lineTo(client_x, client_y);
	pick_a_point_context.moveTo(256, client_y);
	pick_a_point_context.lineTo(client_x, client_y);
	pick_a_point_context.strokeStyle="#dd6644";
    pick_a_point_context.stroke();
    pick_a_point_context.fillStyle="#dd6644";
    pick_a_point_context.fillText(client_to_x(client_x).toFixed(1) + ", " + client_to_y(client_y).toFixed(1), client_x + 4, client_y + 16);
    pick_a_point_context.closePath();
    
	// grid
 	pick_a_point_context.beginPath();
	pick_a_point_context.moveTo(0, 256);
	pick_a_point_context.lineTo(512, 256);
	pick_a_point_context.lineTo(500, 251);
	pick_a_point_context.moveTo(512, 256);
	pick_a_point_context.lineTo(500, 261);
	pick_a_point_context.moveTo(256, 512);
	pick_a_point_context.lineTo(256, 0);
	pick_a_point_context.lineTo(251, 12);
	pick_a_point_context.moveTo(256, 0);
	pick_a_point_context.lineTo(261, 12);
    pick_a_point_context.fillStyle="#000000";
	for(var i = -7; i <= 7; i++){
	    pick_a_point_context.moveTo(256 + i*32, 256);
		pick_a_point_context.lineTo(256 + i*32, 251);
		pick_a_point_context.fillText(i, 256 + i*32 + 4, 256 + 16);
	    pick_a_point_context.moveTo(256, 256 - i*32);
		pick_a_point_context.lineTo(261, 256 - i*32);
		pick_a_point_context.fillText(i, 261, 256 - i*32 + 16);
	}
	
	pick_a_point_context.strokeStyle="#000000";
    pick_a_point_context.stroke();
    pick_a_point_context.closePath();
}

function transform(){
    var w = Number(document.getElementById("proposed_w").value);
    if(w == NaN)
        w = 1;
    if(w == 0){
        document.getElementById("after_the_w_proposed").style.display = "block";
        document.getElementById("transformed").innerHTML = "<br>No transformation available!"
        document.getElementById("to_hide_on_transform").style.display = "none";
    }else{
        document.getElementById("transformed").innerHTML = 
"<br>(" + point_x + ", " + point_y + ") = " + 
"(" + point_x * w + ", " + point_y * w + ", " + w + ")";  
    }
}

function skip_transform(){
        document.getElementById("after_the_w_proposed").style.display = "block";
        document.getElementById("transformed").innerHTML = "<br>When it's 0, then there is no transformation available!"
        document.getElementById("to_hide_on_transform").style.display = "none";
}

function init_slide_a_w(){
    slide_a_w = document.getElementById("slide_a_w");
    slide_a_w_draw(256);
    
    slide_a_w.addEventListener('mousemove', function(e){
    	slide_a_w_draw(e.clientX);
    }, false);
}

function slide_a_w_draw(client_x){
    // coordiantes correction
    var canvas_rect = slide_a_w.getBoundingClientRect();
    client_x -= canvas_rect.left;

    var slide_a_w_context = slide_a_w.getContext("2d"); 
    slide_a_w_context.font = "16px sans-serif";
    // background
    slide_a_w_context.fillStyle="#eeeeee";
	slide_a_w_context.fillRect(0,0,512,512);
	
	// selection
	var w = (client_x - 256) / 32;
	var canvas_x = x_to_client(point_x / w);
	var canvas_y = y_to_client(point_y / w);
    slide_a_w_context.beginPath();
	slide_a_w_context.moveTo(x_to_client(point_x * 100), y_to_client(point_y * 100));
	slide_a_w_context.lineTo(x_to_client(point_x * -100), y_to_client(point_y * -100));
	slide_a_w_context.strokeStyle="#dd6644";
    slide_a_w_context.stroke();
    slide_a_w_context.fillStyle="#dd6644";
    slide_a_w_context.fillText(point_x.toFixed(1) + ", " + point_y.toFixed(1) + ", " + w.toFixed(3), x_to_client(point_x / w) + 4, y_to_client(point_y / w) + 16);
    slide_a_w_context.fillText("w = " + w.toFixed(3), 32, 480); 
    slide_a_w_context.closePath();
    
    
	// grid
 	slide_a_w_context.beginPath();
	slide_a_w_context.moveTo(0, 256);
	slide_a_w_context.lineTo(512, 256);
	slide_a_w_context.lineTo(500, 251);
	slide_a_w_context.moveTo(512, 256);
	slide_a_w_context.lineTo(500, 261);
	slide_a_w_context.moveTo(256, 512);
	slide_a_w_context.lineTo(256, 0);
	slide_a_w_context.lineTo(251, 12);
	slide_a_w_context.moveTo(256, 0);
	slide_a_w_context.lineTo(261, 12);
    slide_a_w_context.fillStyle="#000000";
	for(var i = -7; i <= 7; i++){
	    slide_a_w_context.moveTo(256 + i*32, 256);
		slide_a_w_context.lineTo(256 + i*32, 251);
		slide_a_w_context.fillText(i, 256 + i*32 + 4, 256 + 16);
	    slide_a_w_context.moveTo(256, 256 - i*32);
		slide_a_w_context.lineTo(261, 256 - i*32);
		slide_a_w_context.fillText(i, 261, 256 - i*32 + 16);
	}
	
	slide_a_w_context.strokeStyle="#000000";
    slide_a_w_context.stroke();
    slide_a_w_context.closePath();
}

function init_translation(){
    translation = document.getElementById("translation");
    translation_draw(256, 256);
    
    translation.addEventListener('mousemove', function(e){
    	translation_draw(e.clientX, e.clientY);
    }, false);
}

function translation_draw(client_x, client_y){
    // coordiantes correction
    var canvas_rect = translation.getBoundingClientRect();
    client_x -= canvas_rect.left;
    client_y -= canvas_rect.top;
   	var x = client_to_x(client_x);
	var y = client_to_y(client_y);
    
    var translation_context = translation.getContext("2d"); 
    translation_context.font = "16px sans-serif";
    // background
    translation_context.fillStyle="#eeeeee";
	translation_context.fillRect(0,0,512,512);
	
	// the connection
	translation_context.beginPath();
	translation_context.moveTo(x_to_client(1), y_to_client(1));
	translation_context.lineTo(x_to_client(x), y_to_client(y));
    translation_context.moveTo(x_to_client(1 + 1), y_to_client(1));
	translation_context.lineTo(x_to_client(x + 1), y_to_client(y));
	translation_context.moveTo(x_to_client(1 + 1), y_to_client(1 + 1));
	translation_context.lineTo(x_to_client(x + 1), y_to_client(y + 1));
	translation_context.moveTo(x_to_client(1), y_to_client(1 + 1));
	translation_context.lineTo(x_to_client(x), y_to_client(y + 1));
	translation_context.strokeStyle="#eeaa88";
    translation_context.stroke();
    translation_context.closePath();
    
	// original cube
	translation_context.beginPath();
	translation_context.moveTo(x_to_client(1), y_to_client(1));
	translation_context.lineTo(x_to_client(1 + 1), y_to_client(1));
	translation_context.lineTo(x_to_client(1 + 1), y_to_client(1 + 1));
	translation_context.lineTo(x_to_client(1), y_to_client(1 + 1));
	translation_context.lineTo(x_to_client(1), y_to_client(1));
	translation_context.strokeStyle="#999999";
    translation_context.stroke();
    translation_context.closePath();    
    
	// translation
	translation_context.beginPath();
	translation_context.moveTo(x_to_client(x), y_to_client(y));
	translation_context.lineTo(x_to_client(x + 1), y_to_client(y));
	translation_context.lineTo(x_to_client(x + 1), y_to_client(y + 1));
	translation_context.lineTo(x_to_client(x), y_to_client(y + 1));
	translation_context.lineTo(x_to_client(x), y_to_client(y));
	translation_context.strokeStyle="#dd6644";
    translation_context.stroke();
    translation_context.closePath();    
    translation_context.fillStyle="#dd6644";
    translation_context.fillText("x' = x + a, where a = " + x.toFixed(1), 32, 460);
    translation_context.fillText("y' = y + b, where b = " + y.toFixed(1), 32, 480);
     
	// grid
 	translation_context.beginPath();
	translation_context.moveTo(0, 256);
	translation_context.lineTo(512, 256);
	translation_context.lineTo(500, 251);
	translation_context.moveTo(512, 256);
	translation_context.lineTo(500, 261);
	translation_context.moveTo(256, 512);
	translation_context.lineTo(256, 0);
	translation_context.lineTo(251, 12);
	translation_context.moveTo(256, 0);
	translation_context.lineTo(261, 12);
    translation_context.fillStyle="#000000";
	for(var i = -7; i <= 7; i++){
	    translation_context.moveTo(256 + i*32, 256);
		translation_context.lineTo(256 + i*32, 251);
		translation_context.fillText(i, 256 + i*32 + 4, 256 + 16);
	    translation_context.moveTo(256, 256 - i*32);
		translation_context.lineTo(261, 256 - i*32);
		translation_context.fillText(i, 261, 256 - i*32 + 16);
	}
	
	translation_context.strokeStyle="#000000";
    translation_context.stroke();
    translation_context.closePath();
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Interactive guide to homogeneous coordinates
    </h1>
    <p>
Why would you care about some homogeneous coordinates, whatever they are? Well, if you work with geometry: 3D-graphics, image processing, physical simulation, the answer is obvious. Knowing the mathematics behind your framework of choice lets you write more efficient code. I once got to speed up one picture bending .NET application by simply re-implementing some primitive operations that gave me roughly 100 times performance boost.
    </p>
    <p>
But even if you don’t work with geometry at all, you still might benefit from learning the concept of homogeneous coordinates. This is the one rare example of mathematical magic when a small complication benefits in enormous simplification. One little obscurity pays off in terms of unification and homogenization.
    </p>
    <p>
I think, learning this particular piece of geometry is a valuable experience in its own right. And you know how it works. More experience, higher level, better loot.
    </p>
    <h2>
The complication
    </h2>
    <p>
In our usual Cartesian coordinate system, a point on a plane is set by a pair of numbers (x<sub>c</sub>, y<sub>c</sub>). Please pick a point to continue.
    </p>
    <canvas id="pick_a_point" width=512 height=512></canvas> 
    <script language="JavaScript">
    init_pick_a_point();
    </script>
    <div id="after_the_point_is_picked" style="display:none;">
        <p>
Right! 
        </p>
        <p>
Now in homogeneous coordinates points on a plane are set by a tuple of 3 numbers (x<sub>h</sub>, y<sub>h</sub>, w<sub>h</sub>).
        </p>
        <p>
That's a bit unusual, but if a point is taken from the cartesian space, you can transform a homogeneous tuple into cartesian pair as simple as this:
        </p>
        <p>
x<sub>c</sub> = x<sub>h</sub> / w<sub>h</sub>
            <br>
y<sub>c</sub> = y<sub>h</sub> / w<sub>h</sub>
        </p>
        <p>
Although, there is no one and only way to transform a point from cartesian to homogeneous coordinates. You can pick any (almost) value for w<sub>h</sub> and it would work. 
        </p>
        <p>
        <span id="to_fill_with_numbers">
        </span>
        </p>
        <p>
Here is a coordinate transformer. It will transform your point into homogeneous coordinates for the (almost) every w<sub>h</sub> you propose.
        </p>
        <form>
Please enter w<sub>h</sub>:
        <input type="text" id="proposed_w" value="1">
        <button type="button" onclick="transform()">Transform</button>
        <button type="button" onclick="skip_transform()">No, thanks</button>
        <span id="transformed">
        </span>
        </form>
        <p id="to_hide_on_transform">
But it wouldn't work for all the possible numbers. To continue, please propose the w<sub>h</sub> for which the point could not be transformed.
        </p>
    </div>
    <div id="after_the_w_proposed" style="display:none;">
        <p>
Exactly! 
        </p>
        <p>
Cartesian coordinates are just the first two numbers of homogeneous coordinates divided by the third. So if it is 1, then homogeneous coordinates are basically the same thing as Cartesian. But the smaller w<sub>h</sub> gets, the further the point in Cartesian coordinates travels from the null. 
        </p>
        <canvas id="slide_a_w" width=512 height=512></canvas> 
        <script language="JavaScript">
        init_slide_a_w();
        </script>
        <p>
That’s all rather simple until one moment. What if the fourth coordinate is 0?
        </p>
        <p>
Intuition tells, that it should be further from the 0 than every other point. Every other point in Euclidean space that is. Homogeneous coordinates indeed denote points not only in Euclidean or, more general, affine space, but in projective space that includes and expands affine one.
        <p>
        <p>      
Points from the projective space may lie in the Euclidean space or may be infinitely far from any point of it. If w<sub>h</sub> is 0 then it's the latter. If not, then whatever w<sub>h</sub> is, it's the former.
        </p>
        <p>
From the pragmatic point of view, this lets us, for instance, compose a 3D-scene in a manner that every object that can be reached would fit in affine space with the coordinates (x, y, z, 1), and all the objects that can never be reached will belong to its projective extension (x, y, z, 0).
        </p>
        <p>
So if you do work with 3D graphics, you might notice that it is quite common to write 3D points as a tuple of 4 numbers. The usual question here is: “what does that fourth coordinate stand for?” And the usual answer is: “Just set it to 1 and hope you wouldn’t screw anything!” Well, now you know what the fourth coordinate actually stands for.
        </p>
        <p>
It is also common to refer points from projective extension as a general direction and not a specific point in Euclidean space. A ray that starts at null and has no length has no end, only the direction. You might even have heard about it being called a vector as opposed to a point. This is not technically correct as, of course, any point is a vector in a corresponding vector space. But this still might be a useful naming convention if you are not into the real vector algebra.
        </p>
        <p>
Living in a projective space gives you more options. You can denote points that are unheard of in the Euclidean one. But that’s not all it is good for. In fact, we are only starting to get into the benefits.
        </p>
        <h2>
1. In projective space central and parallel projections are the same
        </h2>
        <p>
There are two kinds of projection in Euclidean space: central and parallel. Central projection is what makes the perspective, so the closer things seem bigger, and that’s what we use in video games to render a 3D scene into a flat picture on a screen. The parallel projection preserves proportions so that’s what we usually use in CAD systems to show bolts and nuts on drawings.        
        </p>
        <p>
In projective space they are the same. You see, in affine space you can set a center for a central projection very-very far away from the scene you want to render. This will make disproportion very small. But in projective space you can hurl a center infinitely far — further away than any point in affine space at all — and the disproportion will disappear completely.
        </p>
        <p>
So bear in mind, if you want to make a game about zombies who happen to be CAD engineers, you don’t have to implement both kinds of projections. Just set the projection central point to (x, y, z, 0) and this will automatically turn it into parallel.
        </p>
        <h2>
2. All the surfaces described as an equation on degree n are the same
        </h2>
        <p>
I remember on my first year in college we were studying quadric surfaces and one of the exercises allegedly made up to help us learn their classification was to make an album. It was 17 sheets of paper with different graphics and formulas sewed together only to be briefly examined by the professor and thrown away a day after. You might imagine we were not fond of this activity.
        </p>
        <p>
Now in projective space this excercise would have been much more environmental friendly. That’s because in homogenous coordinates all the algebraic surfaces are homogenous too. This means every piece of a polynomial that defines the surface has the same degree. It may contain different variables with different degrees of their own, but they all magically add up to the very same degree for every element in the sum.
        </p>
        <p>
And this means only one drawing with one formula to be drawn and thrown away and not seventeen. That should sum up to a couple of dead trees through the years.
        </p>
        <h2>
3. All projective transformations are a matrix (yes, singular)
        </h2>
        <p>
Geometric transformations are something that happens to a point. They are basically functions (x', y') = f(x, y). If you want to apply the transofmrmation to some object, most of the time you would have to represent it with points and then apply the transformation to each of them.
        </p>
        <p>
Sometime this gets computationally heavy. For instance, transforming 3 000 x 4 000 pixels image would require 12 000 000 transformations. So looking for the fastest way to apply a transformation does make sense pragmatically.
        </p>
        <p>
Some of the most common transformations are: transtlation;
        </p>
        <canvas id="translation" width=512 height=512></canvas> 
        <script language="JavaScript">
        init_translation();
        </script>
    </div>
    
    <p class="footer">
    There are more words with buttons on <a href="">wordsandbuttons.com</a>.<br>
    Also please follow us on <a href="">Twitter</a> and on <a href="Facebook">Facebook</a>.
    </p>
    </center>
  </body>
</html>
