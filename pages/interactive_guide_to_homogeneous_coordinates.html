<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Interactive guide to homogeneous coordinates</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.formula {
    font-family: sans-serif;
    font-size: 15pt;
    font-style: italic;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

.footer {
    margin-top: 64pt;
    padding-bottom: 32pt;
    font-family: sans-serif;
    font-size: 16pt;
    text-align: left;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
}

table {
    border-width: 0pt;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    font-family: monospace;
    text-align: center;
}

table td {
    padding: 0pt 4pt 0pt 4pt;
    margin: 0 0 0 0;
    border-width: 0pt;
}

.brackets {
    font-size:48pt;
    padding-bottom:8pt;
    font-family: sans-serif;
    font-weight: 100;
    font-style: normal;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: center;
    font-family: sans-serif;
    width: 505pt;
    background-color: #eeee99;
}

input[type="text"] {
    width: 100pt;
    height: 22pt;
    margin: 8pt 8pt 8pt 8pt;
    padding-left: 3pt;
    font-size: 16pt;
}

button {
    width: 150pt;
    height: 26pt;
    margin-left:8pt;
    margin-right:8pt;
    font-size: 16pt;
}

input[type="radio"]{
    margin: 4pt 4pt 4pt 4pt;
}
    </style>
    <script language="JavaScript">

function client_to_x(client_x){
    return (client_x - 256.) / 64.;
}

function client_to_y(client_y){
    return (256 - client_y) / 64.;
}

function x_to_client(x){
    return x * 64. + 256;
}

function y_to_client(y){
    return 256 - y * 64.;
}

var point_x = 3;
var point_y = 2;

var pick_a_point = null;
var slide_a_w = null;
var translation = null;

function draw_grid_on(context){
    // grid
    context.beginPath();
    context.moveTo(0, 256);
    context.lineTo(512, 256);
    context.lineTo(500, 251);
    context.moveTo(512, 256);
    context.lineTo(500, 261);
    context.moveTo(256, 512);
    context.lineTo(256, 0);
    context.lineTo(251, 12);
    context.moveTo(256, 0);
    context.lineTo(261, 12);
    context.fillStyle="#000000";
    for(var i = -3; i <= 3; i++){
        context.moveTo(256 + i*64, 256);
        context.lineTo(256 + i*64, 251);
        context.fillText(i, 256 + i*64 + 4, 256 + 16);
        context.moveTo(256, 256 - i*64);
        context.lineTo(261, 256 - i*64);
        context.fillText(i, 261, 256 - i*64 + 16);
    }
    context.strokeStyle="#000000";
    context.stroke();
    context.closePath();
}

function write_the_point_value(){
    document.getElementById("to_fill_with_numbers").innerHTML =
    "The point (" + point_x + ", " + point_y + ") is the same as " +
    "(" + point_x + ", " + point_y + ", 1). <br>" +
    "Or (" + point_x*2 + ", " + point_y*2 + ", 2).<br>" +
    "Or (" + point_x*0.5 + ", " + point_y*0.5 + ", 0.5). <br>" +
    "Or even (" + point_x*1000 + ", " + point_y*1000 + ", 1000). <br>" +
    "This is all the same point. ";
}

function init_w(){
    document.getElementById("w").addEventListener('submit', function(e) {
        transform();
        e.preventDefault();
    }, false);
}

function init_pick_a_point(){
    pick_a_point = document.getElementById("pick_a_point");
    var canvas_rect = pick_a_point.getBoundingClientRect();
    client_x = canvas_rect.left + point_x * 64 + 256;
    client_y = canvas_rect.top + 256 - point_y * 64;
    pick_a_point_draw(0, 0, false);

    pick_a_point.addEventListener('mousemove', function(e){
        var canvas_rect = pick_a_point.getBoundingClientRect();
        if(e.buttons == 1){ // drag
            point_x = Math.round(client_to_x(e.clientX - canvas_rect.left)*10)/10;
            point_y = Math.round(client_to_y(e.clientY - canvas_rect.top)*10)/10;
            pick_a_point_draw(0, 0, false);
        }else{  // move
            pick_a_point_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        }
    }, false);

    pick_a_point.addEventListener('mousedown', function(e){
        var canvas_rect = pick_a_point.getBoundingClientRect();
        point_x = Math.round(client_to_x(e.clientX - canvas_rect.left)*10)/10;
        point_y = Math.round(client_to_y(e.clientY - canvas_rect.top)*10)/10;
        pick_a_point_draw(0, 0, false);
        write_the_point_value();
        transform();
        slide_a_w_draw(e.clientX);
    }, false);
}

function pick_a_point_draw(client_x, client_y, do_guides){
    var pick_a_point_context = pick_a_point.getContext("2d");
    pick_a_point_context.font = "16px sans-serif";
    // background
    pick_a_point_context.fillStyle="#eeeeee";
    pick_a_point_context.fillRect(0,0,512,512);

    // selection
    pick_a_point_context.beginPath();
    pick_a_point_context.setLineDash([2, 2]);
    pick_a_point_context.moveTo(x_to_client(point_x), 256);
    pick_a_point_context.lineTo(x_to_client(point_x), y_to_client(point_y));
    pick_a_point_context.moveTo(256, y_to_client(point_y));
    pick_a_point_context.lineTo(x_to_client(point_x), y_to_client(point_y));
    pick_a_point_context.strokeStyle="#dd6644";
    pick_a_point_context.stroke();
    pick_a_point_context.fillStyle="#dd6644";
    pick_a_point_context.fillText(point_x.toFixed(1) + ", " + point_y.toFixed(1), x_to_client(point_x) + 4, y_to_client(point_y) + 16);
    pick_a_point_context.setLineDash([]);
    pick_a_point_context.closePath();
    
    if(do_guides){
        pick_a_point_context.beginPath();
        pick_a_point_context.setLineDash([4, 4]);
        pick_a_point_context.moveTo(client_x, client_y);
        pick_a_point_context.lineTo(x_to_client(point_x), y_to_client(point_y));
        pick_a_point_context.strokeStyle="#dd6644";
        pick_a_point_context.stroke();
        pick_a_point_context.setLineDash([]);
        pick_a_point_context.closePath();
    }

    // grid
    draw_grid_on(pick_a_point_context);
}

function transform(){
    var w = Number(document.getElementById("proposed_w").value);
    if(w == NaN)
        w = 1;
    if(w == 0){
        document.getElementById("after_the_w_proposed").style.display = "block";
        document.getElementById("transformed").innerHTML = "<br>No transformation available!"
        document.getElementById("to_hide_on_transform").style.display = "none";
    }else{
        document.getElementById("transformed").innerHTML =
            "<br>(" + point_x + ", " + point_y + ") = " +
            "(" + point_x * w + ", " + point_y * w + ", " + w + ")";
    }
}

var slide_w = 1.0;

function init_slide_a_w(){
    slide_a_w = document.getElementById("slide_a_w");
    var canvas_rect = slide_a_w.getBoundingClientRect();
    slide_a_w_draw(canvas_rect.left + 32 + 256);

    slide_a_w.addEventListener('mousemove', function(e){
        var canvas_rect = slide_a_w.getBoundingClientRect();
        slide_a_w_draw(e.clientX - canvas_rect.left, true);
        if(e.buttons == 1){
            slide_w = point_x / client_to_x(e.clientX - canvas_rect.left);
            slide_a_w_draw(0, false);            
        }
    }, false);

    slide_a_w.addEventListener('mousedown', function(e){
        var canvas_rect = slide_a_w.getBoundingClientRect();
        slide_w = point_x / client_to_x(e.clientX - canvas_rect.left);
        slide_a_w_draw(0, false);
    }, false);
    
    slide_a_w.addEventListener('mouseleave', function(e){
        var canvas_rect = slide_a_w.getBoundingClientRect();
        slide_a_w_draw(0, false);
    }, false);
}

function slide_a_w_draw(client_x, is_moving){
    var slide_a_w_context = slide_a_w.getContext("2d");
    slide_a_w_context.font = "16px sans-serif";
    // background
    slide_a_w_context.fillStyle="#eeeeee";
    slide_a_w_context.fillRect(0,0,512,512);

    // selection
    var w;
    if(is_moving){
        w = point_x / client_to_x(client_x);
    }else{
        w = slide_w;
    }
    
    var canvas_x = x_to_client(point_x / w);
    var canvas_y = y_to_client(point_y / w);
      
    slide_a_w_context.beginPath();

    slide_a_w_context.moveTo(x_to_client(point_x * 100), y_to_client(point_y * 100));
    slide_a_w_context.lineTo(x_to_client(point_x * -100), y_to_client(point_y * -100));
    
    if(is_moving){
        slide_a_w_context.moveTo(x_to_client(point_x / w) - 10, y_to_client(point_y / w));
        slide_a_w_context.lineTo(x_to_client(point_x / w) + 10, y_to_client(point_y / w));
        slide_a_w_context.moveTo(x_to_client(point_x / w), y_to_client(point_y / w) - 10);
        slide_a_w_context.lineTo(x_to_client(point_x / w), y_to_client(point_y / w) + 10);
    }
    
    slide_a_w_context.moveTo(x_to_client(point_x / slide_w) - 10, y_to_client(point_y / slide_w));
    slide_a_w_context.lineTo(x_to_client(point_x / slide_w) + 10, y_to_client(point_y / slide_w));
    slide_a_w_context.moveTo(x_to_client(point_x / slide_w), y_to_client(point_y / slide_w) - 10);
    slide_a_w_context.lineTo(x_to_client(point_x / slide_w), y_to_client(point_y / slide_w) + 10);
    slide_a_w_context.strokeStyle="#dd6644";
    slide_a_w_context.stroke();
    slide_a_w_context.fillStyle="#dd6644";
    slide_a_w_context.fillText(point_x.toFixed(1) + ", " + point_y.toFixed(1) + ", " + w.toFixed(3), x_to_client(point_x / w) + 4, y_to_client(point_y / w) + 16);
    slide_a_w_context.fillText("w = " + w.toFixed(3), 32, 480);
    slide_a_w_context.closePath();

    // grid
    draw_grid_on(slide_a_w_context);
}


function draw_original_cube_on(context){
    // original cube
    context.beginPath();
    context.moveTo(x_to_client(1), y_to_client(1));
    context.lineTo(x_to_client(1 + 1), y_to_client(1));
    context.lineTo(x_to_client(1 + 1), y_to_client(1 + 1));
    context.lineTo(x_to_client(1), y_to_client(1 + 1));
    context.lineTo(x_to_client(1), y_to_client(1));
    context.strokeStyle="#999999";
    context.stroke();
    context.closePath();
}

var dx = 0.5;
var dy = 0.3;

function init_translation(){
    translation = document.getElementById("translation");
    translation_draw(0, 0, false);
        
    translation.addEventListener('mousedown', function(e){
        var canvas_rect = translation.getBoundingClientRect();
        dx = client_to_x(e.clientX - canvas_rect.left);
        dy = client_to_y(e.clientY - canvas_rect.top);
        translation_draw(0, 0, false);
    }, false);
    
    translation.addEventListener('mousemove', function(e){
        var canvas_rect = translation.getBoundingClientRect();
        if(e.buttons == 1){
            dx = client_to_x(e.clientX - canvas_rect.left);
            dy = client_to_y(e.clientY - canvas_rect.top);
            translation_draw(0, 0, false);
        }else{
            translation_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        }
    }, false);

    translation.addEventListener('mouseleave', function(e){
        var canvas_rect = translation.getBoundingClientRect();
        translation_draw(0, 0, false);
    }, false);
}

function translation_draw(client_x, client_y, do_new){
    if(do_new){
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);
    }else{
        var x = dx;
        var y = dy;    
    }

    var translation_context = translation.getContext("2d");
    translation_context.font = "16px sans-serif";
    // background
    translation_context.fillStyle="#eeeeee";
    translation_context.fillRect(0,0,512,512);

    // original cube
    draw_original_cube_on(translation_context);

    if(do_new){
        // the connection
        translation_context.beginPath();
        translation_context.setLineDash([2, 2]);
        translation_context.moveTo(x_to_client(1), y_to_client(1));
        translation_context.lineTo(x_to_client(x), y_to_client(y));
        translation_context.moveTo(x_to_client(1 + 1), y_to_client(1));
        translation_context.lineTo(x_to_client(x + 1), y_to_client(y));
        translation_context.moveTo(x_to_client(1 + 1), y_to_client(1 + 1));
        translation_context.lineTo(x_to_client(x + 1), y_to_client(y + 1));
        translation_context.moveTo(x_to_client(1), y_to_client(1 + 1));
        translation_context.lineTo(x_to_client(x), y_to_client(y + 1));
        translation_context.strokeStyle="#eeaa88";
        translation_context.stroke();
        translation_context.setLineDash([]);
        translation_context.closePath();
        
        // dx-dy cube
        translation_context.beginPath();
        translation_context.moveTo(x_to_client(dx), y_to_client(dy));
        translation_context.lineTo(x_to_client(dx + 1), y_to_client(dy));
        translation_context.lineTo(x_to_client(dx + 1), y_to_client(dy + 1));
        translation_context.lineTo(x_to_client(dx), y_to_client(dy + 1));
        translation_context.lineTo(x_to_client(dx), y_to_client(dy));
        translation_context.strokeStyle="#ff8866";
        translation_context.stroke();
        translation_context.closePath();
    }
    // translation
    translation_context.beginPath();
    translation_context.moveTo(x_to_client(x), y_to_client(y));
    translation_context.lineTo(x_to_client(x + 1), y_to_client(y));
    translation_context.lineTo(x_to_client(x + 1), y_to_client(y + 1));
    translation_context.lineTo(x_to_client(x), y_to_client(y + 1));
    translation_context.lineTo(x_to_client(x), y_to_client(y));
    translation_context.strokeStyle="#dd6644";
    translation_context.stroke();
    translation_context.closePath();
    translation_context.fillStyle="#dd6644";
    translation_context.fillText("x' = x + a, where a = " + (x-1).toFixed(1), 32, 460);
    translation_context.fillText("y' = y + b, where b = " + (y-1).toFixed(1), 32, 480);

    // grid
    draw_grid_on(translation_context);
}

function rotated_x(a, x, y){
    return Math.sin(a) * x + Math.cos(a) * y;
}

function rotated_y(a, x, y){
    return Math.cos(a) * x - Math.sin(a) * y;
}

function init_rotation(){
    rotation = document.getElementById("rotation");
    var canvas_rect = translation.getBoundingClientRect();
    rotation_draw(canvas_rect.left + 256 + 20, 0, false);

    rotation.addEventListener('mousemove', function(e){
        rotation_draw(e.clientX, e.clientY, true);
    }, false);

    rotation.addEventListener('mouseleave', function(e){
        var canvas_rect = translation.getBoundingClientRect();
        rotation_draw(canvas_rect.left + 256 + 20, 0, false);
    }, false);
}

function rotation_draw(client_x, client_y, do_new){
    // coordiantes correction
    var canvas_rect = rotation.getBoundingClientRect();
    client_x -= canvas_rect.left;
    var a = client_to_x(client_x) / 2;

    var rotation_context = rotation.getContext("2d");
    rotation_context.font = "16px sans-serif";
    // background
    rotation_context.fillStyle="#eeeeee";
    rotation_context.fillRect(0,0,512,512);

    var xs = [1., 2., 2., 1.];
    var ys = [1., 1., 2., 2.];
    var new_xs = [0, 0, 0, 0];
    var new_ys = [0, 0, 0, 0];
    for(var i = 0; i < 4; i++){
      new_xs[i] = rotated_x(a, xs[i], ys[i]);
      new_ys[i] = rotated_y(a, xs[i], ys[i]);
    }

    if(do_new){
        // the connection
        rotation_context.beginPath();
        rotation_context.setLineDash([2, 2]);
        for(var i = 0; i < 4; i++){
            rotation_context.moveTo(x_to_client(xs[i]), y_to_client(ys[i]));
            rotation_context.lineTo(x_to_client(new_xs[i]), y_to_client(new_ys[i]));
        }
        rotation_context.strokeStyle="#eeaa88";
        rotation_context.stroke();
        rotation_context.setLineDash([]);
        rotation_context.closePath();
    }

    // original cube
    draw_original_cube_on(rotation_context);

    // rotation
    rotation_context.beginPath();
    rotation_context.moveTo(x_to_client(new_xs[3]), y_to_client(new_ys[3]));
    for(var i = 0; i < 4; i++){
        rotation_context.lineTo(x_to_client(new_xs[i]), y_to_client(new_ys[i]));
    }
    rotation_context.strokeStyle="#dd6644";
    rotation_context.stroke();
    rotation_context.closePath();
    rotation_context.fillStyle="#dd6644";
    rotation_context.fillText("x' = sin(a) * x + cos(a) * y", 32, 440);
    rotation_context.fillText("y' = cos(a) * x - sin(a) * y", 32, 460);
    rotation_context.fillText("where a = " + a.toFixed(2), 32, 480);

    // grid
    draw_grid_on(rotation_context);
}

function init_scale(){
    scale = document.getElementById("scale");
    var canvas_rect = scale.getBoundingClientRect();
    scale_draw(canvas_rect.left + 256 + 96, canvas_rect.top + 256 - 64, false);

    scale.addEventListener('mousemove', function(e){
        scale_draw(e.clientX, e.clientY, true);
    }, false);

    scale.addEventListener('mouseleave', function(e){
        var canvas_rect = scale.getBoundingClientRect();
        scale_draw(canvas_rect.left + 256 + 96, canvas_rect.top + 256 - 64, false);
    }, false);
}

function scale_draw(client_x, client_y, do_new){
    // coordiantes correction
    var canvas_rect = scale.getBoundingClientRect();
    client_x -= canvas_rect.left;
    client_y -= canvas_rect.top;
    var a = client_to_x(client_x);
    var b = client_to_y(client_y);

    var scale_context = scale.getContext("2d");
    scale_context.font = "16px sans-serif";
    // background
    scale_context.fillStyle="#eeeeee";
    scale_context.fillRect(0,0,512,512);

    var xs = [1., 2., 2., 1.];
    var ys = [1., 1., 2., 2.];
    var new_xs = [0, 0, 0, 0];
    var new_ys = [0, 0, 0, 0];
    for(var i = 0; i < 4; i++){
        new_xs[i] = a * xs[i];
        new_ys[i] = b * ys[i];
    }

    if(do_new){
        // the connection
        scale_context.beginPath();
        scale_context.setLineDash([2, 2]);
        for(var i = 0; i < 4; i++){
            scale_context.moveTo(x_to_client(xs[i]), y_to_client(ys[i]));
            scale_context.lineTo(x_to_client(new_xs[i]), y_to_client(new_ys[i]));
        }
        scale_context.strokeStyle="#eeaa88";
        scale_context.stroke();
        scale_context.setLineDash([]);
        scale_context.closePath();
    }

    // original cube
    draw_original_cube_on(scale_context);

    // scale
    scale_context.beginPath();
    scale_context.moveTo(x_to_client(new_xs[3]), y_to_client(new_ys[3]));
    for(var i = 0; i < 4; i++){
        scale_context.lineTo(x_to_client(new_xs[i]), y_to_client(new_ys[i]));
    }
    scale_context.strokeStyle="#dd6644";
    scale_context.stroke();
    scale_context.closePath();
    scale_context.fillStyle="#dd6644";
    scale_context.fillText("x' = a * x, where a = " + a.toFixed(2), 32, 460);
    scale_context.fillText("y' = b * y, where b = " + b.toFixed(2), 32, 480);

    // grid
    draw_grid_on(scale_context);
}

function init_affine(){
    affine = document.getElementById("affine");
    affine_draw(0, 0, false);

    affine.addEventListener('mousemove', function(e){
        affine_draw(e.clientX, e.clientY, true);
    }, false);

    affine.addEventListener('mousedown', function(e){
        var canvas_rect = affine.getBoundingClientRect();
        client_x = e.clientX - canvas_rect.left;
        client_y = e.clientY - canvas_rect.top;
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);
        affine_xs[affine_i] = x;
        affine_ys[affine_i] = y;
        affine_xs[3] = affine_xs[0] + affine_xs[2] - affine_xs[1];
        affine_ys[3] = affine_ys[0] + affine_ys[2] - affine_ys[1];
        affine_i = (affine_i + 1) % 3;
        affine_draw(e.clientX, e.clientY, true);
    }, false);

    affine.addEventListener('mouseleave', function(e){
        affine_draw(0, 0, false);
    }, false);
}

var affine_xs = [0., 4., 5., 1.];
var affine_ys = [0., 1., 5., 4.];
var affine_i = 0;

function affine_draw(client_x, client_y, do_new){
    // coordiantes correction
    var canvas_rect = affine.getBoundingClientRect();
    client_x -= canvas_rect.left;
    client_y -= canvas_rect.top;
    var x = client_to_x(client_x);
    var y = client_to_y(client_y);

    var affine_context = affine.getContext("2d");
    affine_context.font = "16px sans-serif";
    // background
    affine_context.fillStyle="#eeeeee";
    affine_context.fillRect(0,0,512,512);

    // original cube
    draw_original_cube_on(affine_context);

    // affine
    affine_context.beginPath();
    affine_context.moveTo(x_to_client(affine_xs[3]), y_to_client(affine_ys[3]));
    for(var i = 0; i < 4; i++){
        affine_context.lineTo(x_to_client(affine_xs[i]), y_to_client(affine_ys[i]));
    }
    affine_context.strokeStyle="#dd6644";
    affine_context.stroke();
    affine_context.closePath();

    if(do_new){
        // link
        affine_context.beginPath();
        affine_context.setLineDash([2, 2]);
        affine_context.moveTo(x_to_client(affine_xs[affine_i]), y_to_client(affine_ys[affine_i]));
        affine_context.lineTo(x_to_client(x), y_to_client(y));
        affine_context.strokeStyle="#dd6644";
        affine_context.stroke();
        affine_context.setLineDash([]);
        affine_context.closePath();
    }

    // grid
    draw_grid_on(affine_context);
}

function init_projective(){
    projective = document.getElementById("projective");
    projective_draw(0, 0, false);

    projective.addEventListener('mousemove', function(e){
        projective_draw(e.clientX, e.clientY, true);
    }, false);

    projective.addEventListener('mousedown', function(e){
        var canvas_rect = projective.getBoundingClientRect();
        client_x = e.clientX - canvas_rect.left;
        client_y = e.clientY - canvas_rect.top;
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);
        projective_xs[projective_i] = x;
        projective_ys[projective_i] = y;
        projective_i = (projective_i + 1) % 4;
        projective_draw(e.clientX, e.clientY, true);
    }, false);

    projective.addEventListener('mouseleave', function(e){
        projective_draw(0, 0, false);
    }, false);
}

var projective_xs = [1., 6., 5., 1.];
var projective_ys = [1., 1., 6., 3.];
var projective_i = 0;

function projective_draw(client_x, client_y, do_new){
    // coordiantes correction
    var canvas_rect = projective.getBoundingClientRect();
    client_x -= canvas_rect.left;
    client_y -= canvas_rect.top;
       var x = client_to_x(client_x);
       var y = client_to_y(client_y);

    var projective_context = projective.getContext("2d");
    projective_context.font = "16px sans-serif";
    // background
    projective_context.fillStyle="#eeeeee";
    projective_context.fillRect(0,0,512,512);

    // original cube
    draw_original_cube_on(projective_context);

    // projective
    projective_context.beginPath();
    projective_context.moveTo(x_to_client(projective_xs[3]), y_to_client(projective_ys[3]));
    for(var i = 0; i < 4; i++){
        projective_context.lineTo(x_to_client(projective_xs[i]), y_to_client(projective_ys[i]));
    }
    projective_context.strokeStyle="#dd6644";
    projective_context.stroke();
    projective_context.closePath();

    if(do_new){
        // link
        projective_context.beginPath();
        projective_context.setLineDash([2, 2]);
        projective_context.moveTo(x_to_client(projective_xs[projective_i]), y_to_client(projective_ys[projective_i]));
        projective_context.lineTo(x_to_client(x), y_to_client(y));
        projective_context.strokeStyle="#dd6644";
        projective_context.stroke();
        projective_context.setLineDash([]);
        projective_context.closePath();
    }

    // grid
    draw_grid_on(projective_context);
}


function init_composable(){
    composable = document.getElementById("composable");
    composable_draw(0, 0, false);

    composable.addEventListener('mousemove', function(e){
        composable_draw(e.clientX, e.clientY, true);
    }, false);

    composable.addEventListener('mousedown', function(e){
        var canvas_rect = composable.getBoundingClientRect();
        client_x = e.clientX - canvas_rect.left;
        client_y = e.clientY - canvas_rect.top;
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);

        // new cube
        var new_xs = [1., 2., 2., 1.];
        var new_ys = [1., 1., 2., 2.];
        if(document.getElementById("radio_p").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = composable_xs[i];
                new_ys[i] = composable_ys[i];
            }
            new_xs[composable_i] = x;
            new_ys[composable_i] = y;
            composable_i = (composable_i + 1) % 4;
        }else if(document.getElementById("radio_t").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = composable_xs[i] + x;
                new_ys[i] = composable_ys[i] + y;
            }
        }else if(document.getElementById("radio_r").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = rotated_x(x/2, composable_xs[i], composable_ys[i]);
                new_ys[i] = rotated_y(x/2, composable_xs[i], composable_ys[i]);
            }
        }else if(document.getElementById("radio_s").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = composable_xs[i] * x;
                new_ys[i] = composable_ys[i] * y;
            }
        }
        for(var i = 0; i < 4; i++){
            composable_xs[i] = new_xs[i];
            composable_ys[i] = new_ys[i];
        }

        composable_draw(e.clientX, e.clientY, true);
        // calculate a matrix
        x0 = new_xs[0];     y0 = new_ys[0];
        x1 = new_xs[1];     y1 = new_ys[1];
        x2 = new_xs[2];     y2 = new_ys[2];
        x3 = new_xs[3];     y3 = new_ys[3];
        var A = (-x0*x2*y1 + x0*x2*y3 + x0*x3*y1 - x0*x3*y2 + x1*x2*y0 - x1*x2*y3 - x1*x3*y0 + x1*x3*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
        var B = (x0*x1*y2 - x0*x1*y3 - x0*x2*y1 + x0*x2*y3 + x1*x3*y0 - x1*x3*y2 - x2*x3*y0 + x2*x3*y1)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
        var C = (-2*x0*x1*y2 + 2*x0*x1*y3 + 3*x0*x2*y1 - 3*x0*x2*y3 - 2*x0*x3*y1 + 2*x0*x3*y2 - x1*x2*y0 + x1*x2*y3 + x2*x3*y0 - x2*x3*y1)/
            (x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
        var D = (-x0*y1*y2 + x0*y1*y3 + x1*y0*y2 - x1*y0*y3 + x2*y0*y3 - x2*y1*y3 - x3*y0*y2 + x3*y1*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
        var E = (-x0*y1*y3 + x0*y2*y3 + x1*y0*y2 - x1*y2*y3 - x2*y0*y1 + x2*y1*y3 + x3*y0*y1 - x3*y0*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
        var F = (x0*y1*y2 - x0*y2*y3 - 3*x1*y0*y2 + 2*x1*y0*y3 + x1*y2*y3 + 2*x2*y0*y1 - 2*x2*y0*y3 - 2*x3*y0*y1 + 3*x3*y0*y2 - x3*y1*y2)/
            (x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
        var a = (-x0*y2 + x0*y3 + x1*y2 - x1*y3 + x2*y0 - x2*y1 - x3*y0 + x3*y1)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
        var b = (-x0*y1 + x0*y2 + x1*y0 - x1*y3 - x2*y0 + x2*y3 + x3*y1 - x3*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
        var c = 1.;
        document.getElementById("matrix_col1").innerHTML = A.toFixed(3) + "<br>" + B.toFixed(3) + "<br>" + C.toFixed(3);
        document.getElementById("matrix_col2").innerHTML = D.toFixed(3) + "<br>" + E.toFixed(3) + "<br>" + F.toFixed(3);
        document.getElementById("matrix_col3").innerHTML = a.toFixed(3) + "<br>" + b.toFixed(3) + "<br>" + c.toFixed(3);
    }, false);

    composable.addEventListener('mouseleave', function(e){
        composable_draw(0, 0, false);
    }, false);
}

var composable_xs = [1., 2., 2., 1.];
var composable_ys = [1., 1., 2., 2.];
var composable_i = 0;

function composable_draw(client_x, client_y, do_new){
    // coordiantes correction
    var canvas_rect = composable.getBoundingClientRect();
    client_x -= canvas_rect.left;
    client_y -= canvas_rect.top;
    var x = client_to_x(client_x);
    var y = client_to_y(client_y);

    var composable_context = composable.getContext("2d");
    composable_context.font = "16px sans-serif";
    // background
    composable_context.fillStyle="#eeeeee";
    composable_context.fillRect(0,0,512,512);

    // original cube
    draw_original_cube_on(composable_context);

    // composable
    composable_context.beginPath();
    composable_context.moveTo(x_to_client(composable_xs[3]), y_to_client(composable_ys[3]));
    for(var i = 0; i < 4; i++){
        composable_context.lineTo(x_to_client(composable_xs[i]), y_to_client(composable_ys[i]));
    }
    composable_context.strokeStyle="#dd6644";
    composable_context.stroke();
    composable_context.closePath();

    if(do_new){
        // new cube
        var new_xs = [1., 2., 2., 1.];
        var new_ys = [1., 1., 2., 2.];
        if(document.getElementById("radio_p").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = composable_xs[i];
                new_ys[i] = composable_ys[i];
            }
            new_xs[composable_i] = x;
            new_ys[composable_i] = y;
        }else if(document.getElementById("radio_t").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = composable_xs[i] + x;
                new_ys[i] = composable_ys[i] + y;
            }
        }else if(document.getElementById("radio_r").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = rotated_x(x/2, composable_xs[i], composable_ys[i]);
                new_ys[i] = rotated_y(x/2, composable_xs[i], composable_ys[i]);
            }
        }else if(document.getElementById("radio_s").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = composable_xs[i] * x;
                new_ys[i] = composable_ys[i] * y;
            }
        }

        composable_context.beginPath();
        composable_context.setLineDash([2, 2]);
        composable_context.moveTo(x_to_client(new_xs[3]), y_to_client(new_ys[3]));
        for(var i = 0; i < 4; i++){
            composable_context.lineTo(x_to_client(new_xs[i]), y_to_client(new_ys[i]));
        }
        composable_context.strokeStyle="#dd6644";
        composable_context.stroke();
        composable_context.setLineDash([]);
        composable_context.closePath();
    }
    // grid
    draw_grid_on(composable_context);
}

function revert_composable(){
    composable_xs = [1., 2., 2., 1.];
    composable_ys = [1., 1., 2., 2.];
    document.getElementById("matrix_col1").innerHTML = "1<br>0<br>0";
    document.getElementById("matrix_col2").innerHTML = "0<br>1<br>0";
    document.getElementById("matrix_col3").innerHTML = "0<br>0<br>1";
    composable_draw(0, 0, false);
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Interactive guide to homogeneous coordinates
    </h1>
    <p>
Why would you care about some homogeneous coordinates, whatever they are? Well, if you work with geometry: 3D-graphics, image processing, physical simulation, the answer is obvious. Knowing the mathematics behind your framework of choice lets you write more efficient code.
    </p>
    <p>
But even if you don’t work with geometry at all, you still might benefit from learning the concept of homogeneous coordinates. This is the one rare example of mathematical magic when a small complication benefits in enormous simplification. One little obscurity pays off in terms of unification and homogenization.
    </p>
    <p>
I think, learning this particular piece of geometry is a valuable experience in its own right. And you know how it works. More experience, higher level, better loot.
    </p>
    <h2>
The complication
    </h2>
    <p>
In our usual Cartesian coordinate system, a point on a plane is set by a pair of numbers (x<sub>c</sub>, y<sub>c</sub>). Feel free to pick any point. Just click anywhere on the plot.
    </p>
    <canvas id="pick_a_point" width=512 height=512></canvas>
    <script language="JavaScript">
    init_pick_a_point();
    </script>
    <p>
Now in homogeneous coordinates points on a plane are set by a tuple of 3 numbers (x<sub>h</sub>, y<sub>h</sub>, w<sub>h</sub>).
    </p>
    <p>
That's a bit unusual, but if a point is taken from the Cartesian space, you can transform a homogeneous tuple into Cartesian pair as simple as this:
    </p>
    <p class="formula">
x<sub>c</sub> = x<sub>h</sub> / w<sub>h</sub>
        <br>
y<sub>c</sub> = y<sub>h</sub> / w<sub>h</sub>
    </p>
    <p>
It's not that there is only one way to transform a point from Cartesian to homogeneous coordinates. You can pick any (almost) value for w<sub>h</sub> and it would still work.
    </p>
    <p>
    <span id="to_fill_with_numbers">
    </span>
    <script language="JavaScript">
    write_the_point_value();
    </script>
    </p>
    <p>
Here is a coordinate transformer. It will transform your point into homogeneous coordinates for the (almost) every w<sub>h</sub> you propose.
    </p>
    <form id="w">
Please enter w<sub>h</sub>:
    <input type="text" id="proposed_w" value="1">
    <button type="button" onclick="transform()">Transform</button>
    <span id="transformed">
    </span>
    <script language="JavaScript">
    init_w();
    </script>
    </form>
    <p id="to_hide_on_transform">
But it wouldn't work for all the possible numbers. There is one exception.
    </p>
    <div id="after_the_w_proposed" style="display:none;">
        <p>
Exactly! There is no tranformation between affine and Cartesian coordinates when w<sub>h</sub> is 0. Kudos for finding this yourself!
        </p>
     </div>
    <p>
Usually, Cartesian coordinates are just the first two numbers of homogeneous coordinates divided by the third. So if it is 1, then homogeneous coordinates are basically the same thing as Cartesian. But the smaller w<sub>h</sub> gets, the further the point in Cartesian coordinates “travels” from the null.
    </p>
    <canvas id="slide_a_w" width=512 height=512></canvas>
    <script language="JavaScript">
    init_slide_a_w();
    </script>
    <p>
That’s all rather simple until one moment. What if the fourth coordinate is 0?
    </p>
    <p>
Intuition tells, that it should be further from the beginning of the coordinates than every other point. Every other point in Euclidean space that is. Homogeneous coordinates indeed denote points not only in Euclidean (or, more general, <i>affine</i> space) but in the <i>projective</i> space that includes and expands the affine one.
    <p>
    <p>
Points from the projective space may lie in the Euclidean space or may be infinitely far from any point of it. If w<sub>h</sub> is 0 then it's the latter. If not, then whatever w<sub>h</sub> is, it's the former.
    </p>
    <p>
From the pragmatic point of view, this lets us, for instance, compose a 3D-scene in a manner that every object that can be reached would fit in affine space with the coordinates (x, y, z, 1), and all the objects that can never be reached will belong to its projective extension (x, y, z, 0).
    </p>
    <p>
So if you do work with 3D graphics, you might notice that it is quite common to write 3D points as a tuple of 4 numbers. The usual question here is: “what does that fourth coordinate stand for?” And the usual answer is: “Just set it to 1 and hope you wouldn’t screw anything!” Well, now you know what the fourth coordinate actually stands for.
    </p>
    <p>
It is also common to refer points from projective extension as a general direction and not a specific point in Euclidean space. A ray that starts at null and has no length has no end, only the direction. You might even have heard about it being called a vector as opposed to a point. This is not technically correct as, of course, any point is a vector in a corresponding vector space. But this still might be a useful naming convention if you are not into the real vector algebra.
    </p>
    <p>
Living in a projective space gives you more options. You can denote points that are unheard of in the Euclidean one. But that’s not all it is good for. In fact, we are only starting to get into the benefits.
    </p>
    <h2>
1. In projective space, central and parallel projections are the same
    </h2>
    <p>
There are two kinds of projection in Euclidean space: central and parallel. Central projection is what makes the perspective, so the closer things seem bigger, and that’s what we use in video games to render a 3D scene into a flat picture on a screen. The parallel projection preserves proportions, so that’s what we usually use in CAD systems to show bolts and nuts on drawings.
    </p>
    <p>
In projective space, they are the same. You see, in affine space, you can set a center for a central projection very-very far away from the scene you want to render. This will make disproportion very small. But in projective space, you can hurl a center infinitely far — further away than any point in affine space at all — and the disproportion will disappear completely.
    </p>
    <p>
So bear in mind, if you want to make a game about zombies who happen to be CAD engineers, you don’t have to implement both kinds of projections. Just set the projection central point to (x, y, z, 0), and this will automatically turn it into parallel.
    </p>
    <h2>
2. All the surfaces described as an equation on degree n are the same
    </h2>
    <p>
I remember on my first year in college we were studying quadric surfaces and one of the exercises allegedly made up to help us learn their classification was to make an album. It was 17 sheets of paper with different graphics and formulas sewed together only to be briefly examined by the professor and thrown away a day after. You might imagine we were not fond of this activity.
    </p>
    <p>
Now in projective space, this exercise would have been much more environmentally friendly. That’s because in homogeneous coordinates all the algebraic surfaces are homogenous too. This means every piece of a polynomial that defines the surface has the same degree. It may contain different variables with different degrees of their own, but they all magically add up to the very same degree for every element in the sum.
    </p>
    <p>
And this means only one drawing with one formula to be drawn and thrown away and not seventeen. That should sum up to a couple of dead trees over the years.
    </p>
    <h2>
3. All projective transformations are a matrix (yes, singular)
    </h2>
    <p>
Geometric transformations are something that happens to a point. They are basically functions (x', y') = f(x, y). If you want to apply the transformation to some object, most of the time you would have to represent it with points and then apply the transformation to each of them.
    </p>
    <p>
Sometimes this gets computationally heavy. For instance, transforming 3 000 x 4 000 pixels image would require 12 000 000 transformations. So looking for the fastest way to apply a transformation does make sense pragmatically.
    </p>
    <p>
Some of the most common transformations are called translation;
    </p>
    <canvas id="translation" width=512 height=512></canvas>
    <script language="JavaScript">
    init_translation();
    </script>
    <p>
rotation;
    </p>
    <canvas id="rotation" width=512 height=512></canvas>
    <script language="JavaScript">
    init_rotation();
    </script>
    <p>
and scale.
    </p>
    <canvas id="scale" width=512 height=512></canvas>
    <script language="JavaScript">
    init_scale();
    </script>
    <p>
These can be generalized by the affine transformation that can do a translation, and a rotation, and a scale simultaneously:
    </p>
    <canvas id="affine" width=512 height=512></canvas>
    <script language="JavaScript">
    init_affine();
    </script>
    <p>
As you can see, the affine transformation is quite powerful, but it is meant to preserve parallelism. This limits it in a way. If you want to do something like perspective or projection, you would have to go for projective transformation that looks like this:
    </p>
    <canvas id="projective" width=512 height=512></canvas>
    <script language="JavaScript">
    init_projective();
    </script>
    <h2>
Formulas in Cartesian coordinates
    </h2>
    <p>
The formula for projective transformations in Cartesian coordinates looks like this:
    </p>
    <p class="formula">
x' = (Ax + By + C) / (ax + by +c)
        <br>
y' = (Dx + Ey + F) / (ax + by +c)
    </p>
    <p>
It is a simple geometric transformation just like all we have seen before. It also works on one point at a time. It preserves the degree of curves and surfaces so every straight line will get transformed into the straight line and each plane also into a plane. Since all the 2-nd degree surfaces are the same surface, it will also preserve the degree, but not a class in affine space so that ellipsoid may become paraboloid or hyperboloid.
    </p>
    <p>
It also generalizes affine transformation that has this simple formula:
    </p>
    <p class="formula">
x' = (Ax + By + C)
        <br>
y' = (Dx + Ey + F)
    </p>
    <p>
As you can see, it's just a special case of projective transformation when a = 0, b = 0, and c = 1.
    </p>
    <p>
And the affine transformation in its turn generalizes translation, rotation and scale. Translation is:
    </p>
    <p class="formula">
x' = x + C   (A = 1, B = 0)
        <br>
y' = y + F   (D = 0, E = 1)
    </p>
    <p>
Rotation:
    </p>
    <p class="formula">
x' = sin(r) x + cos(r) y   (A = sin(r), B = cos(r), C = 0)
        <br>
y' = cos(r) x - sin(r) y   (D = cos(r), E = -sin(r), F = 0)
    </p>
    <p>
And scale:
    </p>
    <p class="formula">
x' = Ax   (B = 0, C = 0)
        <br>
y' = Ey   (D = 0, F = 0)
    </p>
    <p>
They are all just special cases of projective transformations.
    </p>
    <p>
Now please bear with me, we are entering the matrix territory.
    </p>
    <h2>
Matrix in homogeneous coordinates
    </h2>
    <p>
What's going to happen if we multiply a square matrix on a point in homogeneous coordinates?
    </p>
    <table class="formula">
    <tr>
    <td class="brackets">[</td>
    <td>A D a<br>B E b<br>C F c</td>
    <td class="brackets">][</td>
    <td>x<br>y<br>w</td>
    <td class="brackets">]</td>
    <td> = </td>
    <td class="brackets">[</td>
    <td>Ax + By + Cw<br>Dx + Ey + Fw<br>ax + by + cw</td>
    <td class="brackets">]</td>
    </tr>
    </table>
    <p>
Let's pretend the point we took came from Cartesian coordinates so w<sub>h</sub> = 1. Now we see that:
    </p>
    <p class="formula">
x' = Ax + By + C
        <br>
y' = Dx + Ey + F
        <br>
w' = ax + by + c
    </p>
    <p>
And let's say we want to get back to Cartesian coordinates with this as well. So let's make our w' = 1. We can do this by dividing everything to the current w'.
    </p>
    <p class="formula">
x' = (Ax + By + C) / (ax + by + c)
        <br>
y' = (Dx + Ey + F) / (ax + by + c)
        <br>
w' = 1
    </p>
    <p>
Doesn't it look familiar? Well, of course, it does! It's the projective transformation. Or the affine. Or it could be the translation, or rotation, or scale. They all can be written as a single matrix multiplication.
    </p>
    <p>
But that's not yet all. Matrices are composable. You can compose your own translation + rotation + another translation + scale + projection — and it all will still fit into a single matrix!
    </p>
    <form>
    <input type="radio" name="transformation_type" id="radio_t">Translation&nbsp;&nbsp;
    <input type="radio" name="transformation_type" id="radio_r">Rotation&nbsp;&nbsp;
    <input type="radio" name="transformation_type" id="radio_s">Scale&nbsp;&nbsp;
    <input type="radio" name="transformation_type" id="radio_p" checked="true">Projection<br>
    </form>
    <canvas id="composable" width=512 height=512></canvas>
    <table class="formula">
    <tr><td>
Matrix:
    </td>
    <td class="brackets">[</td>
    <td id="matrix_col1">
1<br>0<br>0
    </td><td id="matrix_col2">
0<br>1<br>0
    </td><td id="matrix_col3">
0<br>0<br>1
    </td>
    <td class="brackets">]</td>
    </tr>
    </table>

    <button class="button" id="revert_composable" onclick="revert_composable()">Revert to E</button>
    <script language="JavaScript">
    init_composable();
    </script>
    <h2>
Conclusion
    </h2>
    <p>
As you can see, you can save quite a lot of time processing millions of points with one single matrix instead of applying all the transformations separately. And you can also save lines of code by unifying all the transformations. But this is not the whole point. Usually, we lose performance, not because of some small computational inefficiency, but because of needless layering. And the layering occurs because people don’t understand and don’t trust the beauty of the plain mathematics.
    </p>
    <p>
I hope this page reveals a bit of it. I hope it makes it a little more trustworthy.
    </p>


    <p class="footer">
There are more words and buttons on <a href="index.html">wordsandbuttons.online</a>.
    </p>
    </center>
  </body>
</html>
