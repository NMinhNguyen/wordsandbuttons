<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>You too can read disassembly</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.comment {
    font-size: 12pt;
    text-align:center;
    font-family: sans-serif;
    padding-bottom: 24pt;
}

.footer {
    margin-top: 64pt;
    padding-bottom: 32pt;
    font-family: sans-serif;
    font-size: 14pt;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
    width: 360pt;
}

.code_piece {
    font-family: monospace;
    padding-left: 4pt;
    padding-right: 4pt;
}


table {
    border-width: 0pt;
}

td {
    vertical-align: top;
    padding: 6pt 12pt 6pt 12pt;
    font-size: 16pt;
    border: 1px solid black;
}

button{
    width: 304pt;
    height: 42pt;
    margin-left:4pt;
    margin-right:4pt;
    font-size: 18pt;
}

    </style>
    <script language="JavaScript">

    </script>
  </head>
  <body>
    <center>
    <h1>
You too can read disassembly
    </h1>
    <p>
Reading disassembly is more like reading tracks than reading a book. You have to know the language to read a book, but reading tracks, although it gets better with skills and experience, mostly requires attentiveness and logic thinking.
    </p>
    <p>
Most of the time we browse disassembly only to answer one simple question: <i>does compiler do what we expect it to do</i>? In 3 simple exercises, I’ll show you that you too can answer such questions even if you have never seen disassembly before. I’ll use C++ as a source language, but what I’m trying to show is more or less universal, so it doesn’t matter if you write in C or Java, C# or Rust, — if you compile to some sort of machine code — you can benefit from understanding your compiler.
    </p>
    <h2>
1. Compile time computation
    </h2>
    <p>
Any decent compiler tries to make your code efficient. This means doing as little work in runtime as possible. Sometimes it can even conduct the whole computation in compile time, so your machine code will only have to contain the answer.
    </p>
    <p>
This source code defines the number of bits in a byte, provides a template function that accepts the type <span class="code_piece">T</span> and returns the size of <span class="code_piece">T</span> in bits. Then it calls this function from the main section setting <span class="code_piece">T = int</span>.
    </p>
    <table><tr>
    <td style="width: 505pt;">
    <pre>
static int BITS_IN_BYTE = 8;

template&lt;typename T&gt;
size_t bits_in(){
    return sizeof(T)*BITS_IN_BYTE;
}

int main(){
    return bits_in&lt;int&gt;();
}
    </pre>
    </td>
    </td></tr></table>
    <p>
The compiler knows the size of an <span class="code_piece">int</span>. Let's say, for the target platform it is 4 bytes. We also set the number of bits in a byte explicitly. Since all we want is a simple multiplication, and both numbers are known in compile time, the compiler can simply compute the number instead of generating the code that computed the same number each time it's being executed.
    </p>
    <p>
Although, this is not something that is guaranteed by the standard. The compiler may or may not provide this optimization.
    </p>
    <p>
Now look at two possible disassemblies for this source code and decide what variant does compile time computation and what doesn’t.
    </p>
    <table><tr>
    <td>
    <pre>
01021002  in          al,dx  
01021003  mov         eax,dword ptr ds:[01023000h]  
01021008  shl         eax,2  
0102100B  pop         ebp  
0102100C  ret    </pre>
    </td>
    <td>
    <pre>
003C1000  push        20h
003C1002  pop         eax    </pre>
    </td></tr></table>
    <p>
Well, that’s a no-brainer. Of course, the one on the left does.
    </p>
    <p>
On 32-bit platform <span class="code_piece">int</span>'s size is 4 bytes, which is 32 bits, which is 20h in hexadecimal. You might not know the convention by which a function returns the value in <span class="code_piece">eax</span>, but you see that the first variant is long enough to contain an actual multiplication, while the second one has only two lines: something containing the computed answer and the other one.    
    </p>

    <h2>
2. Function inlining
    </h2>
    <p>
Calling a function implies some overhead by preparing input data in the particular order; then starting the execution from another piece of memory; then preparing output data; and then returning back.
    </p>
    <p>
Not that it's that ineffective but if you only want to call the function once, you don’t have to <i>actually call</i> the function. It just makes sense to copy or “inline” the function body to the place it is called from and skip all the formalities. Compilers can often do this for you so you don't even have to bother.
    </p>
    <p>
If the compiler makes such an optimization, this code:
    </p>
    <table><tr>
    <td style="width: 505pt;">
    <pre>
<i>inline</i> int <b>twice</b>(int x){
    return x + x;
}
int main(){
    return <b>twice</b>(2);
}
    </pre>
    </td>
    </td></tr></table>    
    <p>
Virtually becomes this:
    </p>    
    <table><tr>
    <td style="width: 505pt;">
    <pre>
<i>// not really a source code, just explaining the idea</i>
int main(){ 
    return 2 + 2; <i>// twice gets inlined here</i>
}
    </pre>
    </td>
    </td></tr></table> 
    <p>
But the standard does not promise that all the functions marked as <span class="code_piece">inline</span> shall get inlined. It's more a suggestion than a directive.
    </p>
    <p>
Now look at these two disassembly variants below and choose the one where the function gets inlined after all.
    </p>
    <table><tr>
    <td>
    <pre>
00E71002  in          al,dx  
00E71003  mov         eax,2  
00E71008  add         eax,2  
00E7100B  pop         ebp  
00E7100C  ret</pre>
    </td>
    <td>
    <pre>
00261002  in          al,dx  
00261003  mov         eax,dword ptr [x]  
00261006  add         eax,dword ptr [x]  
00261009  pop         ebp  
0026100A  ret
...
008F1010  push        ebp  
008F1011  mov         ebp,esp  
008F1013  push        2  
008F1015  call        twice (08F1000h)  
008F101A  add         esp,4  
008F101D  pop         ebp  
008F101E  ret</pre>
    </td></tr></table>    
    <p>
Not really a mystery either. It’s the one on the left. You might not know, that the instruction to call a function is called the <span class="code_piece">call</span>, but since the disassembly on the left contains no recall of the name <span class="code_piece">twice</span>, it must be inlined.
    </p>
    
    <h3>
3. Loop unrolling
    </h3>    
    <p>
Just like calling functions, going in loops implies some overhead. You have to increment the counter; then compare it against some number; then jump back to the loop beginning.    
    </p>
    <p>
Compilers know that in some context it is more effective to unroll the loop. It means that some piece of code will actually be repeated several times in a row instead of messing with the counter comparison and jumping here and there.
    </p>
    <p>
Let's say we have this piece of code:
    </p>
    <table><tr>
    <td style="width: 505pt;">
    <pre>
int main(int argc, char*)
{
    int result = 1;
    for(short int i = 0; i < 4; ++i)
        result *= argc;
    return result;
}
    </pre>
    </td>
    </td></tr></table>

    <table><tr>
    <td>
    <pre>
asm1
    </pre>
    </td>
    <td>
    <pre>
asm2
    </pre>
    </td></tr></table>



    <p class="footer">
    There are more words and buttons on <a href="index.html">wordsandbuttons.online</a>.<br>
    Also please follow us on <a href="https://twitter.com/wordsandbuttons">Twitter</a>.
    </p>
    </center>
  </body>
</html>
