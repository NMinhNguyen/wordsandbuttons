AAA                  ASCII adjust AL after addition
AAD                  ASCII adjust AX before division
AAM                  ASCII adjust AX after multiplication
AAS                  ASCII adjust AL after subtraction
ADC                  Add with carry
ADD*                 Add
AND*                 Logical AND
CALL                 Call procedure
CBW                  Convert byte to word
CLC                  Clear carry flag
CLD                  Clear direction flag
CLI                  Clear interrupt flag
CMC                  Complement carry flag
CMP*                 Compare operands
CMPSB                Compare bytes in memory
CMPSW                Compare words
CWD                  Convert word to doubleword
DAA                  Decimal adjust AL after addition
DAS                  Decimal adjust AL after subtraction
DEC                  Decrement by 1
DIV                  Unsigned divide
ESC                  Used with floating-point unit
HLT                  Enter halt state
IDIV                 Signed divide
IMUL                 Signed multiply
IN                   Input from port
INC                  Increment by 1
INT                  Call to interrupt
INTO                 Call to interrupt if overflow
IRET                 Return from interrupt
JCXZ                 Jump if CX is zero
JMP                  Jump
J*                   Jump if condition
LAHF                 Load FLAGS into AH register
LDS                  Load pointer using DS
LEA*                 Load Effective Address
LES                  Load ES with pointer
LOCK                 Assert BUS LOCK# signal
LODSB                Load string byte
LODSW                Load string word
LOOP/LOOPx           Loop control
MOV*                 Move
MOVSB                Move byte from string to string
MOVSW                Move word from string to string
MUL                  Unsigned multiply
NEG                  Two's complement negation
NOP                  No operation
NOT                  Negate the operand, logical NOT
OR*                  Logical OR
OUT                  Output to port
POPF                 Pop FLAGS register from stack
POP*                 Pop data from stack
PUSHF                Push FLAGS onto stack
PUSH*                Push data onto stack
RCL                  Rotate left (with carry)
RCR                  Rotate right (with carry)
REP*                 Repeat MOVS/STOS/CMPS/LODS/SCAS
RET                  Return from procedure
RETN                 Return from near procedure
RETF                 Return from far procedure
ROL                  Rotate left
ROR                  Rotate right
SAHF                 Store AH into FLAGS
SAL*                 Shift Arithmetically left (signed shift left)
SAR*                 Shift Arithmetically right (signed shift right)
SBB                  Subtraction with borrow
SCASB                Compare byte string
SCASW                Compare word string
SHL*                 Shift left (unsigned shift left)
SHR*                 Shift right (unsigned shift right)
STC                  Set carry flag
STD                  Set direction flag
STI                  Set interrupt flag
STOSB                Store byte in string
STOSW                Store word in string
SUB                  Subtraction
TEST*                Logical compare (AND)
WAIT                 Wait until not busy
XCHG                 Exchange data
XLAT                 Table look-up translation
XOR*                 Exclusive OR
BOUND                Check array index against bounds
ENTER                Enter stack frame
INS                  Input from port to string
LEAVE                Leave stack frame
OUTS                 Output string to port
POPA                 Pop all general purpose registers from stack
PUSHA                Push all general purpose registers onto stack
SHL*                 Shift bits with an immediate value greater than 1
SHR*                 Shift bits with an immediate value greater than 1
SAL*                 Shift bits with an immediate value greater than 1
SAR*                 Shift bits with an immediate value greater than 1
ROL*                 Rotate bits with an immediate value greater than 1
ROR*                 Rotate bits with an immediate value greater than 1
RCL*                 Rotate bits with an immediate value greater than 1
RCR*                 Rotate bits with an immediate value greater than 1
ARPL                 Adjust RPL field of selector
CLTS                 Clear task-switched flag in register CR0
LAR                  Load access rights byte
LGDT                 Load global descriptor table
LIDT                 Load interrupt descriptor table
LLDT                 Load local descriptor table
LMSW                 Load machine status word
LOADALL              Load all CPU registers, including internal ones such as GDT
LSL                  Load segment limit
LTR                  Load task register
SGDT                 Store global descriptor table
SIDT                 Store interrupt descriptor table
SLDT                 Store local descriptor table
SMSW                 Store machine status word
STR                  Store task register
VERR                 Verify a segment for reading
VERW                 Verify a segment for writing
BSF                  Bit scan forward
BSR                  Bit scan reverse
BT                   Bit test
BTC                  Bit test and complement
BTR                  Bit test and reset
BTS                  Bit test and set
CDQ                  Convert double-word to quad-word
CMPSD                Compare string double-word
CWDE                 Convert word to double-word
INSD                 Input from port to string double-word
IRET*                Interrupt return; D suffix means 32-bit return, F suffix means do not generate epilogue code (i.e. LEAVE instruction)
JECXZ                Jump if ECX is zero
LFS                  Load far pointer
LSS                  Load stack segment
LODSD                Load string double-word
LOOPW                Loop, conditional loop
LOOPD                Loop while equal
MOVSD                Move string double-word
MOVSX                Move with sign-extension
MOVZX                Move with zero-extension
OUTSD                Output to port from string double-word
POPAD                Pop all double-word (32-bit) registers from stack
POPFD                Pop data into EFLAGS register
PUSHAD               Push all double-word (32-bit) registers onto stack
PUSHFD               Push EFLAGS register onto stack
SCASD                Scan string data double-word
SET*                 Set byte to one on condition, zero otherwise
SHLD                 Shift left double-word
SHRD                 Shift right double-word
STOSD                Store string double-word
LGS                  Load far pointer
BSWAP                Byte Swap
CMPXCHG              atomic CoMPare and eXCHanGe
INVD                 Invalidate Internal Caches
INVLPG               Invalidate TLB Entry
WBINVD               Write Back and Invalidate Cache
XADD                 eXchange and ADD
CPUID                CPU IDentification
CMPXCHG8B            CoMPare and eXCHanGe 8 bytes
RDMSR                ReaD from Model-specific register
RDTSC                ReaD Time Stamp Counter
WRMSR                WRite to Model-Specific Register
RSM                  Resume from System Management Mode
RDPMC                Read the PMC [Performance Monitoring Counter
SYSCALL              functionally equivalent to SYSENTER
SYSRET               functionally equivalent to SYSEXIT
CMOV*                Conditional move
UD2                  Undefined Instruction
SYSENTER             SYStem call ENTER
SYSEXIT              SYStem call EXIT
MASKMOVQ             Masked Move of Quadword
MOVNTPS              Move Aligned Four Packed Single-FP Non Temporal
MOVNTQ               Move Quadword Using Non-Temporal Hint
NOP                  Multi-byte no-operation instruction.
PREFETCHT0           Prefetch Data from Address
PREFETCHT1           Prefetch Data from Address
PREFETCHT2           Prefetch Data from Address
PREFETCHNTA          Prefetch Data from Address
SFENCE               Store Fence
CLFLUSH m8           Cache Line Flush
LFENCE               Load Fence
MFENCE               Memory Fence
MOVNTI               Move Doubleword Non-Temporal
PAUSE                Spin Loop Hint
CRC32                Accumulate CRC32
CDQE                 Sign extend EAX into RAX
CQO                  Sign extend RAX into RDX:RAX
CMPSQ                CoMPare String Quadword
CMPXCHG16B           CoMPare and eXCHanGe 16 Bytes
IRETQ                64-bit Return from Interrupt
JRCXZ                Jump if RCX is zero
LODSQ                LOaD String Quadword
MOVSXD               MOV with Sign Extend 32-bit to 64-bit
POPFQ                POP RFLAGS Register
PUSHFQ               PUSH RFLAGS Register
RDTSCP               ReaD Time Stamp Counter and Processor ID
SCASQ                SCAn String Quadword
STOSQ                STOre String Quadword
SWAPGS               Exchange GS base with KernelGSBase MSR
CLGI                 Clear Global Interrupt Flag
INVLPGA              Invalidate TLB entry in a specified ASID
SKINIT               Secure Init and Jump with Attestation
STGI                 Set Global Interrupt Flag
VMLOAD               Load state From VMCB
VMMCALL              Call VMM
VMRUN                Run virtual machine
VMSAVE               Save state To VMCB
VMPTRLD              Load Pointer to Virtual-Machine Control Structure
VMPTRST              Store Pointer to Virtual-Machine Control Structure
VMCLEAR              Clear Virtual-Machine Control Structure
VMREAD               Read Field from Virtual-Machine Control Structure
VMWRITE              Write Field to Virtual-Machine Control Structure
VMCALL               Call to VM Monitor
VMLAUNCH             Launch Virtual Machine
VMRESUME             Resume Virtual Machine
VMXOFF               Leave VMX Operation
VMXON                Enter VMX Operation
F2XM1                {\displaystyle 2^{x}-1}
FABS                 Absolute value
FADD                 Add
FADDP                Add and pop
FBLD                 Load BCD
FBSTP                Store BCD and pop
FCHS                 Change sign
FCLEX                Clear exceptions
FCOM                 Compare
FCOMP                Compare and pop
FCOMPP               Compare and pop twice
FDECSTP              Decrement floating point stack pointer
FDISI                Disable interrupts
FDIV                 Divide
FDIVP                Divide and pop
FDIVR                Divide reversed
FDIVRP               Divide reversed and pop
FENI                 Enable interrupts
FFREE                Free register
FIADD                Integer add
FICOM                Integer compare
FICOMP               Integer compare and pop
FIDIV                Integer divide
FIDIVR               Integer divide reversed
FILD                 Load integer
FIMUL                Integer multiply
FINCSTP              Increment floating point stack pointer
FINIT                Initialize floating point processor
FIST                 Store integer
FISTP                Store integer and pop
FISUB                Integer subtract
FISUBR               Integer subtract reversed
FLD                  Floating point load
FLD1                 Load 1.0 onto stack
FLDCW                Load control word
FLDENV               Load environment state
FLDENVW              Load environment state, 16-bit
FLDL2E               Load log2(e) onto stack
FLDL2T               Load log2(10) onto stack
FLDLG2               Load log10(2) onto stack
FLDLN2               Load ln(2) onto stack
FLDPI                Load ? onto stack
FLDZ                 Load 0.0 onto stack
FMUL                 Multiply
FMULP                Multiply and pop
FNCLEX               Clear exceptions, no wait
FNDISI               Disable interrupts, no wait
FNENI                Enable interrupts, no wait
FNINIT               Initialize floating point processor, no wait
FNOP                 No operation
FNSAVE               Save FPU state, no wait, 8-bit
FNSAVEW              Save FPU state, no wait, 16-bit
FNSTCW               Store control word, no wait
FNSTENV              Store FPU environment, no wait
FNSTENVW             Store FPU environment, no wait, 16-bit
FNSTSW               Store status word, no wait
FPATAN               Partial arctangent
FPREM                Partial remainder
FPTAN                Partial tangent
FRNDINT              Round to integer
FRSTOR               Restore saved state
FRSTORW              Restore saved state
FSAVE                Save FPU state
FSAVEW               Save FPU state, 16-bit
FSCALE               Scale by factor of 2
FSQRT                Square root
FST                  Floating point store
FSTCW                Store control word
FSTENV               Store FPU environment
FSTENVW              Store FPU environment, 16-bit
FSTP                 Store and pop
FSTSW                Store status word
FSUB                 Subtract
FSUBP                Subtract and pop
FSUBR                Reverse subtract
FSUBRP               Reverse subtract and pop
FTST                 Test for zero
FWAIT                Wait while FPU is executing
FXAM                 Examine condition flags
FXCH                 Exchange registers
FXTRACT              Extract exponent and significand
FYL2X                y*log2(x)
FYL2XP1              y*log2(x+1)
FSETPM               Set protected mode
FCOS                 Cosine
FLDENVD              Load environment state, 32-bit
FSAVED               Save FPU state, 32-bit
FSTENVD              Store FPU environment, 32-bit
FPREM1               Partial remainder
FRSTORD              Restore saved state, 32-bit
FSIN                 Sine
FSINCOS              Sine and cosine
FSTENVD              Store FPU environment, 32-bit
FUCOM                Unordered compare
FUCOMP               Unordered compare and pop
FUCOMPP              Unordered compare and pop twice
EMMS                 Empty MMX Technology State
MOVD                 Move doubleword
MOVQ                 Move quadword
PACKSSDW             Pack doublewords to words (signed with saturation)
PACKSSWB             Pack words to bytes (signed with saturation)
PACKUSWB             Pack words to bytes (unsigned with saturation)
PADDB                Add packed byte integers
PADDW                Add packed word integers
PADDD                Add packed doubleword integers
PADDQ                Add packed quadword integers
PADDSB               Add packed signed byte integers and saturate
PADDSW               Add packed signed word integers and saturate
PADDUSB              Add packed unsigned byte integers and saturate
PADDUSW              Add packed unsigned word integers and saturate
PAND                 Bitwise AND
PANDN                Bitwise AND NOT
POR                  Bitwise OR
PXOR                 Bitwise XOR
PCMPEQB              Compare packed bytes for equality
PCMPEQW              Compare packed words for equality
PCMPEQD              Compare packed doublewords for equality
PCMPGTB              Compare packed signed byte integers for greater than
PCMPGTW              Compare packed signed word integers for greater than
PCMPGTD              Compare packed signed doubleword integers for greater than
PMADDWD              Multiply packed words, add adjacent doubleword results
PMULHW               Multiply packed signed word integers, store high 16 bits of results
PMULLW               Multiply packed signed word integers, store low 16 bits of results
PSLLW                Shift left words, shift in zeros
PSLLW                Shift left words, shift in zeros
PSLLD                Shift left doublewords, shift in zeros
PSLLD                Shift left doublewords, shift in zeros
PSLLQ                Shift left quadword, shift in zeros
PSLLQ                Shift left quadword, shift in zeros
PSRAD                Shift right doublewords, shift in sign bits
PSRAD                Shift right doublewords, shift in sign bits
PSRAW                Shift right words, shift in sign bits
PSRAW                Shift right words, shift in sign bits
PSRLW                Shift right words, shift in zeros
PSRLW                Shift right words, shift in zeros
PSRLD                Shift right doublewords, shift in zeros
PSRLD                Shift right doublewords, shift in zeros
PSRLQ                Shift right quadword, shift in zeros
PSRLQ                Shift right quadword, shift in zeros
PSUBB                Subtract packed byte integers
PSUBW                Subtract packed word integers
PSUBD                Subtract packed doubleword integers
PSUBSB               Subtract signed packed bytes with saturation
PSUBSW               Subtract signed packed words with saturation
PSUBUSB              Subtract unsigned packed bytes with saturation
PSUBUSW              Subtract unsigned packed words with saturation
PUNPCKHBW            Unpack and interleave high-order bytes
PUNPCKHWD            Unpack and interleave high-order words
PUNPCKHDQ            Unpack and interleave high-order doublewords
PUNPCKLBW            Unpack and interleave low-order bytes
PUNPCKLWD            Unpack and interleave low-order words
PUNPCKLDQ            Unpack and interleave low-order doublewords
PSHUFW               Shuffle Packed Words
PINSRW               Insert Word
PEXTRW               Extract Word
PMOVMSKB             Move Byte Mask
PMINUB               Minimum of Packed Unsigned Byte Integers
PMAXUB               Maximum of Packed Unsigned Byte Integers
PAVGB                Average Packed Integers
PAVGW                Average Packed Integers
PMULHUW              Multiply Packed Unsigned Integers and Store High Result
PMINSW               Minimum of Packed Signed Word Integers
PMAXSW               Maximum of Packed Signed Word Integers
PSADBW               Compute Sum of Absolute Differences
PSUBQ                Subtract quadword integer
PMULUDQ              Multiply unsigned doubleword intege
PSIGNB               Negate/zero/preserve packed byte integers depending on corresponding sign
PSIGNW               Negate/zero/preserve packed word integers depending on corresponding sign
PSIGND               Negate/zero/preserve packed doubleword integers depending on corresponding sign
PSHUFB               Shuffle bytes
PMULHRSW             Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits
PMADDUBSW            Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words
PHSUBW               Subtract and pack 16-bit signed integers horizontally
PHSUBSW              Subtract and pack 16-bit signed integer horizontally with saturation
PHSUBD               Subtract and pack 32-bit signed integers horizontally
PHADDSW              Add and pack 16-bit signed integers horizontally, pack saturated integers to mm1.
PHADDW               Add and pack 16-bit integers horizontally
PHADDD               Add and pack 32-bit integers horizontally
PALIGNR              Concatenate destination and source operands, extract byte-aligned result shifted to the right
PABSB                Compute the absolute value of bytes and store unsigned result
PABSW                Compute the absolute value of 16-bit integers and store unsigned result
PABSD                Compute the absolute value of 32-bit integers and store unsigned result
ANDPS*               Bitwise Logical AND of Packed Single-Precision Floating-Point Values
ANDNPS*              Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values
ORPS*                Bitwise Logical OR of Single-Precision Floating-Point Values
XORPS*               Bitwise Logical XOR for Single-Precision Floating-Point Values
MOVUPS               Move Unaligned Packed Single-Precision Floating-Point Values
MOVSS                Move Scalar Single-Precision Floating-Point Values
MOVUPS               Move Unaligned Packed Single-Precision Floating-Point Values
MOVSS                Move Scalar Single-Precision Floating-Point Values
MOVLPS               Move Low Packed Single-Precision Floating-Point Values
MOVHLPS              Move Packed Single-Precision Floating-Point Values High to Low
MOVLPS               Move Low Packed Single-Precision Floating-Point Values
UNPCKLPS             Unpack and Interleave Low Packed Single-Precision Floating-Point Values
UNPCKHPS             Unpack and Interleave High Packed Single-Precision Floating-Point Values
MOVHPS               Move High Packed Single-Precision Floating-Point Values
MOVLHPS              Move Packed Single-Precision Floating-Point Values Low to High
MOVHPS               Move High Packed Single-Precision Floating-Point Values
MOVAPS               Move Aligned Packed Single-Precision Floating-Point Values
MOVAPS               Move Aligned Packed Single-Precision Floating-Point Values
MOVMSKPS             Extract Packed Single-Precision Floating-Point 4-bit Sign Mask. The upper bits of the register are filled with zeros.
CVTPI2PS             Convert Packed Dword Integers to Packed Single-Precision FP Values
CVTSI2SS             Convert Dword Integer to Scalar Single-Precision FP Value
CVTSI2SS             Convert Qword Integer to Scalar Single-Precision FP Value
MOVNTPS              Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint
CVTTPS2PI            Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers
CVTTSS2SI            Convert with Truncation Scalar Single-Precision FP Value to Dword Integer
CVTTSS2SI            Convert with Truncation Scalar Single-Precision FP Value to Qword Integer
CVTPS2PI             Convert Packed Single-Precision FP Values to Packed Dword Integers
CVTSS2SI             Convert Scalar Single-Precision FP Value to Dword Integer
CVTSS2SI             Convert Scalar Single-Precision FP Value to Qword Integer
UCOMISS              Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS
COMISS               Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS
SQRTPS               Compute Square Roots of Packed Single-Precision Floating-Point Values
SQRTSS               Compute Square Root of Scalar Single-Precision Floating-Point Value
RSQRTPS              Compute Reciprocal of Square Root of Packed Single-Precision Floating-Point Value
RSQRTSS              Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value
RCPPS                Compute Reciprocal of Packed Single-Precision Floating-Point Values
RCPSS                Compute Reciprocal of Scalar Single-Precision Floating-Point Values
ADDPS                Add Packed Single-Precision Floating-Point Values
ADDSS                Add Scalar Single-Precision Floating-Point Values
MULPS                Multiply Packed Single-Precision Floating-Point Values
MULSS                Multiply Scalar Single-Precision Floating-Point Values
SUBPS                Subtract Packed Single-Precision Floating-Point Values
SUBSS                Subtract Scalar Single-Precision Floating-Point Values
MINPS                Return Minimum Packed Single-Precision Floating-Point Values
MINSS                Return Minimum Scalar Single-Precision Floating-Point Values
DIVPS                Divide Packed Single-Precision Floating-Point Values
DIVSS                Divide Scalar Single-Precision Floating-Point Values
MAXPS                Return Maximum Packed Single-Precision Floating-Point Values
MAXSS                Return Maximum Scalar Single-Precision Floating-Point Values
LDMXCSR              Load MXCSR Register State
STMXCSR              Store MXCSR Register State
CMPPS                Compare Packed Single-Precision Floating-Point Values
CMPSS                Compare Scalar Single-Precision Floating-Point Values
SHUFPS               Shuffle Packed Single-Precision Floating-Point Values
MOVAPD               Move Aligned Packed Double-Precision Floating-Point Values
MOVAPD               Move Aligned Packed Double-Precision Floating-Point Values
MOVNTPD              Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint
MOVHPD               Move High Packed Double-Precision Floating-Point Value
MOVHPD               Move High Packed Double-Precision Floating-Point Value
MOVLPD               Move Low Packed Double-Precision Floating-Point Value
MOVLPD               Move Low Packed Double-Precision Floating-Point Value
MOVUPD               Move Unaligned Packed Double-Precision Floating-Point Values
MOVUPD               Move Unaligned Packed Double-Precision Floating-Point Values
MOVMSKPD             Extract Packed Double-Precision Floating-Point Sign Mask
MOVSD*               Move or Merge Scalar Double-Precision Floating-Point Value
MOVSD                Move or Merge Scalar Double-Precision Floating-Point Value
ADDPD                Add Packed Double-Precision Floating-Point Values
ADDSD                Add Low Double-Precision Floating-Point Value
DIVPD                Divide Packed Double-Precision Floating-Point Values
DIVSD                Divide Scalar Double-Precision Floating-Point Value
MAXPD                Maximum of Packed Double-Precision Floating-Point Values
MAXSD                Return Maximum Scalar Double-Precision Floating-Point Value
MINPD                Minimum of Packed Double-Precision Floating-Point Values
MINSD                Return Minimum Scalar Double-Precision Floating-Point Value
MULPD                Multiply Packed Double-Precision Floating-Point Values
MULSD                Multiply Scalar Double-Precision Floating-Point Value
SQRTPD               Square Root of Double-Precision Floating-Point Values
SQRTSD               Compute Square Root of Scalar Double-Precision Floating-Point Value
SUBPD                Subtract Packed Double-Precision Floating-Point Values
SUBSD                Subtract Scalar Double-Precision Floating-Point Value
ANDPD                Bitwise Logical AND of Packed Double Precision Floating-Point Values
ANDNPD               Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values
ORPD                 Bitwise Logical OR of Packed Double Precision Floating-Point Values
XORPD                Bitwise Logical XOR of Packed Double Precision Floating-Point Values
CMPPD                Compare Packed Double-Precision Floating-Point Values
CMPSD*               Compare Low Double-Precision Floating-Point Values
COMISD               Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS
UCOMISD              Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS
SHUFPD               Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values
UNPCKHPD             Unpack and Interleave High Packed Double-Precision Floating-Point Values
UNPCKLPD             Unpack and Interleave Low Packed Double-Precision Floating-Point Values
CVTDQ2PD             Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values
CVTDQ2PS             Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values
CVTPD2DQ             Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers
CVTPD2PI             Convert Packed Double-Precision FP Values to Packed Dword Integers
CVTPD2PS             Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values
CVTPI2PD             Convert Packed Dword Integers to Packed Double-Precision FP Values
CVTPS2DQ             Convert Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values
CVTPS2PD             Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values
CVTSD2SI             Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer
CVTSD2SI             Convert Scalar Double-Precision Floating-Point Value to Quadword Integer With Sign Extension
CVTSD2SS             Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value
CVTSI2SD             Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value
CVTSI2SD             Convert Quadword Integer to Scalar Double-Precision Floating-Point value
CVTSS2SD             Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value
CVTTPD2DQ            Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers
CVTTPD2PI            Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers
CVTTPS2DQ            Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values
CVTTSD2SI            Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Dword Integer
CVTTSD2SI            Convert with Truncation Scalar Double-Precision Floating-Point Value To Signed Qword Integer
MOVD                 Move doubleword
MOVD                 Move doubleword
MOVQ                 Move quadword
MOVQ                 Move quadword
MOVQ                 Move quadword
MOVQ                 Move quadword
PMOVMSKB             Move a byte mask, zeroing the upper bits of the register
PEXTRW               Extract specified word and move it to reg, setting bits 15-0 and zeroing the rest
PINSRW               Move low word at the specified word position
PACKSSDW             Converts 4 packed signed doubleword integers into 8 packed signed word integers with saturation
PACKSSWB             Converts 8 packed signed word integers into 16 packed signed byte integers with saturation
PACKUSWB             Converts 8 signed word integers into 16 unsigned byte integers with saturation
PADDB                Add packed byte integers
PADDW                Add packed word integers
PADDD                Add packed doubleword integers
PADDQ                Add packed quadword integers.
PADDSB               Add packed signed byte integers with saturation
PADDSW               Add packed signed word integers with saturation
PADDUSB              Add packed unsigned byte integers with saturation
PADDUSW              Add packed unsigned word integers with saturation
PAND                 Bitwise AND
PANDN                Bitwise AND NOT
POR                  Bitwise OR
PXOR                 Bitwise XOR
PCMPEQB              Compare packed bytes for equality.
PCMPEQW              Compare packed words for equality.
PCMPEQD              Compare packed doublewords for equality.
PCMPGTB              Compare packed signed byte integers for greater than
PCMPGTW              Compare packed signed word integers for greater than
PCMPGTD              Compare packed signed doubleword integers for greater than
PMULLW               Multiply packed signed word integers with saturation
PMULHW               Multiply the packed signed word integers, store the high 16 bits of the results
PMULHUW              Multiply packed unsigned word integers, store the high 16 bits of the results
PMULUDQ              Multiply packed unsigned doubleword integers
PSLLW                Shift words left while shifting in 0s
PSLLW                Shift words left while shifting in 0s
PSLLD                Shift doublewords left while shifting in 0s
PSLLD                Shift doublewords left while shifting in 0s
PSLLQ                Shift quadwords left while shifting in 0s
PSLLQ                Shift quadwords left while shifting in 0s
PSRAD                Shift doubleword right while shifting in sign bits
PSRAD                Shift doublewords right while shifting in sign bits
PSRAW                Shift words right while shifting in sign bits
PSRAW                Shift words right while shifting in sign bits
PSRLW                Shift words right while shifting in 0s
PSRLW                Shift words right while shifting in 0s
PSRLD                Shift doublewords right while shifting in 0s
PSRLD                Shift doublewords right while shifting in 0s
PSRLQ                Shift quadwords right while shifting in 0s
PSRLQ                Shift quadwords right while shifting in 0s
PSUBB                Subtract packed byte integers
PSUBW                Subtract packed word integers
PSUBD                Subtract packed doubleword integers
PSUBQ                Subtract packed quadword integers.
PSUBSB               Subtract packed signed byte integers with saturation
PSUBSW               Subtract packed signed word integers with saturation
PMADDWD              Multiply the packed word integers, add adjacent doubleword results
PSUBUSB              Subtract packed unsigned byte integers with saturation
PSUBUSW              Subtract packed unsigned word integers with saturation
PUNPCKHBW            Unpack and interleave high-order bytes
PUNPCKHWD            Unpack and interleave high-order words
PUNPCKHDQ            Unpack and interleave high-order doublewords
PUNPCKLBW            Interleave low-order bytes
PUNPCKLWD            Interleave low-order words
PUNPCKLDQ            Interleave low-order doublewords
PAVGB                Average packed unsigned byte integers with rounding
PAVGW                Average packed unsigned word integers with rounding
PMINUB               Compare packed unsigned byte integers and store packed minimum values
PMINSW               Compare packed signed word integers and store packed minimum values
PMAXSW               Compare packed signed word integers and store maximum packed values
PMAXUB               Compare packed unsigned byte integers and store packed maximum values
PSADBW               Computes the absolute differences of the packed unsigned byte integers; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results
MASKMOVDQU           Non-Temporal Store of Selected Bytes from an XMM Register into Memory
MOVDQ2Q              Move low quadword from XMM to MMX register.
MOVDQA               Move aligned double quadword
MOVDQA               Move aligned double quadword
MOVDQU               Move unaligned double quadword
MOVDQU               Move unaligned double quadword
MOVQ2DQ              Move quadword from MMX register to low quadword of XMM register
MOVNTDQ              Store Packed Integers Using Non-Temporal Hint
PSHUFHW              Shuffle packed high words.
PSHUFLW              Shuffle packed low words.
PSHUFD               Shuffle packed doublewords.
PSLLDQ               Packed shift left logical double quadwords.
PSRLDQ               Packed shift right logical double quadwords.
PUNPCKHQDQ           Unpack and interleave high-order quadwords,
PUNPCKLQDQ           Interleave low quadwords,
ADDSUBPS             Add/subtract single-precision floating-point values
ADDSUBPD             Add/subtract double-precision floating-point values
MOVDDUP              Move double-precision floating-point value and duplicate
MOVSLDUP             Move and duplicate even index single-precision floating-point values
MOVSHDUP             Move and duplicate odd index single-precision floating-point values
HADDPS               Horizontal add packed single-precision floating-point values
HADDPD               Horizontal add packed double-precision floating-point values
HSUBPS               Horizontal subtract packed single-precision floating-point values
HSUBPD               Horizontal subtract packed double-precision floating-point values
LDDQU                Load unaligned data and return double quadword
PSIGNB               Negate/zero/preserve packed byte integers depending on corresponding sign
PSIGNW               Negate/zero/preserve packed word integers depending on corresponding sign
PSIGND               Negate/zero/preserve packed doubleword integers depending on corresponding
PSHUFB               Shuffle bytes
PMULHRSW             Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits
PMADDUBSW            Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words
PHSUBW               Subtract and pack 16-bit signed integers horizontally
PHSUBSW              Subtract and pack 16-bit signed integer horizontally with saturation
PHSUBD               Subtract and pack 32-bit signed integers horizontally
PHADDSW              Add and pack 16-bit signed integers horizontally with saturation
PHADDW               Add and pack 16-bit integers horizontally
PHADDD               Add and pack 32-bit integers horizontally
PALIGNR              Concatenate destination and source operands, extract byte-aligned result shifted to the right
PABSB                Compute the absolute value of bytes and store unsigned result
PABSW                Compute the absolute value of 16-bit integers and store unsigned result
PABSD                Compute the absolute value of 32-bit integers and store unsigned result
DPPS                 Selectively multiply packed SP floating-point values, add and selectively store
DPPD                 Selectively multiply packed DP floating-point values, add and selectively store
BLENDPS              Select packed single precision floating-point values from specified mask
BLENDVPS             Select packed single precision floating-point values from specified mask
BLENDPD              Select packed DP-FP values from specified mask
BLENDVPD             Select packed DP FP values from specified mask
ROUNDPS              Round packed single precision floating-point values
ROUNDSS              Round the low packed single precision floating-point value
ROUNDPD              Round packed double precision floating-point values
ROUNDSD              Round the low packed double precision floating-point value
INSERTPS             Insert a selected single-precision floating-point value at the specified destination element and zero out destination elements
EXTRACTPS            Extract one single-precision floating-point value at specified offset and store the result (zero-extended, if applicable)
MPSADBW              Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers with starting offset
PHMINPOSUW           Find the minimum unsigned word
PMULLD               Multiply the packed dword signed integers and store the low 32 bits
PMULDQ               Multiply packed signed doubleword integers and store quadword result
PBLENDVB             Select byte values from specified mask
PBLENDW              Select words from specified mask
PMINSB               Compare packed signed byte integers
PMINUW               Compare packed unsigned word integers
PMINSD               Compare packed signed dword integers
PMINUD               Compare packed unsigned dword integers
PMAXSB               Compare packed signed byte integers
PMAXUW               Compare packed unsigned word integers
PMAXSD               Compare packed signed dword integers
PMAXUD               Compare packed unsigned dword integers
PINSRB               Insert a byte integer value at specified destination element
PINSRD               Insert a dword integer value at specified destination element
PINSRQ               Insert a qword integer value at specified destination element
PEXTRB               Extract a byte integer value at source byte offset, upper bits are zeroed.
PEXTRW               Extract word and copy to lowest 16 bits, zero-extended
PEXTRD               Extract a dword integer value at source dword offset
PEXTRQ               Extract a qword integer value at source qword offset
PMOVSXBW             Sign extend 8 packed 8-bit integers to 8 packed 16-bit integers
PMOVZXBW             Zero extend 8 packed 8-bit integers to 8 packed 16-bit integers
PMOVSXBD             Sign extend 4 packed 8-bit integers to 4 packed 32-bit integers
PMOVZXBD             Zero extend 4 packed 8-bit integers to 4 packed 32-bit integers
PMOVSXBQ             Sign extend 2 packed 8-bit integers to 2 packed 64-bit integers
PMOVZXBQ             Zero extend 2 packed 8-bit integers to 2 packed 64-bit integers
PMOVSXWD             Sign extend 4 packed 16-bit integers to 4 packed 32-bit integers
PMOVZXWD             Zero extend 4 packed 16-bit integers to 4 packed 32-bit integers
PMOVSXWQ             Sign extend 2 packed 16-bit integers to 2 packed 64-bit integers
PMOVZXWQ             Zero extend 2 packed 16-bit integers to 2 packed 64-bit integers
PMOVSXDQ             Sign extend 2 packed 32-bit integers to 2 packed 64-bit integers
PMOVZXDQ             Zero extend 2 packed 32-bit integers to 2 packed 64-bit integers
PTEST                Set ZF if AND result is all 0s, set CF if AND NOT result is all 0s
PCMPEQQ              Compare packed qwords for equality
PACKUSDW             Convert 2 ? 4 packed signed doubleword integers into 8 packed unsigned word integers with saturation
MOVNTDQA             Move double quadword using non-temporal hint if WC memory type
PCMPESTRI            Packed comparison of string data with explicit lengths, generating an index
PCMPESTRM            Packed comparison of string data with explicit lengths, generating a mask
PCMPISTRI            Packed comparison of string data with implicit lengths, generating an index
PCMPISTRM            Packed comparison of string data with implicit lengths, generating a mask
PCMPGTQ              Compare packed signed qwords for greater than.
VFMADDPD             Fused Multiply-Add of Packed Double-Precision Floating-Point Values
VFMADDPS             Fused Multiply-Add of Packed Single-Precision Floating-Point Values
VFMADDSD             Fused Multiply-Add of Scalar Double-Precision Floating-Point Values
VFMADDSS             Fused Multiply-Add of Scalar Single-Precision Floating-Point Values
VFMADDSUBPD          Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values
VFMADDSUBPS          Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values
VFMSUBADDPD          Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values
VFMSUBADDPS          Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values
VFMSUBPD             Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values
VFMSUBPS             Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values
VFMSUBSD             Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values
VFMSUBSS             Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values
VFNMADDPD            Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values
VFNMADDPS            Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values
VFNMADDSD            Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values
VFNMADDSS            Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values
VFNMSUBPD            Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values
VFNMSUBPS            Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values
VFNMSUBSD            Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values
VFNMSUBSS            Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values
AESENC               Perform one round of an AES encryption flow
AESENCLAST           Perform the last round of an AES encryption flow
AESDEC               Perform one round of an AES decryption flow
AESDECLAST           Perform the last round of an AES decryption flow
AESKEYGENASSIST      Assist in AES round key generation
AESIMC               Assist in AES Inverse Mix Columns
